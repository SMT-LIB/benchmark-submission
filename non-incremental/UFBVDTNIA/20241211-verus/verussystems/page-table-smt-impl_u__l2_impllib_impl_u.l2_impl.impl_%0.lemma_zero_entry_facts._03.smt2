(set-info :smt-lib-version 2.6)
(set-logic UFBVDTNIA)
(set-info :source |
Generated by: Amar Shah
Generated on: 2024-12-11
Generator: Verus
Application: Verification of Rust Program
Target solver: z3
Time limit: 10
Benchmarks generated by the Rust verifier Verus (https://verus-lang.github.io/verus/guide/) on the project Verus Systems (https://dl.acm.org/doi/10.1145/3694715.3695952) and processed using Mariposa (https://github.com/secure-foundations/mariposa). z3 solves this without nonlinear, but it cannot be expressed in SMTLib without a nonlinear theory.
This benchmarks was originally run with z3 with the following options:
    (set-option :auto_config false)
    (set-option :smt.mbqi false)
    (set-option :smt.case_split 3)
    (set-option :smt.qi.eager_threshold 100.0)
    (set-option :smt.delay_units true)
    (set-option :smt.arith.solver 2)
    (set-option :smt.arith.nl false)
    (set-option :pi.enabled false)
    (set-option :rewriter.sort_disjunctions false)
    (set-option :sat.euf true)
    (set-option :tactic.default_tactic sat)
    (set-option :smt.ematching false)
    (set-option :smt.case_split 0)
|)
(set-info :license "https://creativecommons.org/licenses/by/4.0/")
(set-info :category "industrial")
(set-info :status unsat)
(declare-sort %%Function%% 0)
(declare-sort FuelId 0)
(declare-sort Fuel 0)
(declare-const zero Fuel)
(declare-fun succ (Fuel) Fuel)
(declare-fun fuel_bool (FuelId) Bool)
(declare-fun fuel_bool_default (FuelId) Bool)
(declare-const fuel_defaults Bool)
(assert (=> fuel_defaults (forall ((id FuelId)) (! (= (fuel_bool id) (fuel_bool_default id)) :pattern ((fuel_bool id))))))
(declare-datatypes ((fndef 0)) (((fndef_singleton ))))
(declare-sort Poly 0)
(declare-sort Height 0)
(declare-fun I (Int) Poly)
(declare-fun B (Bool) Poly)
(declare-fun F (fndef) Poly)
(declare-fun %I (Poly) Int)
(declare-fun %B (Poly) Bool)
(declare-fun %F (Poly) fndef)
(declare-sort Type 0)
(declare-const BOOL Type)
(declare-const INT Type)
(declare-const NAT Type)
(declare-const CHAR Type)
(declare-fun UINT (Int) Type)
(declare-fun SINT (Int) Type)
(declare-fun CONST_INT (Int) Type)
(declare-sort Dcr 0)
(declare-const $ Dcr)
(declare-fun REF (Dcr) Dcr)
(declare-fun MUT_REF (Dcr) Dcr)
(declare-fun BOX (Dcr Type Dcr) Dcr)
(declare-fun RC (Dcr Type Dcr) Dcr)
(declare-fun ARC (Dcr Type Dcr) Dcr)
(declare-fun GHOST (Dcr) Dcr)
(declare-fun TRACKED (Dcr) Dcr)
(declare-fun NEVER (Dcr) Dcr)
(declare-fun CONST_PTR (Dcr) Dcr)
(declare-fun ARRAY (Dcr Type Dcr Type) Type)
(declare-fun SLICE (Dcr Type) Type)
(declare-const STRSLICE Type)
(declare-const ALLOCATOR_GLOBAL Type)
(declare-fun PTR (Dcr Type) Type)
(declare-fun has_type (Poly Type) Bool)
(declare-fun as_type (Poly Type) Poly)
(declare-fun mk_fun (%%Function%%) %%Function%%)
(declare-fun const_int (Type) Int)
(assert (forall ((i Int)) (! (= i (const_int (CONST_INT i))) :pattern ((CONST_INT i)))))
(assert (forall ((b Bool)) (! (has_type (B b) BOOL) :pattern ((has_type (B b) BOOL)))))
(assert (forall ((x Poly) (True Type)) (! (and (has_type (as_type x True) True) (=> (has_type x True) (= x (as_type x True)))) :pattern ((as_type x True)))))
(assert (forall ((x %%Function%%)) (! (= (mk_fun x) x) :pattern ((mk_fun x)))))
(assert (forall ((x Bool)) (! (= x (%B (B x))) :pattern ((B x)))))
(assert (forall ((x Int)) (! (= x (%I (I x))) :pattern ((I x)))))
(assert (forall ((x Poly)) (! (=> (has_type x BOOL) (= x (B (%B x)))) :pattern ((has_type x BOOL)))))
(assert (forall ((x Poly)) (! (=> (has_type x INT) (= x (I (%I x)))) :pattern ((has_type x INT)))))
(assert (forall ((x Poly)) (! (=> (has_type x NAT) (= x (I (%I x)))) :pattern ((has_type x NAT)))))
(assert (forall ((bits Int) (x Poly)) (! (=> (has_type x (UINT bits)) (= x (I (%I x)))) :pattern ((has_type x (UINT bits))))))
(assert (forall ((bits Int) (x Poly)) (! (=> (has_type x (SINT bits)) (= x (I (%I x)))) :pattern ((has_type x (SINT bits))))))
(assert (forall ((x Poly)) (! (=> (has_type x CHAR) (= x (I (%I x)))) :pattern ((has_type x CHAR)))))
(declare-fun ext_eq (Bool Type Poly Poly) Bool)
(assert (forall ((deep Bool) (True Type) (x Poly) (y Poly)) (! (= (= x y) (ext_eq deep True x y)) :pattern ((ext_eq deep True x y)))))
(declare-const SZ Int)
(assert (= SZ 64))
(declare-fun uHi (Int) Int)
(declare-fun iLo (Int) Int)
(declare-fun iHi (Int) Int)
(assert (= (uHi 8) 256))
(assert (= (uHi 16) 65536))
(assert (= (uHi 32) 4294967296))
(assert (= (uHi 64) 18446744073709551616))
(assert (= (uHi 128) (+ 1 340282366920938463463374607431768211455)))
(assert (= (iLo 8) (- 128)))
(assert (= (iLo 16) (- 32768)))
(assert (= (iLo 32) (- 2147483648)))
(assert (= (iLo 64) (- 9223372036854775808)))
(assert (= (iLo 128) (- 170141183460469231731687303715884105728)))
(assert (= (iHi 8) 128))
(assert (= (iHi 16) 32768))
(assert (= (iHi 32) 2147483648))
(assert (= (iHi 64) 9223372036854775808))
(assert (= (iHi 128) 170141183460469231731687303715884105728))
(declare-fun nClip (Int) Int)
(declare-fun uClip (Int Int) Int)
(declare-fun iClip (Int Int) Int)
(declare-fun charClip (Int) Int)
(assert (forall ((i Int)) (! (and (<= 0 (nClip i)) (=> (<= 0 i) (= i (nClip i)))) :pattern ((nClip i)))))
(assert (forall ((bits Int) (i Int)) (! (and (<= 0 (uClip bits i)) (< (uClip bits i) (uHi bits)) (=> (and (<= 0 i) (< i (uHi bits))) (= i (uClip bits i)))) :pattern ((uClip bits i)))))
(assert (forall ((bits Int) (i Int)) (! (and (<= (iLo bits) (iClip bits i)) (< (iClip bits i) (iHi bits)) (=> (and (<= (iLo bits) i) (< i (iHi bits))) (= i (iClip bits i)))) :pattern ((iClip bits i)))))
(assert (forall ((i Int)) (! (and (or (and (<= 0 (charClip i)) (<= (charClip i) 55295)) (and (<= 57344 (charClip i)) (<= (charClip i) 1114111))) (=> (or (and (<= 0 i) (<= i 55295)) (and (<= 57344 i) (<= i 1114111))) (= i (charClip i)))) :pattern ((charClip i)))))
(declare-fun uInv (Int Int) Bool)
(declare-fun iInv (Int Int) Bool)
(declare-fun charInv (Int) Bool)
(assert (forall ((bits Int) (i Int)) (! (= (uInv bits i) (and (<= 0 i) (< i (uHi bits)))) :pattern ((uInv bits i)))))
(assert (forall ((bits Int) (i Int)) (! (= (iInv bits i) (and (<= (iLo bits) i) (< i (iHi bits)))) :pattern ((iInv bits i)))))
(assert (forall ((i Int)) (! (= (charInv i) (or (and (<= 0 i) (<= i 55295)) (and (<= 57344 i) (<= i 1114111)))) :pattern ((charInv i)))))
(assert (forall ((x Int)) (! (has_type (I x) INT) :pattern ((has_type (I x) INT)))))
(assert (forall ((x Int)) (! (=> (<= 0 x) (has_type (I x) NAT)) :pattern ((has_type (I x) NAT)))))
(assert (forall ((bits Int) (x Int)) (! (=> (uInv bits x) (has_type (I x) (UINT bits))) :pattern ((has_type (I x) (UINT bits))))))
(assert (forall ((bits Int) (x Int)) (! (=> (iInv bits x) (has_type (I x) (SINT bits))) :pattern ((has_type (I x) (SINT bits))))))
(assert (forall ((x Int)) (! (=> (charInv x) (has_type (I x) CHAR)) :pattern ((has_type (I x) CHAR)))))
(assert (forall ((x Poly)) (! (=> (has_type x NAT) (<= 0 (%I x))) :pattern ((has_type x NAT)))))
(assert (forall ((bits Int) (x Poly)) (! (=> (has_type x (UINT bits)) (uInv bits (%I x))) :pattern ((has_type x (UINT bits))))))
(assert (forall ((bits Int) (x Poly)) (! (=> (has_type x (SINT bits)) (iInv bits (%I x))) :pattern ((has_type x (SINT bits))))))
(declare-fun Add (Int Int) Int)
(declare-fun Sub (Int Int) Int)
(declare-fun Mul (Int Int) Int)
(declare-fun EucDiv (Int Int) Int)
(declare-fun EucMod (Int Int) Int)
(assert (forall ((x Int) (y Int)) (! (= (Add x y) (+ x y)) :pattern ((Add x y)))))
(assert (forall ((x Int) (y Int)) (! (= (Sub x y) (- x y)) :pattern ((Sub x y)))))
(assert (forall ((x Int) (y Int)) (! (= (Mul x y) (* x y)) :pattern ((Mul x y)))))
(assert (forall ((x Int) (y Int)) (! (= (EucDiv x y) (div x y)) :pattern ((EucDiv x y)))))
(assert (forall ((x Int) (y Int)) (! (= (EucMod x y) (mod x y)) :pattern ((EucMod x y)))))
(assert (forall ((x Int) (y Int)) (! (=> (and (<= 0 x) (<= 0 y)) (<= 0 (Mul x y))) :pattern ((Mul x y)))))
(assert (forall ((x Int) (y Int)) (! (=> (and (<= 0 x) (< 0 y)) (and (<= 0 (EucDiv x y)) (<= (EucDiv x y) x))) :pattern ((EucDiv x y)))))
(assert (forall ((x Int) (y Int)) (! (=> (and (<= 0 x) (< 0 y)) (and (<= 0 (EucMod x y)) (< (EucMod x y) y))) :pattern ((EucMod x y)))))
(declare-fun bitxor (Poly Poly) Int)
(declare-fun bitand (Poly Poly) Int)
(declare-fun bitor (Poly Poly) Int)
(declare-fun bitshr (Poly Poly) Int)
(declare-fun bitshl (Poly Poly) Int)
(declare-fun bitnot (Poly) Int)
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (uInv bits (%I x)) (uInv bits (%I y))) (uInv bits (bitxor x y))) :pattern ((uClip bits (bitxor x y))))))
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (iInv bits (%I x)) (iInv bits (%I y))) (iInv bits (bitxor x y))) :pattern ((iClip bits (bitxor x y))))))
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (uInv bits (%I x)) (uInv bits (%I y))) (uInv bits (bitor x y))) :pattern ((uClip bits (bitor x y))))))
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (iInv bits (%I x)) (iInv bits (%I y))) (iInv bits (bitor x y))) :pattern ((iClip bits (bitor x y))))))
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (uInv bits (%I x)) (uInv bits (%I y))) (uInv bits (bitand x y))) :pattern ((uClip bits (bitand x y))))))
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (iInv bits (%I x)) (iInv bits (%I y))) (iInv bits (bitand x y))) :pattern ((iClip bits (bitand x y))))))
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (uInv bits (%I x)) (<= 0 (%I y))) (uInv bits (bitshr x y))) :pattern ((uClip bits (bitshr x y))))))
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (iInv bits (%I x)) (<= 0 (%I y))) (iInv bits (bitshr x y))) :pattern ((iClip bits (bitshr x y))))))
(declare-fun singular_mod (Int Int) Int)
(assert (forall ((x Int) (y Int)) (! (=> (not (= y 0)) (= (EucMod x y) (singular_mod x y))) :pattern ((singular_mod x y)))))
(declare-fun closure_req (Type Dcr Type Poly Poly) Bool)
(declare-fun closure_ens (Type Dcr Type Poly Poly Poly) Bool)
(declare-fun height (Poly) Height)
(declare-fun height_lt (Height Height) Bool)
(declare-fun fun_from_recursive_field (Poly) Poly)
(declare-fun check_decrease_int (Int Int Bool) Bool)
(assert (forall ((cur Int) (prev Int) (otherwise Bool)) (! (= (check_decrease_int cur prev otherwise) (or (and (<= 0 cur) (< cur prev)) (and (= cur prev) otherwise))) :pattern ((check_decrease_int cur prev otherwise)))))
(declare-fun check_decrease_height (Poly Poly Bool) Bool)
(assert (forall ((cur Poly) (prev Poly) (otherwise Bool)) (! (= (check_decrease_height cur prev otherwise) (or (height_lt (height cur) (height prev)) (and (= (height cur) (height prev)) otherwise))) :pattern ((check_decrease_height cur prev otherwise)))))
(declare-fun partial-order (Height Height) Bool)
(assert (forall ((x Height)) (partial-order x x)))
(assert (forall ((x Height) (y Height)) (=> (and (partial-order x y) (partial-order y x)) (= x y))))
(assert (forall ((x Height) (y Height) (z Height)) (=> (and (partial-order x y) (partial-order y z)) (partial-order x z))))
(assert (forall ((x Height) (y Height)) (! (= (height_lt x y) (and (partial-order x y) (not (= x y)))) :pattern ((height_lt x y)))))
(declare-const fuel%vstd!seq.impl&%0.spec_index. FuelId)
(declare-const fuel%vstd!seq.axiom_seq_index_decreases. FuelId)
(declare-const fuel%vstd!seq.axiom_seq_ext_equal. FuelId)
(declare-const fuel%vstd!seq.axiom_seq_ext_equal_deep. FuelId)
(declare-const fuel%vstd!set.axiom_set_ext_equal. FuelId)
(declare-const fuel%vstd!set.axiom_set_ext_equal_deep. FuelId)
(declare-const fuel%lib!impl_u.l2_impl.addr_is_zero_padded. FuelId)
(declare-const fuel%lib!impl_u.l2_impl.impl&%0.hp_pat_is_zero. FuelId)
(declare-const fuel%lib!spec_t.hardware.impl&%1.get_Directory_addr. FuelId)
(declare-const fuel%lib!spec_t.hardware.impl&%1.get_Directory_flag_RW. FuelId)
(declare-const fuel%lib!spec_t.hardware.impl&%1.get_Directory_flag_US. FuelId)
(declare-const fuel%lib!spec_t.hardware.impl&%1.get_Directory_flag_XD. FuelId)
(declare-const fuel%lib!spec_t.hardware.impl&%1.get_Page_addr. FuelId)
(declare-const fuel%lib!spec_t.hardware.impl&%1.get_Page_flag_RW. FuelId)
(declare-const fuel%lib!spec_t.hardware.impl&%1.get_Page_flag_US. FuelId)
(declare-const fuel%lib!spec_t.hardware.impl&%1.get_Page_flag_XD. FuelId)
(declare-const fuel%lib!spec_t.hardware.MASK_FLAG_P. FuelId)
(declare-const fuel%lib!spec_t.hardware.MASK_FLAG_RW. FuelId)
(declare-const fuel%lib!spec_t.hardware.MASK_FLAG_US. FuelId)
(declare-const fuel%lib!spec_t.hardware.MASK_FLAG_PWT. FuelId)
(declare-const fuel%lib!spec_t.hardware.MASK_FLAG_PCD. FuelId)
(declare-const fuel%lib!spec_t.hardware.MASK_FLAG_A. FuelId)
(declare-const fuel%lib!spec_t.hardware.MASK_FLAG_XD. FuelId)
(declare-const fuel%lib!spec_t.hardware.MASK_PG_FLAG_D. FuelId)
(declare-const fuel%lib!spec_t.hardware.MASK_PG_FLAG_G. FuelId)
(declare-const fuel%lib!spec_t.hardware.MASK_PG_FLAG_PAT. FuelId)
(declare-const fuel%lib!spec_t.hardware.MASK_L1_PG_FLAG_PS. FuelId)
(declare-const fuel%lib!spec_t.hardware.MASK_L2_PG_FLAG_PS. FuelId)
(declare-const fuel%lib!spec_t.hardware.MASK_L3_PG_FLAG_PAT. FuelId)
(declare-const fuel%lib!spec_t.hardware.MASK_ADDR_SPEC. FuelId)
(declare-const fuel%lib!spec_t.hardware.MASK_L1_PG_ADDR_SPEC. FuelId)
(declare-const fuel%lib!spec_t.hardware.MASK_L2_PG_ADDR_SPEC. FuelId)
(declare-const fuel%lib!spec_t.hardware.MASK_L3_PG_ADDR_SPEC. FuelId)
(declare-const fuel%lib!spec_t.hardware.MASK_DIR_ADDR_SPEC. FuelId)
(declare-const fuel%lib!spec_t.hardware.impl&%3.view. FuelId)
(declare-const fuel%lib!spec_t.hardware.impl&%3.all_mb0_bits_are_zero. FuelId)
(declare-const fuel%lib!spec_t.hardware.impl&%3.layer. FuelId)
(declare-const fuel%lib!definitions_t.MAX_PHYADDR_SPEC. FuelId)
(declare-const fuel%lib!definitions_t.PAGE_SIZE. FuelId)
(declare-const fuel%lib!definitions_t.L3_ENTRY_SIZE. FuelId)
(declare-const fuel%lib!definitions_t.L2_ENTRY_SIZE. FuelId)
(declare-const fuel%lib!definitions_t.L1_ENTRY_SIZE. FuelId)
(declare-const fuel%lib!definitions_t.aligned. FuelId)
(declare-const fuel%vstd!array.group_array_axioms. FuelId)
(declare-const fuel%vstd!map.group_map_axioms. FuelId)
(declare-const fuel%vstd!multiset.group_multiset_axioms. FuelId)
(declare-const fuel%vstd!raw_ptr.group_raw_ptr_axioms. FuelId)
(declare-const fuel%vstd!seq.group_seq_axioms. FuelId)
(declare-const fuel%vstd!seq_lib.group_seq_lib_default. FuelId)
(declare-const fuel%vstd!set.group_set_axioms. FuelId)
(declare-const fuel%vstd!set_lib.group_set_lib_axioms. FuelId)
(declare-const fuel%vstd!slice.group_slice_axioms. FuelId)
(declare-const fuel%vstd!string.group_string_axioms. FuelId)
(declare-const fuel%vstd!std_specs.bits.group_bits_axioms. FuelId)
(declare-const fuel%vstd!std_specs.control_flow.group_control_flow_axioms. FuelId)
(declare-const fuel%vstd!std_specs.range.group_range_axioms. FuelId)
(declare-const fuel%vstd!std_specs.vec.group_vec_axioms. FuelId)
(declare-const fuel%vstd!group_vstd_default. FuelId)
(assert (distinct fuel%vstd!seq.impl&%0.spec_index. fuel%vstd!seq.axiom_seq_index_decreases. fuel%vstd!seq.axiom_seq_ext_equal. fuel%vstd!seq.axiom_seq_ext_equal_deep. fuel%vstd!set.axiom_set_ext_equal. fuel%vstd!set.axiom_set_ext_equal_deep. fuel%lib!impl_u.l2_impl.addr_is_zero_padded. fuel%lib!impl_u.l2_impl.impl&%0.hp_pat_is_zero. fuel%lib!spec_t.hardware.impl&%1.get_Directory_addr. fuel%lib!spec_t.hardware.impl&%1.get_Directory_flag_RW. fuel%lib!spec_t.hardware.impl&%1.get_Directory_flag_US. fuel%lib!spec_t.hardware.impl&%1.get_Directory_flag_XD. fuel%lib!spec_t.hardware.impl&%1.get_Page_addr. fuel%lib!spec_t.hardware.impl&%1.get_Page_flag_RW. fuel%lib!spec_t.hardware.impl&%1.get_Page_flag_US. fuel%lib!spec_t.hardware.impl&%1.get_Page_flag_XD. fuel%lib!spec_t.hardware.MASK_FLAG_P. fuel%lib!spec_t.hardware.MASK_FLAG_RW. fuel%lib!spec_t.hardware.MASK_FLAG_US. fuel%lib!spec_t.hardware.MASK_FLAG_PWT. fuel%lib!spec_t.hardware.MASK_FLAG_PCD. fuel%lib!spec_t.hardware.MASK_FLAG_A. fuel%lib!spec_t.hardware.MASK_FLAG_XD. fuel%lib!spec_t.hardware.MASK_PG_FLAG_D. fuel%lib!spec_t.hardware.MASK_PG_FLAG_G. fuel%lib!spec_t.hardware.MASK_PG_FLAG_PAT. fuel%lib!spec_t.hardware.MASK_L1_PG_FLAG_PS. fuel%lib!spec_t.hardware.MASK_L2_PG_FLAG_PS. fuel%lib!spec_t.hardware.MASK_L3_PG_FLAG_PAT. fuel%lib!spec_t.hardware.MASK_ADDR_SPEC. fuel%lib!spec_t.hardware.MASK_L1_PG_ADDR_SPEC. fuel%lib!spec_t.hardware.MASK_L2_PG_ADDR_SPEC. fuel%lib!spec_t.hardware.MASK_L3_PG_ADDR_SPEC. fuel%lib!spec_t.hardware.MASK_DIR_ADDR_SPEC. fuel%lib!spec_t.hardware.impl&%3.view. fuel%lib!spec_t.hardware.impl&%3.all_mb0_bits_are_zero. fuel%lib!spec_t.hardware.impl&%3.layer. fuel%lib!definitions_t.MAX_PHYADDR_SPEC. fuel%lib!definitions_t.PAGE_SIZE. fuel%lib!definitions_t.L3_ENTRY_SIZE. fuel%lib!definitions_t.L2_ENTRY_SIZE. fuel%lib!definitions_t.L1_ENTRY_SIZE. fuel%lib!definitions_t.aligned. fuel%vstd!array.group_array_axioms. fuel%vstd!map.group_map_axioms. fuel%vstd!multiset.group_multiset_axioms. fuel%vstd!raw_ptr.group_raw_ptr_axioms. fuel%vstd!seq.group_seq_axioms. fuel%vstd!seq_lib.group_seq_lib_default. fuel%vstd!set.group_set_axioms. fuel%vstd!set_lib.group_set_lib_axioms. fuel%vstd!slice.group_slice_axioms. fuel%vstd!string.group_string_axioms. fuel%vstd!std_specs.bits.group_bits_axioms. fuel%vstd!std_specs.control_flow.group_control_flow_axioms. fuel%vstd!std_specs.range.group_range_axioms. fuel%vstd!std_specs.vec.group_vec_axioms. fuel%vstd!group_vstd_default.))
(assert (=> (fuel_bool_default fuel%vstd!seq.group_seq_axioms.) (and (fuel_bool_default fuel%vstd!seq.axiom_seq_index_decreases.) (fuel_bool_default fuel%vstd!seq.axiom_seq_ext_equal.) (fuel_bool_default fuel%vstd!seq.axiom_seq_ext_equal_deep.))))
(assert (=> (fuel_bool_default fuel%vstd!set.group_set_axioms.) (and (fuel_bool_default fuel%vstd!set.axiom_set_ext_equal.) (fuel_bool_default fuel%vstd!set.axiom_set_ext_equal_deep.))))
(assert (fuel_bool_default fuel%vstd!group_vstd_default.))
(assert (=> (fuel_bool_default fuel%vstd!group_vstd_default.) (and (fuel_bool_default fuel%vstd!seq.group_seq_axioms.) (fuel_bool_default fuel%vstd!seq_lib.group_seq_lib_default.) (fuel_bool_default fuel%vstd!map.group_map_axioms.) (fuel_bool_default fuel%vstd!set.group_set_axioms.) (fuel_bool_default fuel%vstd!set_lib.group_set_lib_axioms.) (fuel_bool_default fuel%vstd!std_specs.bits.group_bits_axioms.) (fuel_bool_default fuel%vstd!std_specs.control_flow.group_control_flow_axioms.) (fuel_bool_default fuel%vstd!std_specs.vec.group_vec_axioms.) (fuel_bool_default fuel%vstd!slice.group_slice_axioms.) (fuel_bool_default fuel%vstd!array.group_array_axioms.) (fuel_bool_default fuel%vstd!multiset.group_multiset_axioms.) (fuel_bool_default fuel%vstd!string.group_string_axioms.) (fuel_bool_default fuel%vstd!std_specs.range.group_range_axioms.) (fuel_bool_default fuel%vstd!raw_ptr.group_raw_ptr_axioms.))))
(declare-sort vstd!seq.Seq<core!option.Option<lib!impl_u.l2_impl.PTDir.>.>. 0)
(declare-sort vstd!set.Set<lib!definitions_t.MemRegion.>. 0)
(declare-datatypes ((core!option.Option. 0) (lib!impl_u.l2_impl.PTDir. 0) (lib!spec_t.hardware.GhostPageDirectoryEntry. 0) (lib!spec_t.hardware.PageDirectoryEntry. 0) (lib!definitions_t.MemRegion. 0) (lib!definitions_t.MemRegionExec. 0) (lib!definitions_t.Flags. 0) (lib!definitions_t.PageTableEntryExec. 0) (tuple%0. 0)) (((core!option.Option./None ) (core!option.Option./Some (core!option.Option./Some/?0 Poly))) ((lib!impl_u.l2_impl.PTDir./PTDir (lib!impl_u.l2_impl.PTDir./PTDir/?region lib!definitions_t.MemRegion.) (lib!impl_u.l2_impl.PTDir./PTDir/?entries vstd!seq.Seq<core!option.Option<lib!impl_u.l2_impl.PTDir.>.>.) (lib!impl_u.l2_impl.PTDir./PTDir/?used_regions vstd!set.Set<lib!definitions_t.MemRegion.>.))) ((lib!spec_t.hardware.GhostPageDirectoryEntry./Directory (lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/?addr Int) (lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/?flag_P Bool) (lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/?flag_RW Bool) (lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/?flag_US Bool) (lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/?flag_PWT Bool) (lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/?flag_PCD Bool) (lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/?flag_A Bool) (lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/?flag_XD Bool)) (lib!spec_t.hardware.GhostPageDirectoryEntry./Page (lib!spec_t.hardware.GhostPageDirectoryEntry./Page/?addr Int) (lib!spec_t.hardware.GhostPageDirectoryEntry./Page/?flag_P Bool) (lib!spec_t.hardware.GhostPageDirectoryEntry./Page/?flag_RW Bool) (lib!spec_t.hardware.GhostPageDirectoryEntry./Page/?flag_US Bool) (lib!spec_t.hardware.GhostPageDirectoryEntry./Page/?flag_PWT Bool) (lib!spec_t.hardware.GhostPageDirectoryEntry./Page/?flag_PCD Bool) (lib!spec_t.hardware.GhostPageDirectoryEntry./Page/?flag_A Bool) (lib!spec_t.hardware.GhostPageDirectoryEntry./Page/?flag_D Bool) (lib!spec_t.hardware.GhostPageDirectoryEntry./Page/?flag_G Bool) (lib!spec_t.hardware.GhostPageDirectoryEntry./Page/?flag_PAT Bool) (lib!spec_t.hardware.GhostPageDirectoryEntry./Page/?flag_XD Bool)) (lib!spec_t.hardware.GhostPageDirectoryEntry./Empty )) ((lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/?entry Int) (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/?layer Int))) ((lib!definitions_t.MemRegion./MemRegion (lib!definitions_t.MemRegion./MemRegion/?base Int) (lib!definitions_t.MemRegion./MemRegion/?size Int))) ((lib!definitions_t.MemRegionExec./MemRegionExec (lib!definitions_t.MemRegionExec./MemRegionExec/?base Int) (lib!definitions_t.MemRegionExec./MemRegionExec/?size Int))) ((lib!definitions_t.Flags./Flags (lib!definitions_t.Flags./Flags/?is_writable Bool) (lib!definitions_t.Flags./Flags/?is_supervisor Bool) (lib!definitions_t.Flags./Flags/?disable_execute Bool))) ((lib!definitions_t.PageTableEntryExec./PageTableEntryExec (lib!definitions_t.PageTableEntryExec./PageTableEntryExec/?frame lib!definitions_t.MemRegionExec.) (lib!definitions_t.PageTableEntryExec./PageTableEntryExec/?flags lib!definitions_t.Flags.))) ((tuple%0./tuple%0 ))))
(declare-fun core!option.Option./Some/0 (core!option.Option.) Poly)
(declare-fun lib!impl_u.l2_impl.PTDir./PTDir/region (lib!impl_u.l2_impl.PTDir.) lib!definitions_t.MemRegion.)
(declare-fun lib!impl_u.l2_impl.PTDir./PTDir/entries (lib!impl_u.l2_impl.PTDir.) vstd!seq.Seq<core!option.Option<lib!impl_u.l2_impl.PTDir.>.>.)
(declare-fun lib!impl_u.l2_impl.PTDir./PTDir/used_regions (lib!impl_u.l2_impl.PTDir.) vstd!set.Set<lib!definitions_t.MemRegion.>.)
(declare-fun lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/addr (lib!spec_t.hardware.GhostPageDirectoryEntry.) Int)
(declare-fun lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/flag_P (lib!spec_t.hardware.GhostPageDirectoryEntry.) Bool)
(declare-fun lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/flag_RW (lib!spec_t.hardware.GhostPageDirectoryEntry.) Bool)
(declare-fun lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/flag_US (lib!spec_t.hardware.GhostPageDirectoryEntry.) Bool)
(declare-fun lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/flag_PWT (lib!spec_t.hardware.GhostPageDirectoryEntry.) Bool)
(declare-fun lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/flag_PCD (lib!spec_t.hardware.GhostPageDirectoryEntry.) Bool)
(declare-fun lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/flag_A (lib!spec_t.hardware.GhostPageDirectoryEntry.) Bool)
(declare-fun lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/flag_XD (lib!spec_t.hardware.GhostPageDirectoryEntry.) Bool)
(declare-fun lib!spec_t.hardware.GhostPageDirectoryEntry./Page/addr (lib!spec_t.hardware.GhostPageDirectoryEntry.) Int)
(declare-fun lib!spec_t.hardware.GhostPageDirectoryEntry./Page/flag_P (lib!spec_t.hardware.GhostPageDirectoryEntry.) Bool)
(declare-fun lib!spec_t.hardware.GhostPageDirectoryEntry./Page/flag_RW (lib!spec_t.hardware.GhostPageDirectoryEntry.) Bool)
(declare-fun lib!spec_t.hardware.GhostPageDirectoryEntry./Page/flag_US (lib!spec_t.hardware.GhostPageDirectoryEntry.) Bool)
(declare-fun lib!spec_t.hardware.GhostPageDirectoryEntry./Page/flag_PWT (lib!spec_t.hardware.GhostPageDirectoryEntry.) Bool)
(declare-fun lib!spec_t.hardware.GhostPageDirectoryEntry./Page/flag_PCD (lib!spec_t.hardware.GhostPageDirectoryEntry.) Bool)
(declare-fun lib!spec_t.hardware.GhostPageDirectoryEntry./Page/flag_A (lib!spec_t.hardware.GhostPageDirectoryEntry.) Bool)
(declare-fun lib!spec_t.hardware.GhostPageDirectoryEntry./Page/flag_D (lib!spec_t.hardware.GhostPageDirectoryEntry.) Bool)
(declare-fun lib!spec_t.hardware.GhostPageDirectoryEntry./Page/flag_G (lib!spec_t.hardware.GhostPageDirectoryEntry.) Bool)
(declare-fun lib!spec_t.hardware.GhostPageDirectoryEntry./Page/flag_PAT (lib!spec_t.hardware.GhostPageDirectoryEntry.) Bool)
(declare-fun lib!spec_t.hardware.GhostPageDirectoryEntry./Page/flag_XD (lib!spec_t.hardware.GhostPageDirectoryEntry.) Bool)
(declare-fun lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/entry (lib!spec_t.hardware.PageDirectoryEntry.) Int)
(declare-fun lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/layer (lib!spec_t.hardware.PageDirectoryEntry.) Int)
(declare-fun lib!definitions_t.MemRegion./MemRegion/base (lib!definitions_t.MemRegion.) Int)
(declare-fun lib!definitions_t.MemRegion./MemRegion/size (lib!definitions_t.MemRegion.) Int)
(declare-fun lib!definitions_t.MemRegionExec./MemRegionExec/base (lib!definitions_t.MemRegionExec.) Int)
(declare-fun lib!definitions_t.MemRegionExec./MemRegionExec/size (lib!definitions_t.MemRegionExec.) Int)
(declare-fun lib!definitions_t.Flags./Flags/is_writable (lib!definitions_t.Flags.) Bool)
(declare-fun lib!definitions_t.Flags./Flags/is_supervisor (lib!definitions_t.Flags.) Bool)
(declare-fun lib!definitions_t.Flags./Flags/disable_execute (lib!definitions_t.Flags.) Bool)
(declare-fun lib!definitions_t.PageTableEntryExec./PageTableEntryExec/frame (lib!definitions_t.PageTableEntryExec.) lib!definitions_t.MemRegionExec.)
(declare-fun lib!definitions_t.PageTableEntryExec./PageTableEntryExec/flags (lib!definitions_t.PageTableEntryExec.) lib!definitions_t.Flags.)
(declare-fun TYPE%core!option.Option. (Dcr Type) Type)
(declare-fun TYPE%vstd!seq.Seq. (Dcr Type) Type)
(declare-fun TYPE%vstd!set.Set. (Dcr Type) Type)
(declare-const TYPE%lib!impl_u.l2_impl.PTDir. Type)
(declare-const TYPE%lib!spec_t.hardware.GhostPageDirectoryEntry. Type)
(declare-const TYPE%lib!spec_t.hardware.PageDirectoryEntry. Type)
(declare-const TYPE%lib!definitions_t.MemRegion. Type)
(declare-const TYPE%lib!definitions_t.MemRegionExec. Type)
(declare-const TYPE%lib!definitions_t.Flags. Type)
(declare-const TYPE%lib!definitions_t.PageTableEntryExec. Type)
(declare-const TYPE%tuple%0. Type)
(declare-fun Poly%vstd!seq.Seq<core!option.Option<lib!impl_u.l2_impl.PTDir.>.>. (vstd!seq.Seq<core!option.Option<lib!impl_u.l2_impl.PTDir.>.>.) Poly)
(declare-fun %Poly%vstd!seq.Seq<core!option.Option<lib!impl_u.l2_impl.PTDir.>.>. (Poly) vstd!seq.Seq<core!option.Option<lib!impl_u.l2_impl.PTDir.>.>.)
(declare-fun Poly%vstd!set.Set<lib!definitions_t.MemRegion.>. (vstd!set.Set<lib!definitions_t.MemRegion.>.) Poly)
(declare-fun %Poly%vstd!set.Set<lib!definitions_t.MemRegion.>. (Poly) vstd!set.Set<lib!definitions_t.MemRegion.>.)
(declare-fun Poly%core!option.Option. (core!option.Option.) Poly)
(declare-fun %Poly%core!option.Option. (Poly) core!option.Option.)
(declare-fun Poly%lib!impl_u.l2_impl.PTDir. (lib!impl_u.l2_impl.PTDir.) Poly)
(declare-fun %Poly%lib!impl_u.l2_impl.PTDir. (Poly) lib!impl_u.l2_impl.PTDir.)
(declare-fun Poly%lib!spec_t.hardware.GhostPageDirectoryEntry. (lib!spec_t.hardware.GhostPageDirectoryEntry.) Poly)
(declare-fun %Poly%lib!spec_t.hardware.GhostPageDirectoryEntry. (Poly) lib!spec_t.hardware.GhostPageDirectoryEntry.)
(declare-fun Poly%lib!spec_t.hardware.PageDirectoryEntry. (lib!spec_t.hardware.PageDirectoryEntry.) Poly)
(declare-fun %Poly%lib!spec_t.hardware.PageDirectoryEntry. (Poly) lib!spec_t.hardware.PageDirectoryEntry.)
(declare-fun Poly%lib!definitions_t.MemRegion. (lib!definitions_t.MemRegion.) Poly)
(declare-fun %Poly%lib!definitions_t.MemRegion. (Poly) lib!definitions_t.MemRegion.)
(declare-fun Poly%lib!definitions_t.MemRegionExec. (lib!definitions_t.MemRegionExec.) Poly)
(declare-fun %Poly%lib!definitions_t.MemRegionExec. (Poly) lib!definitions_t.MemRegionExec.)
(declare-fun Poly%lib!definitions_t.Flags. (lib!definitions_t.Flags.) Poly)
(declare-fun %Poly%lib!definitions_t.Flags. (Poly) lib!definitions_t.Flags.)
(declare-fun Poly%lib!definitions_t.PageTableEntryExec. (lib!definitions_t.PageTableEntryExec.) Poly)
(declare-fun %Poly%lib!definitions_t.PageTableEntryExec. (Poly) lib!definitions_t.PageTableEntryExec.)
(declare-fun Poly%tuple%0. (tuple%0.) Poly)
(declare-fun %Poly%tuple%0. (Poly) tuple%0.)
(assert (forall ((x vstd!seq.Seq<core!option.Option<lib!impl_u.l2_impl.PTDir.>.>.)) (! (= x (%Poly%vstd!seq.Seq<core!option.Option<lib!impl_u.l2_impl.PTDir.>.>. (Poly%vstd!seq.Seq<core!option.Option<lib!impl_u.l2_impl.PTDir.>.>. x))) :pattern ((Poly%vstd!seq.Seq<core!option.Option<lib!impl_u.l2_impl.PTDir.>.>. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x (TYPE%vstd!seq.Seq. $ (TYPE%core!option.Option. $ TYPE%lib!impl_u.l2_impl.PTDir.))) (= x (Poly%vstd!seq.Seq<core!option.Option<lib!impl_u.l2_impl.PTDir.>.>. (%Poly%vstd!seq.Seq<core!option.Option<lib!impl_u.l2_impl.PTDir.>.>. x)))) :pattern ((has_type x (TYPE%vstd!seq.Seq. $ (TYPE%core!option.Option. $ TYPE%lib!impl_u.l2_impl.PTDir.)))))))
(assert (forall ((x vstd!seq.Seq<core!option.Option<lib!impl_u.l2_impl.PTDir.>.>.)) (! (has_type (Poly%vstd!seq.Seq<core!option.Option<lib!impl_u.l2_impl.PTDir.>.>. x) (TYPE%vstd!seq.Seq. $ (TYPE%core!option.Option. $ TYPE%lib!impl_u.l2_impl.PTDir.))) :pattern ((has_type (Poly%vstd!seq.Seq<core!option.Option<lib!impl_u.l2_impl.PTDir.>.>. x) (TYPE%vstd!seq.Seq. $ (TYPE%core!option.Option. $ TYPE%lib!impl_u.l2_impl.PTDir.)))))))
(assert (forall ((x vstd!set.Set<lib!definitions_t.MemRegion.>.)) (! (= x (%Poly%vstd!set.Set<lib!definitions_t.MemRegion.>. (Poly%vstd!set.Set<lib!definitions_t.MemRegion.>. x))) :pattern ((Poly%vstd!set.Set<lib!definitions_t.MemRegion.>. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x (TYPE%vstd!set.Set. $ TYPE%lib!definitions_t.MemRegion.)) (= x (Poly%vstd!set.Set<lib!definitions_t.MemRegion.>. (%Poly%vstd!set.Set<lib!definitions_t.MemRegion.>. x)))) :pattern ((has_type x (TYPE%vstd!set.Set. $ TYPE%lib!definitions_t.MemRegion.))))))
(assert (forall ((x vstd!set.Set<lib!definitions_t.MemRegion.>.)) (! (has_type (Poly%vstd!set.Set<lib!definitions_t.MemRegion.>. x) (TYPE%vstd!set.Set. $ TYPE%lib!definitions_t.MemRegion.)) :pattern ((has_type (Poly%vstd!set.Set<lib!definitions_t.MemRegion.>. x) (TYPE%vstd!set.Set. $ TYPE%lib!definitions_t.MemRegion.))))))
(assert (forall ((x core!option.Option.)) (! (= x (%Poly%core!option.Option. (Poly%core!option.Option. x))) :pattern ((Poly%core!option.Option. x)))))
(assert (forall ((V&. Dcr) (V& Type) (x Poly)) (! (=> (has_type x (TYPE%core!option.Option. V&. V&)) (= x (Poly%core!option.Option. (%Poly%core!option.Option. x)))) :pattern ((has_type x (TYPE%core!option.Option. V&. V&))))))
(assert (forall ((V&. Dcr) (V& Type)) (! (has_type (Poly%core!option.Option. core!option.Option./None) (TYPE%core!option.Option. V&. V&)) :pattern ((has_type (Poly%core!option.Option. core!option.Option./None) (TYPE%core!option.Option. V&. V&))))))
(assert (forall ((V&. Dcr) (V& Type) (_0! Poly)) (! (=> (has_type _0! V&) (has_type (Poly%core!option.Option. (core!option.Option./Some _0!)) (TYPE%core!option.Option. V&. V&))) :pattern ((has_type (Poly%core!option.Option. (core!option.Option./Some _0!)) (TYPE%core!option.Option. V&. V&))))))
(assert (forall ((x core!option.Option.)) (! (= (core!option.Option./Some/0 x) (core!option.Option./Some/?0 x)) :pattern ((core!option.Option./Some/0 x)))))
(assert (forall ((V&. Dcr) (V& Type) (x Poly)) (! (=> (has_type x (TYPE%core!option.Option. V&. V&)) (has_type (core!option.Option./Some/0 (%Poly%core!option.Option. x)) V&)) :pattern ((core!option.Option./Some/0 (%Poly%core!option.Option. x)) (has_type x (TYPE%core!option.Option. V&. V&))))))
(define-fun is-core!option.Option./Some_ ((c core!option.Option.)) Bool ((_ is core!option.Option./Some) c))
(assert (forall ((x core!option.Option.)) (! (=> (is-core!option.Option./Some_ x) (height_lt (height (core!option.Option./Some/0 x)) (height (Poly%core!option.Option. x)))) :pattern ((height (core!option.Option./Some/0 x))))))
(define-fun is-core!option.Option./None_ ((c core!option.Option.)) Bool ((_ is core!option.Option./None) c))
(assert (forall ((V&. Dcr) (V& Type) (deep Bool) (x Poly) (y Poly)) (! (=> (and (has_type x (TYPE%core!option.Option. V&. V&)) (has_type y (TYPE%core!option.Option. V&. V&)) (is-core!option.Option./None_ (%Poly%core!option.Option. x)) (is-core!option.Option./None_ (%Poly%core!option.Option. y))) (ext_eq deep (TYPE%core!option.Option. V&. V&) x y)) :pattern ((ext_eq deep (TYPE%core!option.Option. V&. V&) x y)))))
(assert (forall ((V&. Dcr) (V& Type) (deep Bool) (x Poly) (y Poly)) (! (=> (and (has_type x (TYPE%core!option.Option. V&. V&)) (has_type y (TYPE%core!option.Option. V&. V&)) (is-core!option.Option./Some_ (%Poly%core!option.Option. x)) (is-core!option.Option./Some_ (%Poly%core!option.Option. y)) (ext_eq deep V& (core!option.Option./Some/0 (%Poly%core!option.Option. x)) (core!option.Option./Some/0 (%Poly%core!option.Option. y)))) (ext_eq deep (TYPE%core!option.Option. V&. V&) x y)) :pattern ((ext_eq deep (TYPE%core!option.Option. V&. V&) x y)))))
(assert (forall ((x lib!impl_u.l2_impl.PTDir.)) (! (= x (%Poly%lib!impl_u.l2_impl.PTDir. (Poly%lib!impl_u.l2_impl.PTDir. x))) :pattern ((Poly%lib!impl_u.l2_impl.PTDir. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!impl_u.l2_impl.PTDir.) (= x (Poly%lib!impl_u.l2_impl.PTDir. (%Poly%lib!impl_u.l2_impl.PTDir. x)))) :pattern ((has_type x TYPE%lib!impl_u.l2_impl.PTDir.)))))
(assert (forall ((_region! lib!definitions_t.MemRegion.) (_entries! vstd!seq.Seq<core!option.Option<lib!impl_u.l2_impl.PTDir.>.>.) (_used_regions! vstd!set.Set<lib!definitions_t.MemRegion.>.)) (! (=> (has_type (Poly%lib!definitions_t.MemRegion. _region!) TYPE%lib!definitions_t.MemRegion.) (has_type (Poly%lib!impl_u.l2_impl.PTDir. (lib!impl_u.l2_impl.PTDir./PTDir _region! _entries! _used_regions!)) TYPE%lib!impl_u.l2_impl.PTDir.)) :pattern ((has_type (Poly%lib!impl_u.l2_impl.PTDir. (lib!impl_u.l2_impl.PTDir./PTDir _region! _entries! _used_regions!)) TYPE%lib!impl_u.l2_impl.PTDir.)))))
(assert (forall ((x lib!impl_u.l2_impl.PTDir.)) (! (= (lib!impl_u.l2_impl.PTDir./PTDir/region x) (lib!impl_u.l2_impl.PTDir./PTDir/?region x)) :pattern ((lib!impl_u.l2_impl.PTDir./PTDir/region x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!impl_u.l2_impl.PTDir.) (has_type (Poly%lib!definitions_t.MemRegion. (lib!impl_u.l2_impl.PTDir./PTDir/region (%Poly%lib!impl_u.l2_impl.PTDir. x))) TYPE%lib!definitions_t.MemRegion.)) :pattern ((lib!impl_u.l2_impl.PTDir./PTDir/region (%Poly%lib!impl_u.l2_impl.PTDir. x)) (has_type x TYPE%lib!impl_u.l2_impl.PTDir.)))))
(assert (forall ((x lib!impl_u.l2_impl.PTDir.)) (! (= (lib!impl_u.l2_impl.PTDir./PTDir/entries x) (lib!impl_u.l2_impl.PTDir./PTDir/?entries x)) :pattern ((lib!impl_u.l2_impl.PTDir./PTDir/entries x)))))
(assert (forall ((x lib!impl_u.l2_impl.PTDir.)) (! (= (lib!impl_u.l2_impl.PTDir./PTDir/used_regions x) (lib!impl_u.l2_impl.PTDir./PTDir/?used_regions x)) :pattern ((lib!impl_u.l2_impl.PTDir./PTDir/used_regions x)))))
(define-fun is-lib!impl_u.l2_impl.PTDir./PTDir_ ((c lib!impl_u.l2_impl.PTDir.)) Bool ((_ is lib!impl_u.l2_impl.PTDir./PTDir) c))
(assert (forall ((x lib!impl_u.l2_impl.PTDir.)) (! (=> (is-lib!impl_u.l2_impl.PTDir./PTDir_ x) (height_lt (height (Poly%vstd!seq.Seq<core!option.Option<lib!impl_u.l2_impl.PTDir.>.>. (lib!impl_u.l2_impl.PTDir./PTDir/entries x))) (height (Poly%lib!impl_u.l2_impl.PTDir. x)))) :pattern ((height (Poly%vstd!seq.Seq<core!option.Option<lib!impl_u.l2_impl.PTDir.>.>. (lib!impl_u.l2_impl.PTDir./PTDir/entries x)))))))
(assert (forall ((x lib!spec_t.hardware.GhostPageDirectoryEntry.)) (! (= x (%Poly%lib!spec_t.hardware.GhostPageDirectoryEntry. (Poly%lib!spec_t.hardware.GhostPageDirectoryEntry. x))) :pattern ((Poly%lib!spec_t.hardware.GhostPageDirectoryEntry. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!spec_t.hardware.GhostPageDirectoryEntry.) (= x (Poly%lib!spec_t.hardware.GhostPageDirectoryEntry. (%Poly%lib!spec_t.hardware.GhostPageDirectoryEntry. x)))) :pattern ((has_type x TYPE%lib!spec_t.hardware.GhostPageDirectoryEntry.)))))
(assert (forall ((_addr! Int) (_flag_P! Bool) (_flag_RW! Bool) (_flag_US! Bool) (_flag_PWT! Bool) (_flag_PCD! Bool) (_flag_A! Bool) (_flag_XD! Bool)) (! (=> (uInv SZ _addr!) (has_type (Poly%lib!spec_t.hardware.GhostPageDirectoryEntry. (lib!spec_t.hardware.GhostPageDirectoryEntry./Directory _addr! _flag_P! _flag_RW! _flag_US! _flag_PWT! _flag_PCD! _flag_A! _flag_XD!)) TYPE%lib!spec_t.hardware.GhostPageDirectoryEntry.)) :pattern ((has_type (Poly%lib!spec_t.hardware.GhostPageDirectoryEntry. (lib!spec_t.hardware.GhostPageDirectoryEntry./Directory _addr! _flag_P! _flag_RW! _flag_US! _flag_PWT! _flag_PCD! _flag_A! _flag_XD!)) TYPE%lib!spec_t.hardware.GhostPageDirectoryEntry.)))))
(assert (forall ((x lib!spec_t.hardware.GhostPageDirectoryEntry.)) (! (= (lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/addr x) (lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/?addr x)) :pattern ((lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/addr x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!spec_t.hardware.GhostPageDirectoryEntry.) (uInv SZ (lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/addr (%Poly%lib!spec_t.hardware.GhostPageDirectoryEntry. x)))) :pattern ((lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/addr (%Poly%lib!spec_t.hardware.GhostPageDirectoryEntry. x)) (has_type x TYPE%lib!spec_t.hardware.GhostPageDirectoryEntry.)))))
(assert (forall ((x lib!spec_t.hardware.GhostPageDirectoryEntry.)) (! (= (lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/flag_P x) (lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/?flag_P x)) :pattern ((lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/flag_P x)))))
(assert (forall ((x lib!spec_t.hardware.GhostPageDirectoryEntry.)) (! (= (lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/flag_RW x) (lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/?flag_RW x)) :pattern ((lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/flag_RW x)))))
(assert (forall ((x lib!spec_t.hardware.GhostPageDirectoryEntry.)) (! (= (lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/flag_US x) (lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/?flag_US x)) :pattern ((lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/flag_US x)))))
(assert (forall ((x lib!spec_t.hardware.GhostPageDirectoryEntry.)) (! (= (lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/flag_PWT x) (lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/?flag_PWT x)) :pattern ((lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/flag_PWT x)))))
(assert (forall ((x lib!spec_t.hardware.GhostPageDirectoryEntry.)) (! (= (lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/flag_PCD x) (lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/?flag_PCD x)) :pattern ((lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/flag_PCD x)))))
(assert (forall ((x lib!spec_t.hardware.GhostPageDirectoryEntry.)) (! (= (lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/flag_A x) (lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/?flag_A x)) :pattern ((lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/flag_A x)))))
(assert (forall ((x lib!spec_t.hardware.GhostPageDirectoryEntry.)) (! (= (lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/flag_XD x) (lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/?flag_XD x)) :pattern ((lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/flag_XD x)))))
(assert (forall ((_addr! Int) (_flag_P! Bool) (_flag_RW! Bool) (_flag_US! Bool) (_flag_PWT! Bool) (_flag_PCD! Bool) (_flag_A! Bool) (_flag_D! Bool) (_flag_G! Bool) (_flag_PAT! Bool) (_flag_XD! Bool)) (! (=> (uInv SZ _addr!) (has_type (Poly%lib!spec_t.hardware.GhostPageDirectoryEntry. (lib!spec_t.hardware.GhostPageDirectoryEntry./Page _addr! _flag_P! _flag_RW! _flag_US! _flag_PWT! _flag_PCD! _flag_A! _flag_D! _flag_G! _flag_PAT! _flag_XD!)) TYPE%lib!spec_t.hardware.GhostPageDirectoryEntry.)) :pattern ((has_type (Poly%lib!spec_t.hardware.GhostPageDirectoryEntry. (lib!spec_t.hardware.GhostPageDirectoryEntry./Page _addr! _flag_P! _flag_RW! _flag_US! _flag_PWT! _flag_PCD! _flag_A! _flag_D! _flag_G! _flag_PAT! _flag_XD!)) TYPE%lib!spec_t.hardware.GhostPageDirectoryEntry.)))))
(assert (forall ((x lib!spec_t.hardware.GhostPageDirectoryEntry.)) (! (= (lib!spec_t.hardware.GhostPageDirectoryEntry./Page/addr x) (lib!spec_t.hardware.GhostPageDirectoryEntry./Page/?addr x)) :pattern ((lib!spec_t.hardware.GhostPageDirectoryEntry./Page/addr x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!spec_t.hardware.GhostPageDirectoryEntry.) (uInv SZ (lib!spec_t.hardware.GhostPageDirectoryEntry./Page/addr (%Poly%lib!spec_t.hardware.GhostPageDirectoryEntry. x)))) :pattern ((lib!spec_t.hardware.GhostPageDirectoryEntry./Page/addr (%Poly%lib!spec_t.hardware.GhostPageDirectoryEntry. x)) (has_type x TYPE%lib!spec_t.hardware.GhostPageDirectoryEntry.)))))
(assert (forall ((x lib!spec_t.hardware.GhostPageDirectoryEntry.)) (! (= (lib!spec_t.hardware.GhostPageDirectoryEntry./Page/flag_P x) (lib!spec_t.hardware.GhostPageDirectoryEntry./Page/?flag_P x)) :pattern ((lib!spec_t.hardware.GhostPageDirectoryEntry./Page/flag_P x)))))
(assert (forall ((x lib!spec_t.hardware.GhostPageDirectoryEntry.)) (! (= (lib!spec_t.hardware.GhostPageDirectoryEntry./Page/flag_RW x) (lib!spec_t.hardware.GhostPageDirectoryEntry./Page/?flag_RW x)) :pattern ((lib!spec_t.hardware.GhostPageDirectoryEntry./Page/flag_RW x)))))
(assert (forall ((x lib!spec_t.hardware.GhostPageDirectoryEntry.)) (! (= (lib!spec_t.hardware.GhostPageDirectoryEntry./Page/flag_US x) (lib!spec_t.hardware.GhostPageDirectoryEntry./Page/?flag_US x)) :pattern ((lib!spec_t.hardware.GhostPageDirectoryEntry./Page/flag_US x)))))
(assert (forall ((x lib!spec_t.hardware.GhostPageDirectoryEntry.)) (! (= (lib!spec_t.hardware.GhostPageDirectoryEntry./Page/flag_PWT x) (lib!spec_t.hardware.GhostPageDirectoryEntry./Page/?flag_PWT x)) :pattern ((lib!spec_t.hardware.GhostPageDirectoryEntry./Page/flag_PWT x)))))
(assert (forall ((x lib!spec_t.hardware.GhostPageDirectoryEntry.)) (! (= (lib!spec_t.hardware.GhostPageDirectoryEntry./Page/flag_PCD x) (lib!spec_t.hardware.GhostPageDirectoryEntry./Page/?flag_PCD x)) :pattern ((lib!spec_t.hardware.GhostPageDirectoryEntry./Page/flag_PCD x)))))
(assert (forall ((x lib!spec_t.hardware.GhostPageDirectoryEntry.)) (! (= (lib!spec_t.hardware.GhostPageDirectoryEntry./Page/flag_A x) (lib!spec_t.hardware.GhostPageDirectoryEntry./Page/?flag_A x)) :pattern ((lib!spec_t.hardware.GhostPageDirectoryEntry./Page/flag_A x)))))
(assert (forall ((x lib!spec_t.hardware.GhostPageDirectoryEntry.)) (! (= (lib!spec_t.hardware.GhostPageDirectoryEntry./Page/flag_D x) (lib!spec_t.hardware.GhostPageDirectoryEntry./Page/?flag_D x)) :pattern ((lib!spec_t.hardware.GhostPageDirectoryEntry./Page/flag_D x)))))
(assert (forall ((x lib!spec_t.hardware.GhostPageDirectoryEntry.)) (! (= (lib!spec_t.hardware.GhostPageDirectoryEntry./Page/flag_G x) (lib!spec_t.hardware.GhostPageDirectoryEntry./Page/?flag_G x)) :pattern ((lib!spec_t.hardware.GhostPageDirectoryEntry./Page/flag_G x)))))
(assert (forall ((x lib!spec_t.hardware.GhostPageDirectoryEntry.)) (! (= (lib!spec_t.hardware.GhostPageDirectoryEntry./Page/flag_PAT x) (lib!spec_t.hardware.GhostPageDirectoryEntry./Page/?flag_PAT x)) :pattern ((lib!spec_t.hardware.GhostPageDirectoryEntry./Page/flag_PAT x)))))
(assert (forall ((x lib!spec_t.hardware.GhostPageDirectoryEntry.)) (! (= (lib!spec_t.hardware.GhostPageDirectoryEntry./Page/flag_XD x) (lib!spec_t.hardware.GhostPageDirectoryEntry./Page/?flag_XD x)) :pattern ((lib!spec_t.hardware.GhostPageDirectoryEntry./Page/flag_XD x)))))
(assert (has_type (Poly%lib!spec_t.hardware.GhostPageDirectoryEntry. lib!spec_t.hardware.GhostPageDirectoryEntry./Empty) TYPE%lib!spec_t.hardware.GhostPageDirectoryEntry.))
(assert (forall ((x lib!spec_t.hardware.PageDirectoryEntry.)) (! (= x (%Poly%lib!spec_t.hardware.PageDirectoryEntry. (Poly%lib!spec_t.hardware.PageDirectoryEntry. x))) :pattern ((Poly%lib!spec_t.hardware.PageDirectoryEntry. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!spec_t.hardware.PageDirectoryEntry.) (= x (Poly%lib!spec_t.hardware.PageDirectoryEntry. (%Poly%lib!spec_t.hardware.PageDirectoryEntry. x)))) :pattern ((has_type x TYPE%lib!spec_t.hardware.PageDirectoryEntry.)))))
(assert (forall ((_entry! Int) (_layer! Int)) (! (=> (and (uInv 64 _entry!) (<= 0 _layer!)) (has_type (Poly%lib!spec_t.hardware.PageDirectoryEntry. (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry _entry! _layer!)) TYPE%lib!spec_t.hardware.PageDirectoryEntry.)) :pattern ((has_type (Poly%lib!spec_t.hardware.PageDirectoryEntry. (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry _entry! _layer!)) TYPE%lib!spec_t.hardware.PageDirectoryEntry.)))))
(assert (forall ((x lib!spec_t.hardware.PageDirectoryEntry.)) (! (= (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/entry x) (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/?entry x)) :pattern ((lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/entry x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!spec_t.hardware.PageDirectoryEntry.) (uInv 64 (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/entry (%Poly%lib!spec_t.hardware.PageDirectoryEntry. x)))) :pattern ((lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/entry (%Poly%lib!spec_t.hardware.PageDirectoryEntry. x)) (has_type x TYPE%lib!spec_t.hardware.PageDirectoryEntry.)))))
(assert (forall ((x lib!spec_t.hardware.PageDirectoryEntry.)) (! (= (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/layer x) (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/?layer x)) :pattern ((lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/layer x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!spec_t.hardware.PageDirectoryEntry.) (<= 0 (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/layer (%Poly%lib!spec_t.hardware.PageDirectoryEntry. x)))) :pattern ((lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/layer (%Poly%lib!spec_t.hardware.PageDirectoryEntry. x)) (has_type x TYPE%lib!spec_t.hardware.PageDirectoryEntry.)))))
(assert (forall ((x lib!definitions_t.MemRegion.)) (! (= x (%Poly%lib!definitions_t.MemRegion. (Poly%lib!definitions_t.MemRegion. x))) :pattern ((Poly%lib!definitions_t.MemRegion. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!definitions_t.MemRegion.) (= x (Poly%lib!definitions_t.MemRegion. (%Poly%lib!definitions_t.MemRegion. x)))) :pattern ((has_type x TYPE%lib!definitions_t.MemRegion.)))))
(assert (forall ((_base! Int) (_size! Int)) (! (=> (and (<= 0 _base!) (<= 0 _size!)) (has_type (Poly%lib!definitions_t.MemRegion. (lib!definitions_t.MemRegion./MemRegion _base! _size!)) TYPE%lib!definitions_t.MemRegion.)) :pattern ((has_type (Poly%lib!definitions_t.MemRegion. (lib!definitions_t.MemRegion./MemRegion _base! _size!)) TYPE%lib!definitions_t.MemRegion.)))))
(assert (forall ((x lib!definitions_t.MemRegion.)) (! (= (lib!definitions_t.MemRegion./MemRegion/base x) (lib!definitions_t.MemRegion./MemRegion/?base x)) :pattern ((lib!definitions_t.MemRegion./MemRegion/base x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!definitions_t.MemRegion.) (<= 0 (lib!definitions_t.MemRegion./MemRegion/base (%Poly%lib!definitions_t.MemRegion. x)))) :pattern ((lib!definitions_t.MemRegion./MemRegion/base (%Poly%lib!definitions_t.MemRegion. x)) (has_type x TYPE%lib!definitions_t.MemRegion.)))))
(assert (forall ((x lib!definitions_t.MemRegion.)) (! (= (lib!definitions_t.MemRegion./MemRegion/size x) (lib!definitions_t.MemRegion./MemRegion/?size x)) :pattern ((lib!definitions_t.MemRegion./MemRegion/size x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!definitions_t.MemRegion.) (<= 0 (lib!definitions_t.MemRegion./MemRegion/size (%Poly%lib!definitions_t.MemRegion. x)))) :pattern ((lib!definitions_t.MemRegion./MemRegion/size (%Poly%lib!definitions_t.MemRegion. x)) (has_type x TYPE%lib!definitions_t.MemRegion.)))))
(assert (forall ((x lib!definitions_t.MemRegionExec.)) (! (= x (%Poly%lib!definitions_t.MemRegionExec. (Poly%lib!definitions_t.MemRegionExec. x))) :pattern ((Poly%lib!definitions_t.MemRegionExec. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!definitions_t.MemRegionExec.) (= x (Poly%lib!definitions_t.MemRegionExec. (%Poly%lib!definitions_t.MemRegionExec. x)))) :pattern ((has_type x TYPE%lib!definitions_t.MemRegionExec.)))))
(assert (forall ((_base! Int) (_size! Int)) (! (=> (and (uInv SZ _base!) (uInv SZ _size!)) (has_type (Poly%lib!definitions_t.MemRegionExec. (lib!definitions_t.MemRegionExec./MemRegionExec _base! _size!)) TYPE%lib!definitions_t.MemRegionExec.)) :pattern ((has_type (Poly%lib!definitions_t.MemRegionExec. (lib!definitions_t.MemRegionExec./MemRegionExec _base! _size!)) TYPE%lib!definitions_t.MemRegionExec.)))))
(assert (forall ((x lib!definitions_t.MemRegionExec.)) (! (= (lib!definitions_t.MemRegionExec./MemRegionExec/base x) (lib!definitions_t.MemRegionExec./MemRegionExec/?base x)) :pattern ((lib!definitions_t.MemRegionExec./MemRegionExec/base x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!definitions_t.MemRegionExec.) (uInv SZ (lib!definitions_t.MemRegionExec./MemRegionExec/base (%Poly%lib!definitions_t.MemRegionExec. x)))) :pattern ((lib!definitions_t.MemRegionExec./MemRegionExec/base (%Poly%lib!definitions_t.MemRegionExec. x)) (has_type x TYPE%lib!definitions_t.MemRegionExec.)))))
(assert (forall ((x lib!definitions_t.MemRegionExec.)) (! (= (lib!definitions_t.MemRegionExec./MemRegionExec/size x) (lib!definitions_t.MemRegionExec./MemRegionExec/?size x)) :pattern ((lib!definitions_t.MemRegionExec./MemRegionExec/size x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!definitions_t.MemRegionExec.) (uInv SZ (lib!definitions_t.MemRegionExec./MemRegionExec/size (%Poly%lib!definitions_t.MemRegionExec. x)))) :pattern ((lib!definitions_t.MemRegionExec./MemRegionExec/size (%Poly%lib!definitions_t.MemRegionExec. x)) (has_type x TYPE%lib!definitions_t.MemRegionExec.)))))
(assert (forall ((x lib!definitions_t.Flags.)) (! (= x (%Poly%lib!definitions_t.Flags. (Poly%lib!definitions_t.Flags. x))) :pattern ((Poly%lib!definitions_t.Flags. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!definitions_t.Flags.) (= x (Poly%lib!definitions_t.Flags. (%Poly%lib!definitions_t.Flags. x)))) :pattern ((has_type x TYPE%lib!definitions_t.Flags.)))))
(assert (forall ((x lib!definitions_t.Flags.)) (! (= (lib!definitions_t.Flags./Flags/is_writable x) (lib!definitions_t.Flags./Flags/?is_writable x)) :pattern ((lib!definitions_t.Flags./Flags/is_writable x)))))
(assert (forall ((x lib!definitions_t.Flags.)) (! (= (lib!definitions_t.Flags./Flags/is_supervisor x) (lib!definitions_t.Flags./Flags/?is_supervisor x)) :pattern ((lib!definitions_t.Flags./Flags/is_supervisor x)))))
(assert (forall ((x lib!definitions_t.Flags.)) (! (= (lib!definitions_t.Flags./Flags/disable_execute x) (lib!definitions_t.Flags./Flags/?disable_execute x)) :pattern ((lib!definitions_t.Flags./Flags/disable_execute x)))))
(assert (forall ((x lib!definitions_t.Flags.)) (! (has_type (Poly%lib!definitions_t.Flags. x) TYPE%lib!definitions_t.Flags.) :pattern ((has_type (Poly%lib!definitions_t.Flags. x) TYPE%lib!definitions_t.Flags.)))))
(assert (forall ((x lib!definitions_t.PageTableEntryExec.)) (! (= x (%Poly%lib!definitions_t.PageTableEntryExec. (Poly%lib!definitions_t.PageTableEntryExec. x))) :pattern ((Poly%lib!definitions_t.PageTableEntryExec. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!definitions_t.PageTableEntryExec.) (= x (Poly%lib!definitions_t.PageTableEntryExec. (%Poly%lib!definitions_t.PageTableEntryExec. x)))) :pattern ((has_type x TYPE%lib!definitions_t.PageTableEntryExec.)))))
(assert (forall ((_frame! lib!definitions_t.MemRegionExec.) (_flags! lib!definitions_t.Flags.)) (! (=> (has_type (Poly%lib!definitions_t.MemRegionExec. _frame!) TYPE%lib!definitions_t.MemRegionExec.) (has_type (Poly%lib!definitions_t.PageTableEntryExec. (lib!definitions_t.PageTableEntryExec./PageTableEntryExec _frame! _flags!)) TYPE%lib!definitions_t.PageTableEntryExec.)) :pattern ((has_type (Poly%lib!definitions_t.PageTableEntryExec. (lib!definitions_t.PageTableEntryExec./PageTableEntryExec _frame! _flags!)) TYPE%lib!definitions_t.PageTableEntryExec.)))))
(assert (forall ((x lib!definitions_t.PageTableEntryExec.)) (! (= (lib!definitions_t.PageTableEntryExec./PageTableEntryExec/frame x) (lib!definitions_t.PageTableEntryExec./PageTableEntryExec/?frame x)) :pattern ((lib!definitions_t.PageTableEntryExec./PageTableEntryExec/frame x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!definitions_t.PageTableEntryExec.) (has_type (Poly%lib!definitions_t.MemRegionExec. (lib!definitions_t.PageTableEntryExec./PageTableEntryExec/frame (%Poly%lib!definitions_t.PageTableEntryExec. x))) TYPE%lib!definitions_t.MemRegionExec.)) :pattern ((lib!definitions_t.PageTableEntryExec./PageTableEntryExec/frame (%Poly%lib!definitions_t.PageTableEntryExec. x)) (has_type x TYPE%lib!definitions_t.PageTableEntryExec.)))))
(assert (forall ((x lib!definitions_t.PageTableEntryExec.)) (! (= (lib!definitions_t.PageTableEntryExec./PageTableEntryExec/flags x) (lib!definitions_t.PageTableEntryExec./PageTableEntryExec/?flags x)) :pattern ((lib!definitions_t.PageTableEntryExec./PageTableEntryExec/flags x)))))
(assert (forall ((x tuple%0.)) (! (= x (%Poly%tuple%0. (Poly%tuple%0. x))) :pattern ((Poly%tuple%0. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%tuple%0.) (= x (Poly%tuple%0. (%Poly%tuple%0. x)))) :pattern ((has_type x TYPE%tuple%0.)))))
(assert (forall ((x tuple%0.)) (! (has_type (Poly%tuple%0. x) TYPE%tuple%0.) :pattern ((has_type (Poly%tuple%0. x) TYPE%tuple%0.)))))
(declare-fun vstd!seq.Seq.len.? (Dcr Type Poly) Int)
(declare-fun vstd!seq.Seq.index.? (Dcr Type Poly Poly) Poly)
(declare-fun vstd!seq.impl&%0.spec_index.? (Dcr Type Poly Poly) Poly)
(declare-fun vstd!set.impl&%0.contains.? (Dcr Type Poly Poly) Bool)
(declare-fun vstd!pervasive.arbitrary.? (Dcr Type) Poly)
(declare-fun lib!definitions_t.aligned.? (Poly Poly) Bool)
(declare-fun lib!definitions_t.PAGE_SIZE.? () Int)
(declare-fun lib!definitions_t.MAX_PHYADDR_WIDTH.? () Int)
(declare-fun lib!definitions_t.MAX_PHYADDR_SPEC.? () Int)
(declare-fun lib!definitions_t.L3_ENTRY_SIZE.? () Int)
(declare-fun lib!definitions_t.L2_ENTRY_SIZE.? () Int)
(declare-fun lib!definitions_t.L1_ENTRY_SIZE.? () Int)
(declare-fun lib!spec_t.hardware.MASK_FLAG_P.? () Int)
(declare-fun lib!spec_t.hardware.MASK_FLAG_RW.? () Int)
(declare-fun lib!spec_t.hardware.MASK_FLAG_US.? () Int)
(declare-fun lib!spec_t.hardware.MASK_FLAG_PWT.? () Int)
(declare-fun lib!spec_t.hardware.MASK_FLAG_PCD.? () Int)
(declare-fun lib!spec_t.hardware.MASK_FLAG_A.? () Int)
(declare-fun lib!spec_t.hardware.MASK_FLAG_XD.? () Int)
(declare-fun lib!spec_t.hardware.MASK_PG_FLAG_D.? () Int)
(declare-fun lib!spec_t.hardware.MASK_PG_FLAG_G.? () Int)
(declare-fun lib!spec_t.hardware.MASK_L1_PG_FLAG_PS.? () Int)
(declare-fun lib!spec_t.hardware.MASK_L2_PG_FLAG_PS.? () Int)
(declare-fun lib!spec_t.hardware.impl&%3.all_mb0_bits_are_zero.? (Poly) Bool)
(declare-fun lib!spec_t.hardware.MASK_ADDR_SPEC.? () Int)
(declare-fun lib!spec_t.hardware.MASK_L1_PG_ADDR_SPEC.? () Int)
(declare-fun lib!spec_t.hardware.MASK_PG_FLAG_PAT.? () Int)
(declare-fun lib!spec_t.hardware.MASK_L2_PG_ADDR_SPEC.? () Int)
(declare-fun lib!spec_t.hardware.MASK_L3_PG_ADDR_SPEC.? () Int)
(declare-fun lib!spec_t.hardware.MASK_L3_PG_FLAG_PAT.? () Int)
(declare-fun lib!spec_t.hardware.impl&%3.view.? (Poly) lib!spec_t.hardware.GhostPageDirectoryEntry.)
(declare-fun lib!spec_t.hardware.impl&%1.get_Directory_addr.? (Poly) Int)
(declare-fun lib!spec_t.hardware.impl&%1.get_Directory_flag_RW.? (Poly) Bool)
(declare-fun lib!spec_t.hardware.impl&%1.get_Directory_flag_US.? (Poly) Bool)
(declare-fun lib!spec_t.hardware.impl&%1.get_Directory_flag_XD.? (Poly) Bool)
(declare-fun lib!impl_u.l2_impl.impl&%0.hp_pat_is_zero.? (Poly) Bool)
(declare-fun lib!impl_u.l2_impl.addr_is_zero_padded.? (Poly Poly Poly) Bool)
(declare-fun lib!spec_t.hardware.impl&%1.get_Page_addr.? (Poly) Int)
(declare-fun lib!spec_t.hardware.impl&%1.get_Page_flag_RW.? (Poly) Bool)
(declare-fun lib!spec_t.hardware.impl&%1.get_Page_flag_US.? (Poly) Bool)
(declare-fun lib!spec_t.hardware.impl&%1.get_Page_flag_XD.? (Poly) Bool)
(declare-fun lib!spec_t.hardware.MASK_DIR_ADDR_SPEC.? () Int)
(declare-fun lib!spec_t.hardware.impl&%3.layer.? (Poly) Int)
(assert (forall ((A&. Dcr) (A& Type) (self! Poly)) (! (=> (has_type self! (TYPE%vstd!seq.Seq. A&. A&)) (<= 0 (vstd!seq.Seq.len.? A&. A& self!))) :pattern ((vstd!seq.Seq.len.? A&. A& self!)))))
(declare-fun req%vstd!seq.Seq.index. (Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%0 Bool)
(assert (forall ((A&. Dcr) (A& Type) (self! Poly) (i! Poly)) (! (= (req%vstd!seq.Seq.index. A&. A& self! i!) (=> %%global_location_label%%0 (and (<= 0 (%I i!)) (< (%I i!) (vstd!seq.Seq.len.? A&. A& self!))))) :pattern ((req%vstd!seq.Seq.index. A&. A& self! i!)))))
(assert (forall ((A&. Dcr) (A& Type) (self! Poly) (i! Poly)) (! (=> (and (has_type self! (TYPE%vstd!seq.Seq. A&. A&)) (has_type i! INT)) (has_type (vstd!seq.Seq.index.? A&. A& self! i!) A&)) :pattern ((vstd!seq.Seq.index.? A&. A& self! i!)))))
(declare-fun req%vstd!seq.impl&%0.spec_index. (Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%1 Bool)
(assert (forall ((A&. Dcr) (A& Type) (self! Poly) (i! Poly)) (! (= (req%vstd!seq.impl&%0.spec_index. A&. A& self! i!) (=> %%global_location_label%%1 (and (<= 0 (%I i!)) (< (%I i!) (vstd!seq.Seq.len.? A&. A& self!))))) :pattern ((req%vstd!seq.impl&%0.spec_index. A&. A& self! i!)))))
(assert (fuel_bool_default fuel%vstd!seq.impl&%0.spec_index.))
(assert (=> (fuel_bool fuel%vstd!seq.impl&%0.spec_index.) (forall ((A&. Dcr) (A& Type) (self! Poly) (i! Poly)) (! (= (vstd!seq.impl&%0.spec_index.? A&. A& self! i!) (vstd!seq.Seq.index.? A&. A& self! i!)) :pattern ((vstd!seq.impl&%0.spec_index.? A&. A& self! i!))))))
(assert (forall ((A&. Dcr) (A& Type) (self! Poly) (i! Poly)) (! (=> (and (has_type self! (TYPE%vstd!seq.Seq. A&. A&)) (has_type i! INT)) (has_type (vstd!seq.impl&%0.spec_index.? A&. A& self! i!) A&)) :pattern ((vstd!seq.impl&%0.spec_index.? A&. A& self! i!)))))
(assert (forall ((A&. Dcr) (A& Type)) (! (has_type (vstd!pervasive.arbitrary.? A&. A&) A&) :pattern ((vstd!pervasive.arbitrary.? A&. A&)))))
(assert (=> (fuel_bool fuel%vstd!seq.axiom_seq_index_decreases.) (forall ((A&. Dcr) (A& Type) (s! Poly) (i! Poly)) (! (=> (and (has_type s! (TYPE%vstd!seq.Seq. A&. A&)) (has_type i! INT)) (=> (and (<= 0 (%I i!)) (< (%I i!) (vstd!seq.Seq.len.? A&. A& s!))) (height_lt (height (vstd!seq.Seq.index.? A&. A& s! i!)) (height s!)))) :pattern ((height (vstd!seq.Seq.index.? A&. A& s! i!)))))))
(assert (=> (fuel_bool fuel%vstd!seq.axiom_seq_ext_equal.) (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly)) (! (=> (and (has_type s1! (TYPE%vstd!seq.Seq. A&. A&)) (has_type s2! (TYPE%vstd!seq.Seq. A&. A&))) (= (ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) (and (= (vstd!seq.Seq.len.? A&. A& s1!) (vstd!seq.Seq.len.? A&. A& s2!)) (forall ((i$ Poly)) (! (=> (has_type i$ INT) (=> (and (<= 0 (%I i$)) (< (%I i$) (vstd!seq.Seq.len.? A&. A& s1!))) (= (vstd!seq.Seq.index.? A&. A& s1! i$) (vstd!seq.Seq.index.? A&. A& s2! i$)))) :pattern ((vstd!seq.Seq.index.? A&. A& s1! i$)) :pattern ((vstd!seq.Seq.index.? A&. A& s2! i$))))))) :pattern ((ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!))))))
(assert (=> (fuel_bool fuel%vstd!seq.axiom_seq_ext_equal_deep.) (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly)) (! (=> (and (has_type s1! (TYPE%vstd!seq.Seq. A&. A&)) (has_type s2! (TYPE%vstd!seq.Seq. A&. A&))) (= (ext_eq true (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) (and (= (vstd!seq.Seq.len.? A&. A& s1!) (vstd!seq.Seq.len.? A&. A& s2!)) (forall ((i$ Poly)) (! (=> (has_type i$ INT) (=> (and (<= 0 (%I i$)) (< (%I i$) (vstd!seq.Seq.len.? A&. A& s1!))) (ext_eq true A& (vstd!seq.Seq.index.? A&. A& s1! i$) (vstd!seq.Seq.index.? A&. A& s2! i$)))) :pattern ((vstd!seq.Seq.index.? A&. A& s1! i$)) :pattern ((vstd!seq.Seq.index.? A&. A& s2! i$))))))) :pattern ((ext_eq true (TYPE%vstd!seq.Seq. A&. A&) s1! s2!))))))
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_ext_equal.) (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly)) (! (=> (and (has_type s1! (TYPE%vstd!set.Set. A&. A&)) (has_type s2! (TYPE%vstd!set.Set. A&. A&))) (= (ext_eq false (TYPE%vstd!set.Set. A&. A&) s1! s2!) (forall ((a$ Poly)) (! (=> (has_type a$ A&) (= (vstd!set.impl&%0.contains.? A&. A& s1! a$) (vstd!set.impl&%0.contains.? A&. A& s2! a$))) :pattern ((vstd!set.impl&%0.contains.? A&. A& s1! a$)) :pattern ((vstd!set.impl&%0.contains.? A&. A& s2! a$)))))) :pattern ((ext_eq false (TYPE%vstd!set.Set. A&. A&) s1! s2!))))))
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_ext_equal_deep.) (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly)) (! (=> (and (has_type s1! (TYPE%vstd!set.Set. A&. A&)) (has_type s2! (TYPE%vstd!set.Set. A&. A&))) (= (ext_eq true (TYPE%vstd!set.Set. A&. A&) s1! s2!) (ext_eq false (TYPE%vstd!set.Set. A&. A&) s1! s2!))) :pattern ((ext_eq true (TYPE%vstd!set.Set. A&. A&) s1! s2!))))))
(assert (fuel_bool_default fuel%lib!definitions_t.aligned.))
(assert (=> (fuel_bool fuel%lib!definitions_t.aligned.) (forall ((addr! Poly) (size! Poly)) (! (= (lib!definitions_t.aligned.? addr! size!) (= (nClip (EucMod (%I addr!) (%I size!))) 0)) :pattern ((lib!definitions_t.aligned.? addr! size!))))))
(assert (fuel_bool_default fuel%lib!definitions_t.PAGE_SIZE.))
(assert (=> (fuel_bool fuel%lib!definitions_t.PAGE_SIZE.) (= lib!definitions_t.PAGE_SIZE.? 4096)))
(assert (uInv SZ lib!definitions_t.PAGE_SIZE.?))
(assert (uInv 64 lib!definitions_t.MAX_PHYADDR_WIDTH.?))
(assert (fuel_bool_default fuel%lib!definitions_t.MAX_PHYADDR_SPEC.))
(assert (=> (fuel_bool fuel%lib!definitions_t.MAX_PHYADDR_SPEC.) (= lib!definitions_t.MAX_PHYADDR_SPEC.? (uClip 64 (Sub (uClip 64 (bitshl (I 1) (I lib!definitions_t.MAX_PHYADDR_WIDTH.?))) 1)))))
(assert (uInv 64 lib!definitions_t.MAX_PHYADDR_SPEC.?))
(assert (fuel_bool_default fuel%lib!definitions_t.L3_ENTRY_SIZE.))
(assert (=> (fuel_bool fuel%lib!definitions_t.L3_ENTRY_SIZE.) (= lib!definitions_t.L3_ENTRY_SIZE.? lib!definitions_t.PAGE_SIZE.?)))
(assert (uInv SZ lib!definitions_t.L3_ENTRY_SIZE.?))
(assert (fuel_bool_default fuel%lib!definitions_t.L2_ENTRY_SIZE.))
(assert (=> (fuel_bool fuel%lib!definitions_t.L2_ENTRY_SIZE.) (= lib!definitions_t.L2_ENTRY_SIZE.? (uClip SZ (Mul 512 lib!definitions_t.L3_ENTRY_SIZE.?)))))
(assert (uInv SZ lib!definitions_t.L2_ENTRY_SIZE.?))
(assert (fuel_bool_default fuel%lib!definitions_t.L1_ENTRY_SIZE.))
(assert (=> (fuel_bool fuel%lib!definitions_t.L1_ENTRY_SIZE.) (= lib!definitions_t.L1_ENTRY_SIZE.? (uClip SZ (Mul 512 lib!definitions_t.L2_ENTRY_SIZE.?)))))
(assert (uInv SZ lib!definitions_t.L1_ENTRY_SIZE.?))
(assert (fuel_bool_default fuel%lib!spec_t.hardware.MASK_FLAG_P.))
(assert (=> (fuel_bool fuel%lib!spec_t.hardware.MASK_FLAG_P.) (= lib!spec_t.hardware.MASK_FLAG_P.? (uClip 64 (bitshl (I 1) (I 0))))))
(assert (uInv 64 lib!spec_t.hardware.MASK_FLAG_P.?))
(assert (fuel_bool_default fuel%lib!spec_t.hardware.MASK_FLAG_RW.))
(assert (=> (fuel_bool fuel%lib!spec_t.hardware.MASK_FLAG_RW.) (= lib!spec_t.hardware.MASK_FLAG_RW.? (uClip 64 (bitshl (I 1) (I 1))))))
(assert (uInv 64 lib!spec_t.hardware.MASK_FLAG_RW.?))
(assert (fuel_bool_default fuel%lib!spec_t.hardware.MASK_FLAG_US.))
(assert (=> (fuel_bool fuel%lib!spec_t.hardware.MASK_FLAG_US.) (= lib!spec_t.hardware.MASK_FLAG_US.? (uClip 64 (bitshl (I 1) (I 2))))))
(assert (uInv 64 lib!spec_t.hardware.MASK_FLAG_US.?))
(assert (fuel_bool_default fuel%lib!spec_t.hardware.MASK_FLAG_PWT.))
(assert (=> (fuel_bool fuel%lib!spec_t.hardware.MASK_FLAG_PWT.) (= lib!spec_t.hardware.MASK_FLAG_PWT.? (uClip 64 (bitshl (I 1) (I 3))))))
(assert (uInv 64 lib!spec_t.hardware.MASK_FLAG_PWT.?))
(assert (fuel_bool_default fuel%lib!spec_t.hardware.MASK_FLAG_PCD.))
(assert (=> (fuel_bool fuel%lib!spec_t.hardware.MASK_FLAG_PCD.) (= lib!spec_t.hardware.MASK_FLAG_PCD.? (uClip 64 (bitshl (I 1) (I 4))))))
(assert (uInv 64 lib!spec_t.hardware.MASK_FLAG_PCD.?))
(assert (fuel_bool_default fuel%lib!spec_t.hardware.MASK_FLAG_A.))
(assert (=> (fuel_bool fuel%lib!spec_t.hardware.MASK_FLAG_A.) (= lib!spec_t.hardware.MASK_FLAG_A.? (uClip 64 (bitshl (I 1) (I 5))))))
(assert (uInv 64 lib!spec_t.hardware.MASK_FLAG_A.?))
(assert (fuel_bool_default fuel%lib!spec_t.hardware.MASK_FLAG_XD.))
(assert (=> (fuel_bool fuel%lib!spec_t.hardware.MASK_FLAG_XD.) (= lib!spec_t.hardware.MASK_FLAG_XD.? (uClip 64 (bitshl (I 1) (I 63))))))
(assert (uInv 64 lib!spec_t.hardware.MASK_FLAG_XD.?))
(assert (fuel_bool_default fuel%lib!spec_t.hardware.MASK_PG_FLAG_D.))
(assert (=> (fuel_bool fuel%lib!spec_t.hardware.MASK_PG_FLAG_D.) (= lib!spec_t.hardware.MASK_PG_FLAG_D.? (uClip 64 (bitshl (I 1) (I 6))))))
(assert (uInv 64 lib!spec_t.hardware.MASK_PG_FLAG_D.?))
(assert (fuel_bool_default fuel%lib!spec_t.hardware.MASK_PG_FLAG_G.))
(assert (=> (fuel_bool fuel%lib!spec_t.hardware.MASK_PG_FLAG_G.) (= lib!spec_t.hardware.MASK_PG_FLAG_G.? (uClip 64 (bitshl (I 1) (I 8))))))
(assert (uInv 64 lib!spec_t.hardware.MASK_PG_FLAG_G.?))
(assert (fuel_bool_default fuel%lib!spec_t.hardware.MASK_L1_PG_FLAG_PS.))
(assert (=> (fuel_bool fuel%lib!spec_t.hardware.MASK_L1_PG_FLAG_PS.) (= lib!spec_t.hardware.MASK_L1_PG_FLAG_PS.? (uClip 64 (bitshl (I 1) (I 7))))))
(assert (uInv 64 lib!spec_t.hardware.MASK_L1_PG_FLAG_PS.?))
(assert (fuel_bool_default fuel%lib!spec_t.hardware.MASK_L2_PG_FLAG_PS.))
(assert (=> (fuel_bool fuel%lib!spec_t.hardware.MASK_L2_PG_FLAG_PS.) (= lib!spec_t.hardware.MASK_L2_PG_FLAG_PS.? (uClip 64 (bitshl (I 1) (I 7))))))
(assert (uInv 64 lib!spec_t.hardware.MASK_L2_PG_FLAG_PS.?))
(declare-fun req%lib!spec_t.hardware.impl&%3.all_mb0_bits_are_zero. (Poly) Bool)
(declare-const %%global_location_label%%2 Bool)
(assert (forall ((self! Poly)) (! (= (req%lib!spec_t.hardware.impl&%3.all_mb0_bits_are_zero. self!) (=> %%global_location_label%%2 (<= (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/layer (%Poly%lib!spec_t.hardware.PageDirectoryEntry. self!)) 3))) :pattern ((req%lib!spec_t.hardware.impl&%3.all_mb0_bits_are_zero. self!)))))
(assert (=> (fuel_bool fuel%lib!spec_t.hardware.impl&%3.all_mb0_bits_are_zero.) (forall ((self! Poly)) (! (= (lib!spec_t.hardware.impl&%3.all_mb0_bits_are_zero.? self!) (=> (= (uClip 64 (bitand (I (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/entry (%Poly%lib!spec_t.hardware.PageDirectoryEntry. self!))) (I lib!spec_t.hardware.MASK_FLAG_P.?))) lib!spec_t.hardware.MASK_FLAG_P.?) (ite (= (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/layer (%Poly%lib!spec_t.hardware.PageDirectoryEntry. self!)) 0) (and (= (uClip 64 (bitand (I (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/entry (%Poly%lib!spec_t.hardware.PageDirectoryEntry. self!))) (I (uClip 64 (bitshl (I (uClip 64 (bitnot (I (uClip 64 (bitshl (I (uClip 64 (bitnot (I 0)))) (I (uClip 64 (Sub (uClip 64 (Add 51 1)) lib!definitions_t.MAX_PHYADDR_WIDTH.?))))))))) (I lib!definitions_t.MAX_PHYADDR_WIDTH.?)))))) 0) (= (uClip 64 (bitand (I (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/entry (%Poly%lib!spec_t.hardware.PageDirectoryEntry. self!))) (I (uClip 64 (bitshl (I 1) (I 7)))))) 0)) (ite (= (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/layer (%Poly%lib!spec_t.hardware.PageDirectoryEntry. self!)) 1) (ite (= (uClip 64 (bitand (I (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/entry (%Poly%lib!spec_t.hardware.PageDirectoryEntry. self!))) (I lib!spec_t.hardware.MASK_L1_PG_FLAG_PS.?))) lib!spec_t.hardware.MASK_L1_PG_FLAG_PS.?) (and (= (uClip 64 (bitand (I (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/entry (%Poly%lib!spec_t.hardware.PageDirectoryEntry. self!))) (I (uClip 64 (bitshl (I (uClip 64 (bitnot (I (uClip 64 (bitshl (I (uClip 64 (bitnot (I 0)))) (I (uClip 64 (Sub (uClip 64 (Add 51 1)) lib!definitions_t.MAX_PHYADDR_WIDTH.?))))))))) (I lib!definitions_t.MAX_PHYADDR_WIDTH.?)))))) 0) (= (uClip 64 (bitand (I (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/entry (%Poly%lib!spec_t.hardware.PageDirectoryEntry. self!))) (I (uClip 64 (bitshl (I (uClip 64 (bitnot (I (uClip 64 (bitshl (I (uClip 64 (bitnot (I 0)))) (I (uClip 64 (Sub (uClip 64 (Add 29 1)) 13))))))))) (I 13)))))) 0)) (and (= (uClip 64 (bitand (I (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/entry (%Poly%lib!spec_t.hardware.PageDirectoryEntry. self!))) (I (uClip 64 (bitshl (I (uClip 64 (bitnot (I (uClip 64 (bitshl (I (uClip 64 (bitnot (I 0)))) (I (uClip 64 (Sub (uClip 64 (Add 51 1)) lib!definitions_t.MAX_PHYADDR_WIDTH.?))))))))) (I lib!definitions_t.MAX_PHYADDR_WIDTH.?)))))) 0) (= (uClip 64 (bitand (I (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/entry (%Poly%lib!spec_t.hardware.PageDirectoryEntry. self!))) (I (uClip 64 (bitshl (I 1) (I 7)))))) 0))) (ite (= (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/layer (%Poly%lib!spec_t.hardware.PageDirectoryEntry. self!)) 2) (ite (= (uClip 64 (bitand (I (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/entry (%Poly%lib!spec_t.hardware.PageDirectoryEntry. self!))) (I lib!spec_t.hardware.MASK_L2_PG_FLAG_PS.?))) lib!spec_t.hardware.MASK_L2_PG_FLAG_PS.?) (and (= (uClip 64 (bitand (I (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/entry (%Poly%lib!spec_t.hardware.PageDirectoryEntry. self!))) (I (uClip 64 (bitshl (I (uClip 64 (bitnot (I (uClip 64 (bitshl (I (uClip 64 (bitnot (I 0)))) (I (uClip 64 (Sub (uClip 64 (Add 62 1)) lib!definitions_t.MAX_PHYADDR_WIDTH.?))))))))) (I lib!definitions_t.MAX_PHYADDR_WIDTH.?)))))) 0) (= (uClip 64 (bitand (I (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/entry (%Poly%lib!spec_t.hardware.PageDirectoryEntry. self!))) (I (uClip 64 (bitshl (I (uClip 64 (bitnot (I (uClip 64 (bitshl (I (uClip 64 (bitnot (I 0)))) (I (uClip 64 (Sub (uClip 64 (Add 20 1)) 13))))))))) (I 13)))))) 0)) (and (= (uClip 64 (bitand (I (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/entry (%Poly%lib!spec_t.hardware.PageDirectoryEntry. self!))) (I (uClip 64 (bitshl (I (uClip 64 (bitnot (I (uClip 64 (bitshl (I (uClip 64 (bitnot (I 0)))) (I (uClip 64 (Sub (uClip 64 (Add 62 1)) lib!definitions_t.MAX_PHYADDR_WIDTH.?))))))))) (I lib!definitions_t.MAX_PHYADDR_WIDTH.?)))))) 0) (= (uClip 64 (bitand (I (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/entry (%Poly%lib!spec_t.hardware.PageDirectoryEntry. self!))) (I (uClip 64 (bitshl (I 1) (I 7)))))) 0))) (ite (= (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/layer (%Poly%lib!spec_t.hardware.PageDirectoryEntry. self!)) 3) (= (uClip 64 (bitand (I (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/entry (%Poly%lib!spec_t.hardware.PageDirectoryEntry. self!))) (I (uClip 64 (bitshl (I (uClip 64 (bitnot (I (uClip 64 (bitshl (I (uClip 64 (bitnot (I 0)))) (I (uClip 64 (Sub (uClip 64 (Add 62 1)) lib!definitions_t.MAX_PHYADDR_WIDTH.?))))))))) (I lib!definitions_t.MAX_PHYADDR_WIDTH.?)))))) 0) (%B (vstd!pervasive.arbitrary.? $ BOOL)))))))) :pattern ((lib!spec_t.hardware.impl&%3.all_mb0_bits_are_zero.? self!))))))
(assert (fuel_bool_default fuel%lib!spec_t.hardware.MASK_ADDR_SPEC.))
(assert (=> (fuel_bool fuel%lib!spec_t.hardware.MASK_ADDR_SPEC.) (= lib!spec_t.hardware.MASK_ADDR_SPEC.? (uClip 64 (bitshl (I (uClip 64 (bitnot (I (uClip 64 (bitshl (I (uClip 64 (bitnot (I 0)))) (I (uClip 64 (Sub (uClip 64 (Add (uClip 64 (Sub lib!definitions_t.MAX_PHYADDR_WIDTH.? 1)) 1)) 12))))))))) (I 12))))))
(assert (uInv 64 lib!spec_t.hardware.MASK_ADDR_SPEC.?))
(assert (fuel_bool_default fuel%lib!spec_t.hardware.MASK_L1_PG_ADDR_SPEC.))
(assert (=> (fuel_bool fuel%lib!spec_t.hardware.MASK_L1_PG_ADDR_SPEC.) (= lib!spec_t.hardware.MASK_L1_PG_ADDR_SPEC.? (uClip 64 (bitshl (I (uClip 64 (bitnot (I (uClip 64 (bitshl (I (uClip 64 (bitnot (I 0)))) (I (uClip 64 (Sub (uClip 64 (Add (uClip 64 (Sub lib!definitions_t.MAX_PHYADDR_WIDTH.? 1)) 1)) 30))))))))) (I 30))))))
(assert (uInv 64 lib!spec_t.hardware.MASK_L1_PG_ADDR_SPEC.?))
(assert (fuel_bool_default fuel%lib!spec_t.hardware.MASK_PG_FLAG_PAT.))
(assert (=> (fuel_bool fuel%lib!spec_t.hardware.MASK_PG_FLAG_PAT.) (= lib!spec_t.hardware.MASK_PG_FLAG_PAT.? (uClip 64 (bitshl (I 1) (I 12))))))
(assert (uInv 64 lib!spec_t.hardware.MASK_PG_FLAG_PAT.?))
(assert (fuel_bool_default fuel%lib!spec_t.hardware.MASK_L2_PG_ADDR_SPEC.))
(assert (=> (fuel_bool fuel%lib!spec_t.hardware.MASK_L2_PG_ADDR_SPEC.) (= lib!spec_t.hardware.MASK_L2_PG_ADDR_SPEC.? (uClip 64 (bitshl (I (uClip 64 (bitnot (I (uClip 64 (bitshl (I (uClip 64 (bitnot (I 0)))) (I (uClip 64 (Sub (uClip 64 (Add (uClip 64 (Sub lib!definitions_t.MAX_PHYADDR_WIDTH.? 1)) 1)) 21))))))))) (I 21))))))
(assert (uInv 64 lib!spec_t.hardware.MASK_L2_PG_ADDR_SPEC.?))
(assert (fuel_bool_default fuel%lib!spec_t.hardware.MASK_L3_PG_ADDR_SPEC.))
(assert (=> (fuel_bool fuel%lib!spec_t.hardware.MASK_L3_PG_ADDR_SPEC.) (= lib!spec_t.hardware.MASK_L3_PG_ADDR_SPEC.? (uClip 64 (bitshl (I (uClip 64 (bitnot (I (uClip 64 (bitshl (I (uClip 64 (bitnot (I 0)))) (I (uClip 64 (Sub (uClip 64 (Add (uClip 64 (Sub lib!definitions_t.MAX_PHYADDR_WIDTH.? 1)) 1)) 12))))))))) (I 12))))))
(assert (uInv 64 lib!spec_t.hardware.MASK_L3_PG_ADDR_SPEC.?))
(assert (fuel_bool_default fuel%lib!spec_t.hardware.MASK_L3_PG_FLAG_PAT.))
(assert (=> (fuel_bool fuel%lib!spec_t.hardware.MASK_L3_PG_FLAG_PAT.) (= lib!spec_t.hardware.MASK_L3_PG_FLAG_PAT.? (uClip 64 (bitshl (I 1) (I 7))))))
(assert (uInv 64 lib!spec_t.hardware.MASK_L3_PG_FLAG_PAT.?))
(assert (fuel_bool_default fuel%lib!spec_t.hardware.impl&%3.view.))
(assert (=> (fuel_bool fuel%lib!spec_t.hardware.impl&%3.view.) (forall ((self! Poly)) (! (= (lib!spec_t.hardware.impl&%3.view.? self!) (let ((v$ (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/entry (%Poly%lib!spec_t.hardware.PageDirectoryEntry. self!)))) (let ((flag_P$ (= (uClip 64 (bitand (I v$) (I lib!spec_t.hardware.MASK_FLAG_P.?))) lib!spec_t.hardware.MASK_FLAG_P.?))) (let ((flag_RW$ (= (uClip 64 (bitand (I v$) (I lib!spec_t.hardware.MASK_FLAG_RW.?))) lib!spec_t.hardware.MASK_FLAG_RW.?))) (let ((flag_US$ (= (uClip 64 (bitand (I v$) (I lib!spec_t.hardware.MASK_FLAG_US.?))) lib!spec_t.hardware.MASK_FLAG_US.?))) (let ((flag_PWT$ (= (uClip 64 (bitand (I v$) (I lib!spec_t.hardware.MASK_FLAG_PWT.?))) lib!spec_t.hardware.MASK_FLAG_PWT.?))) (let ((flag_PCD$ (= (uClip 64 (bitand (I v$) (I lib!spec_t.hardware.MASK_FLAG_PCD.?))) lib!spec_t.hardware.MASK_FLAG_PCD.?))) (let ((flag_A$ (= (uClip 64 (bitand (I v$) (I lib!spec_t.hardware.MASK_FLAG_A.?))) lib!spec_t.hardware.MASK_FLAG_A.?))) (let ((flag_XD$ (= (uClip 64 (bitand (I v$) (I lib!spec_t.hardware.MASK_FLAG_XD.?))) lib!spec_t.hardware.MASK_FLAG_XD.?))) (let ((flag_D$ (= (uClip 64 (bitand (I v$) (I lib!spec_t.hardware.MASK_PG_FLAG_D.?))) lib!spec_t.hardware.MASK_PG_FLAG_D.?))) (let ((flag_G$ (= (uClip 64 (bitand (I v$) (I lib!spec_t.hardware.MASK_PG_FLAG_G.?))) lib!spec_t.hardware.MASK_PG_FLAG_G.?))) (ite (<= (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/layer (%Poly%lib!spec_t.hardware.PageDirectoryEntry. self!)) 3) (ite (and (= (uClip 64 (bitand (I v$) (I lib!spec_t.hardware.MASK_FLAG_P.?))) lib!spec_t.hardware.MASK_FLAG_P.?) (lib!spec_t.hardware.impl&%3.all_mb0_bits_are_zero.? self!)) (ite (= (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/layer (%Poly%lib!spec_t.hardware.PageDirectoryEntry. self!)) 0) (let ((addr$ (uClip SZ (uClip 64 (bitand (I v$) (I lib!spec_t.hardware.MASK_ADDR_SPEC.?)))))) (lib!spec_t.hardware.GhostPageDirectoryEntry./Directory (%I (I addr$)) (%B (B flag_P$)) (%B (B flag_RW$)) (%B (B flag_US$)) (%B (B flag_PWT$)) (%B (B flag_PCD$)) (%B (B flag_A$)) (%B (B flag_XD$)))) (ite (= (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/layer (%Poly%lib!spec_t.hardware.PageDirectoryEntry. self!)) 1) (ite (= (uClip 64 (bitand (I v$) (I lib!spec_t.hardware.MASK_L1_PG_FLAG_PS.?))) lib!spec_t.hardware.MASK_L1_PG_FLAG_PS.?) (let ((addr$ (uClip SZ (uClip 64 (bitand (I v$) (I lib!spec_t.hardware.MASK_L1_PG_ADDR_SPEC.?)))))) (let ((flag_PAT$ (= (uClip 64 (bitand (I v$) (I lib!spec_t.hardware.MASK_PG_FLAG_PAT.?))) lib!spec_t.hardware.MASK_PG_FLAG_PAT.?))) (lib!spec_t.hardware.GhostPageDirectoryEntry./Page (%I (I addr$)) (%B (B flag_P$)) (%B (B flag_RW$)) (%B (B flag_US$)) (%B (B flag_PWT$)) (%B (B flag_PCD$)) (%B (B flag_A$)) (%B (B flag_D$)) (%B (B flag_G$)) (%B (B flag_PAT$)) (%B (B flag_XD$))))) (let ((addr$ (uClip SZ (uClip 64 (bitand (I v$) (I lib!spec_t.hardware.MASK_ADDR_SPEC.?)))))) (lib!spec_t.hardware.GhostPageDirectoryEntry./Directory (%I (I addr$)) (%B (B flag_P$)) (%B (B flag_RW$)) (%B (B flag_US$)) (%B (B flag_PWT$)) (%B (B flag_PCD$)) (%B (B flag_A$)) (%B (B flag_XD$))))) (ite (= (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/layer (%Poly%lib!spec_t.hardware.PageDirectoryEntry. self!)) 2) (ite (= (uClip 64 (bitand (I v$) (I lib!spec_t.hardware.MASK_L2_PG_FLAG_PS.?))) lib!spec_t.hardware.MASK_L2_PG_FLAG_PS.?) (let ((addr$ (uClip SZ (uClip 64 (bitand (I v$) (I lib!spec_t.hardware.MASK_L2_PG_ADDR_SPEC.?)))))) (let ((flag_PAT$ (= (uClip 64 (bitand (I v$) (I lib!spec_t.hardware.MASK_PG_FLAG_PAT.?))) lib!spec_t.hardware.MASK_PG_FLAG_PAT.?))) (lib!spec_t.hardware.GhostPageDirectoryEntry./Page (%I (I addr$)) (%B (B flag_P$)) (%B (B flag_RW$)) (%B (B flag_US$)) (%B (B flag_PWT$)) (%B (B flag_PCD$)) (%B (B flag_A$)) (%B (B flag_D$)) (%B (B flag_G$)) (%B (B flag_PAT$)) (%B (B flag_XD$))))) (let ((addr$ (uClip SZ (uClip 64 (bitand (I v$) (I lib!spec_t.hardware.MASK_ADDR_SPEC.?)))))) (lib!spec_t.hardware.GhostPageDirectoryEntry./Directory (%I (I addr$)) (%B (B flag_P$)) (%B (B flag_RW$)) (%B (B flag_US$)) (%B (B flag_PWT$)) (%B (B flag_PCD$)) (%B (B flag_A$)) (%B (B flag_XD$))))) (let ((addr$ (uClip SZ (uClip 64 (bitand (I v$) (I lib!spec_t.hardware.MASK_L3_PG_ADDR_SPEC.?)))))) (let ((flag_PAT$ (= (uClip 64 (bitand (I v$) (I lib!spec_t.hardware.MASK_L3_PG_FLAG_PAT.?))) lib!spec_t.hardware.MASK_L3_PG_FLAG_PAT.?))) (lib!spec_t.hardware.GhostPageDirectoryEntry./Page (%I (I addr$)) (%B (B flag_P$)) (%B (B flag_RW$)) (%B (B flag_US$)) (%B (B flag_PWT$)) (%B (B flag_PCD$)) (%B (B flag_A$)) (%B (B flag_D$)) (%B (B flag_G$)) (%B (B flag_PAT$)) (%B (B flag_XD$)))))))) lib!spec_t.hardware.GhostPageDirectoryEntry./Empty) (%Poly%lib!spec_t.hardware.GhostPageDirectoryEntry. (vstd!pervasive.arbitrary.? $ TYPE%lib!spec_t.hardware.GhostPageDirectoryEntry.)))))))))))))) :pattern ((lib!spec_t.hardware.impl&%3.view.? self!))))))
(assert (forall ((self! Poly)) (! (=> (has_type self! TYPE%lib!spec_t.hardware.PageDirectoryEntry.) (has_type (Poly%lib!spec_t.hardware.GhostPageDirectoryEntry. (lib!spec_t.hardware.impl&%3.view.? self!)) TYPE%lib!spec_t.hardware.GhostPageDirectoryEntry.)) :pattern ((lib!spec_t.hardware.impl&%3.view.? self!)))))
(declare-fun ens%lib!definitions_t.axiom_max_phyaddr_width_facts. (Int) Bool)
(assert (forall ((no%param Int)) (! (= (ens%lib!definitions_t.axiom_max_phyaddr_width_facts. no%param) (let ((tmp%%$ lib!definitions_t.MAX_PHYADDR_WIDTH.?)) (and (<= 32 tmp%%$) (<= tmp%%$ 52)))) :pattern ((ens%lib!definitions_t.axiom_max_phyaddr_width_facts. no%param)))))
(assert (fuel_bool_default fuel%lib!spec_t.hardware.impl&%1.get_Directory_addr.))
(assert (=> (fuel_bool fuel%lib!spec_t.hardware.impl&%1.get_Directory_addr.) (forall ((self! Poly)) (! (= (lib!spec_t.hardware.impl&%1.get_Directory_addr.? self!) (lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/addr (%Poly%lib!spec_t.hardware.GhostPageDirectoryEntry. self!))) :pattern ((lib!spec_t.hardware.impl&%1.get_Directory_addr.? self!))))))
(assert (forall ((self! Poly)) (! (=> (has_type self! TYPE%lib!spec_t.hardware.GhostPageDirectoryEntry.) (uInv SZ (lib!spec_t.hardware.impl&%1.get_Directory_addr.? self!))) :pattern ((lib!spec_t.hardware.impl&%1.get_Directory_addr.? self!)))))
(assert (fuel_bool_default fuel%lib!spec_t.hardware.impl&%1.get_Directory_flag_RW.))
(assert (=> (fuel_bool fuel%lib!spec_t.hardware.impl&%1.get_Directory_flag_RW.) (forall ((self! Poly)) (! (= (lib!spec_t.hardware.impl&%1.get_Directory_flag_RW.? self!) (lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/flag_RW (%Poly%lib!spec_t.hardware.GhostPageDirectoryEntry. self!))) :pattern ((lib!spec_t.hardware.impl&%1.get_Directory_flag_RW.? self!))))))
(assert (fuel_bool_default fuel%lib!spec_t.hardware.impl&%1.get_Directory_flag_US.))
(assert (=> (fuel_bool fuel%lib!spec_t.hardware.impl&%1.get_Directory_flag_US.) (forall ((self! Poly)) (! (= (lib!spec_t.hardware.impl&%1.get_Directory_flag_US.? self!) (lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/flag_US (%Poly%lib!spec_t.hardware.GhostPageDirectoryEntry. self!))) :pattern ((lib!spec_t.hardware.impl&%1.get_Directory_flag_US.? self!))))))
(assert (fuel_bool_default fuel%lib!spec_t.hardware.impl&%1.get_Directory_flag_XD.))
(assert (=> (fuel_bool fuel%lib!spec_t.hardware.impl&%1.get_Directory_flag_XD.) (forall ((self! Poly)) (! (= (lib!spec_t.hardware.impl&%1.get_Directory_flag_XD.? self!) (lib!spec_t.hardware.GhostPageDirectoryEntry./Directory/flag_XD (%Poly%lib!spec_t.hardware.GhostPageDirectoryEntry. self!))) :pattern ((lib!spec_t.hardware.impl&%1.get_Directory_flag_XD.? self!))))))
(assert (fuel_bool_default fuel%lib!impl_u.l2_impl.impl&%0.hp_pat_is_zero.))
(define-fun is-lib!spec_t.hardware.GhostPageDirectoryEntry./Page_ ((c lib!spec_t.hardware.GhostPageDirectoryEntry.)) Bool ((_ is lib!spec_t.hardware.GhostPageDirectoryEntry./Page) c))
(assert (=> (fuel_bool fuel%lib!impl_u.l2_impl.impl&%0.hp_pat_is_zero.) (forall ((self! Poly)) (! (= (lib!impl_u.l2_impl.impl&%0.hp_pat_is_zero.? self!) (and (=> (and (is-lib!spec_t.hardware.GhostPageDirectoryEntry./Page_ (lib!spec_t.hardware.impl&%3.view.? self!)) (= (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/layer (%Poly%lib!spec_t.hardware.PageDirectoryEntry. self!)) 1)) (= (uClip 64 (bitand (I (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/entry (%Poly%lib!spec_t.hardware.PageDirectoryEntry. self!))) (I lib!spec_t.hardware.MASK_PG_FLAG_PAT.?))) 0)) (=> (and (is-lib!spec_t.hardware.GhostPageDirectoryEntry./Page_ (lib!spec_t.hardware.impl&%3.view.? self!)) (= (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/layer (%Poly%lib!spec_t.hardware.PageDirectoryEntry. self!)) 2)) (= (uClip 64 (bitand (I (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/entry (%Poly%lib!spec_t.hardware.PageDirectoryEntry. self!))) (I lib!spec_t.hardware.MASK_PG_FLAG_PAT.?))) 0)))) :pattern ((lib!impl_u.l2_impl.impl&%0.hp_pat_is_zero.? self!))))))
(declare-fun req%lib!extra.aligned_transitive. (Int Int Int) Bool)
(declare-const %%global_location_label%%3 Bool)
(declare-const %%global_location_label%%4 Bool)
(declare-const %%global_location_label%%5 Bool)
(declare-const %%global_location_label%%6 Bool)
(assert (forall ((a! Int) (b! Int) (c! Int)) (! (= (req%lib!extra.aligned_transitive. a! b! c!) (and (=> %%global_location_label%%3 (< 0 b!)) (=> %%global_location_label%%4 (< 0 c!)) (=> %%global_location_label%%5 (lib!definitions_t.aligned.? (I a!) (I b!))) (=> %%global_location_label%%6 (lib!definitions_t.aligned.? (I b!) (I c!))))) :pattern ((req%lib!extra.aligned_transitive. a! b! c!)))))
(declare-fun ens%lib!extra.aligned_transitive. (Int Int Int) Bool)
(assert (forall ((a! Int) (b! Int) (c! Int)) (! (= (ens%lib!extra.aligned_transitive. a! b! c!) (lib!definitions_t.aligned.? (I a!) (I c!))) :pattern ((ens%lib!extra.aligned_transitive. a! b! c!)))))
(assert (fuel_bool_default fuel%lib!impl_u.l2_impl.addr_is_zero_padded.))
(assert (=> (fuel_bool fuel%lib!impl_u.l2_impl.addr_is_zero_padded.) (forall ((layer! Poly) (addr! Poly) (is_page! Poly)) (! (= (lib!impl_u.l2_impl.addr_is_zero_padded.? layer! addr! is_page!) (=> (%B is_page!) (ite (= (%I layer!) 1) (= (uClip 64 (bitand (I (%I addr!)) (I lib!spec_t.hardware.MASK_L1_PG_ADDR_SPEC.?))) (%I addr!)) (ite (= (%I layer!) 2) (= (uClip 64 (bitand (I (%I addr!)) (I lib!spec_t.hardware.MASK_L2_PG_ADDR_SPEC.?))) (%I addr!)) (ite (= (%I layer!) 3) (= (uClip 64 (bitand (I (%I addr!)) (I lib!spec_t.hardware.MASK_L3_PG_ADDR_SPEC.?))) (%I addr!)) (%B (vstd!pervasive.arbitrary.? $ BOOL))))))) :pattern ((lib!impl_u.l2_impl.addr_is_zero_padded.? layer! addr! is_page!))))))
(assert (fuel_bool_default fuel%lib!spec_t.hardware.impl&%1.get_Page_addr.))
(assert (=> (fuel_bool fuel%lib!spec_t.hardware.impl&%1.get_Page_addr.) (forall ((self! Poly)) (! (= (lib!spec_t.hardware.impl&%1.get_Page_addr.? self!) (lib!spec_t.hardware.GhostPageDirectoryEntry./Page/addr (%Poly%lib!spec_t.hardware.GhostPageDirectoryEntry. self!))) :pattern ((lib!spec_t.hardware.impl&%1.get_Page_addr.? self!))))))
(assert (forall ((self! Poly)) (! (=> (has_type self! TYPE%lib!spec_t.hardware.GhostPageDirectoryEntry.) (uInv SZ (lib!spec_t.hardware.impl&%1.get_Page_addr.? self!))) :pattern ((lib!spec_t.hardware.impl&%1.get_Page_addr.? self!)))))
(assert (fuel_bool_default fuel%lib!spec_t.hardware.impl&%1.get_Page_flag_RW.))
(assert (=> (fuel_bool fuel%lib!spec_t.hardware.impl&%1.get_Page_flag_RW.) (forall ((self! Poly)) (! (= (lib!spec_t.hardware.impl&%1.get_Page_flag_RW.? self!) (lib!spec_t.hardware.GhostPageDirectoryEntry./Page/flag_RW (%Poly%lib!spec_t.hardware.GhostPageDirectoryEntry. self!))) :pattern ((lib!spec_t.hardware.impl&%1.get_Page_flag_RW.? self!))))))
(assert (fuel_bool_default fuel%lib!spec_t.hardware.impl&%1.get_Page_flag_US.))
(assert (=> (fuel_bool fuel%lib!spec_t.hardware.impl&%1.get_Page_flag_US.) (forall ((self! Poly)) (! (= (lib!spec_t.hardware.impl&%1.get_Page_flag_US.? self!) (lib!spec_t.hardware.GhostPageDirectoryEntry./Page/flag_US (%Poly%lib!spec_t.hardware.GhostPageDirectoryEntry. self!))) :pattern ((lib!spec_t.hardware.impl&%1.get_Page_flag_US.? self!))))))
(assert (fuel_bool_default fuel%lib!spec_t.hardware.impl&%1.get_Page_flag_XD.))
(assert (=> (fuel_bool fuel%lib!spec_t.hardware.impl&%1.get_Page_flag_XD.) (forall ((self! Poly)) (! (= (lib!spec_t.hardware.impl&%1.get_Page_flag_XD.? self!) (lib!spec_t.hardware.GhostPageDirectoryEntry./Page/flag_XD (%Poly%lib!spec_t.hardware.GhostPageDirectoryEntry. self!))) :pattern ((lib!spec_t.hardware.impl&%1.get_Page_flag_XD.? self!))))))
(assert (fuel_bool_default fuel%lib!spec_t.hardware.MASK_DIR_ADDR_SPEC.))
(assert (=> (fuel_bool fuel%lib!spec_t.hardware.MASK_DIR_ADDR_SPEC.) (= lib!spec_t.hardware.MASK_DIR_ADDR_SPEC.? lib!spec_t.hardware.MASK_ADDR_SPEC.?)))
(assert (uInv 64 lib!spec_t.hardware.MASK_DIR_ADDR_SPEC.?))
(assert (fuel_bool_default fuel%lib!spec_t.hardware.impl&%3.layer.))
(assert (=> (fuel_bool fuel%lib!spec_t.hardware.impl&%3.layer.) (forall ((self! Poly)) (! (= (lib!spec_t.hardware.impl&%3.layer.? self!) (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/layer (%Poly%lib!spec_t.hardware.PageDirectoryEntry. self!))) :pattern ((lib!spec_t.hardware.impl&%3.layer.? self!))))))
(assert (forall ((self! Poly)) (! (=> (has_type self! TYPE%lib!spec_t.hardware.PageDirectoryEntry.) (<= 0 (lib!spec_t.hardware.impl&%3.layer.? self!))) :pattern ((lib!spec_t.hardware.impl&%3.layer.? self!)))))
(declare-fun req%lib!impl_u.l2_impl.impl&%0.lemma_zero_entry_facts. (lib!spec_t.hardware.PageDirectoryEntry.) Bool)
(declare-const %%global_location_label%%7 Bool)
(declare-const %%global_location_label%%8 Bool)
(assert (forall ((self! lib!spec_t.hardware.PageDirectoryEntry.)) (! (= (req%lib!impl_u.l2_impl.impl&%0.lemma_zero_entry_facts. self!) (and (=> %%global_location_label%%7 (= (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/entry (%Poly%lib!spec_t.hardware.PageDirectoryEntry. (Poly%lib!spec_t.hardware.PageDirectoryEntry. self!))) 0)) (=> %%global_location_label%%8 (<= (lib!spec_t.hardware.PageDirectoryEntry./PageDirectoryEntry/layer (%Poly%lib!spec_t.hardware.PageDirectoryEntry. (Poly%lib!spec_t.hardware.PageDirectoryEntry. self!))) 3)))) :pattern ((req%lib!impl_u.l2_impl.impl&%0.lemma_zero_entry_facts. self!)))))
(declare-fun ens%lib!impl_u.l2_impl.impl&%0.lemma_zero_entry_facts. (lib!spec_t.hardware.PageDirectoryEntry.) Bool)
(define-fun is-lib!spec_t.hardware.GhostPageDirectoryEntry./Empty_ ((c lib!spec_t.hardware.GhostPageDirectoryEntry.)) Bool ((_ is lib!spec_t.hardware.GhostPageDirectoryEntry./Empty) c))
(assert (forall ((self! lib!spec_t.hardware.PageDirectoryEntry.)) (! (= (ens%lib!impl_u.l2_impl.impl&%0.lemma_zero_entry_facts. self!) (and (is-lib!spec_t.hardware.GhostPageDirectoryEntry./Empty_ (lib!spec_t.hardware.impl&%3.view.? (Poly%lib!spec_t.hardware.PageDirectoryEntry. self!))) (lib!spec_t.hardware.impl&%3.all_mb0_bits_are_zero.? (Poly%lib!spec_t.hardware.PageDirectoryEntry. self!)))) :pattern ((ens%lib!impl_u.l2_impl.impl&%0.lemma_zero_entry_facts. self!)))))
(assert true)
(declare-const %%location_label%%0 Bool)
(assert (not (=> %%location_label%%0 (= (bvand (_ bv0 1) (_ bv1 1)) (_ bv0 1)))))
(check-sat)
(exit)
