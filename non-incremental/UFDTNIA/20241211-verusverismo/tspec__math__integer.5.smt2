(set-info :smt-lib-version 2.6)
(set-logic UFDTNIA)
(set-info :source |
Generated by: Amar Shah
Generated on: 2024-12-11
Generator: Verus
Application: Verification of Rust Program
Target solver: z3
Time limit: 10
Benchmarks generated by the Rust verifier Verus (https://verus-lang.github.io/verus/guide/) on the project Verismo (https://www.usenix.org/conference/osdi24/presentation/zhou) and processed using Mariposa (https://github.com/secure-foundations/mariposa). z3 solves this without nonlinear, but it cannot be expressed in SMTLib without a nonlinear theory.
|)
(set-info :license "https://creativecommons.org/licenses/by/4.0/")
(set-info :category "industrial")
(set-info :status unsat)
(set-option :auto_config false)
(set-option :smt.mbqi false)
(set-option :smt.case_split 3)
(set-option :smt.qi.eager_threshold 100.0)
(set-option :smt.delay_units true)
(set-option :smt.arith.solver 2)
(set-option :smt.arith.nl false)
(set-option :pi.enabled false)
(set-option :rewriter.sort_disjunctions false)
(set-info :comment ";; Prelude")
(set-info :comment ";; AIR prelude")
(declare-sort %%Function%% 0)
(declare-sort FuelId 0)
(declare-sort Fuel 0)
(declare-const zero Fuel)
(declare-fun succ (Fuel) Fuel)
(declare-fun fuel_bool (FuelId) Bool)
(declare-fun fuel_bool_default (FuelId) Bool)
(declare-const fuel_defaults Bool)
(assert (=> fuel_defaults (forall ((id FuelId)) (! (= (fuel_bool id) (fuel_bool_default id)) :pattern ((fuel_bool id))))))
(declare-sort Char 0)
(declare-fun char%from_unicode (Int) Char)
(declare-fun char%to_unicode (Char) Int)
(declare-sort StrSlice 0)
(declare-fun str%strslice_is_ascii (StrSlice) Bool)
(declare-fun str%strslice_len (StrSlice) Int)
(declare-fun str%strslice_get_char (StrSlice Int) Char)
(declare-fun str%new_strlit (Int) StrSlice)
(declare-fun str%from_strlit (StrSlice) Int)
(declare-datatypes ((fndef 0)) (((fndef_singleton ))))
(declare-sort Poly 0)
(declare-sort Height 0)
(declare-fun I (Int) Poly)
(declare-fun B (Bool) Poly)
(declare-fun F (fndef) Poly)
(declare-fun %I (Poly) Int)
(declare-fun %B (Poly) Bool)
(declare-fun %F (Poly) fndef)
(declare-fun S (StrSlice) Poly)
(declare-fun %S (Poly) StrSlice)
(declare-fun C (Char) Poly)
(declare-fun %C (Poly) Char)
(declare-sort Type 0)
(declare-const BOOL Type)
(declare-const INT Type)
(declare-const NAT Type)
(declare-const STRSLICE Type)
(declare-const CHAR Type)
(declare-fun UINT (Int) Type)
(declare-fun SINT (Int) Type)
(declare-fun CONST_INT (Int) Type)
(declare-sort Dcr 0)
(declare-const $ Dcr)
(declare-fun REF (Dcr) Dcr)
(declare-fun MUT_REF (Dcr) Dcr)
(declare-fun BOX (Dcr) Dcr)
(declare-fun RC (Dcr) Dcr)
(declare-fun ARC (Dcr) Dcr)
(declare-fun GHOST (Dcr) Dcr)
(declare-fun TRACKED (Dcr) Dcr)
(declare-fun NEVER (Dcr) Dcr)
(declare-fun ARRAY (Dcr Type Dcr Type) Type)
(declare-fun SLICE (Dcr Type) Type)
(declare-fun has_type (Poly Type) Bool)
(declare-fun as_type (Poly Type) Poly)
(declare-fun mk_fun (%%Function%%) %%Function%%)
(declare-fun const_int (Type) Int)
(assert (forall ((i Int)) (! (= i (const_int (CONST_INT i))) :pattern ((CONST_INT i)))))
(assert (forall ((b Bool)) (! (has_type (B b) BOOL) :pattern ((has_type (B b) BOOL)))))
(assert (forall ((x Poly) (True Type)) (! (and (has_type (as_type x True) True) (=> (has_type x True) (= x (as_type x True)))) :pattern ((as_type x True)))))
(assert (forall ((x %%Function%%)) (! (= (mk_fun x) x) :pattern ((mk_fun x)))))
(assert (forall ((x Bool)) (! (= x (%B (B x))) :pattern ((B x)))))
(assert (forall ((x Int)) (! (= x (%I (I x))) :pattern ((I x)))))
(assert (forall ((x Poly)) (! (=> (has_type x BOOL) (= x (B (%B x)))) :pattern ((has_type x BOOL)))))
(assert (forall ((x Poly)) (! (=> (has_type x INT) (= x (I (%I x)))) :pattern ((has_type x INT)))))
(assert (forall ((x Poly)) (! (=> (has_type x NAT) (= x (I (%I x)))) :pattern ((has_type x NAT)))))
(assert (forall ((bits Int) (x Poly)) (! (=> (has_type x (UINT bits)) (= x (I (%I x)))) :pattern ((has_type x (UINT bits))))))
(assert (forall ((bits Int) (x Poly)) (! (=> (has_type x (SINT bits)) (= x (I (%I x)))) :pattern ((has_type x (SINT bits))))))
(assert (forall ((x Int)) (! (= (str%from_strlit (str%new_strlit x)) x) :pattern ((str%new_strlit x)))))
(assert (forall ((x Poly)) (! (=> (has_type x STRSLICE) (= x (S (%S x)))) :pattern ((has_type x STRSLICE)))))
(assert (forall ((x StrSlice)) (! (= x (%S (S x))) :pattern ((S x)))))
(assert (forall ((x StrSlice)) (! (has_type (S x) STRSLICE) :pattern ((has_type (S x) STRSLICE)))))
(declare-fun ext_eq (Bool Type Poly Poly) Bool)
(assert (forall ((deep Bool) (True Type) (x Poly) (y Poly)) (! (= (= x y) (ext_eq deep True x y)) :pattern ((ext_eq deep True x y)))))
(declare-const SZ Int)
(assert (= SZ 64))
(declare-fun uHi (Int) Int)
(declare-fun iLo (Int) Int)
(declare-fun iHi (Int) Int)
(assert (= (uHi 8) 256))
(assert (= (uHi 16) 65536))
(assert (= (uHi 32) 4294967296))
(assert (= (uHi 64) 18446744073709551616))
(assert (= (uHi 128) (+ 1 340282366920938463463374607431768211455)))
(assert (= (iLo 8) (- 128)))
(assert (= (iLo 16) (- 32768)))
(assert (= (iLo 32) (- 2147483648)))
(assert (= (iLo 64) (- 9223372036854775808)))
(assert (= (iLo 128) (- 170141183460469231731687303715884105728)))
(assert (= (iHi 8) 128))
(assert (= (iHi 16) 32768))
(assert (= (iHi 32) 2147483648))
(assert (= (iHi 64) 9223372036854775808))
(assert (= (iHi 128) 170141183460469231731687303715884105728))
(declare-fun nClip (Int) Int)
(declare-fun uClip (Int Int) Int)
(declare-fun iClip (Int Int) Int)
(assert (forall ((i Int)) (! (and (<= 0 (nClip i)) (=> (<= 0 i) (= i (nClip i)))) :pattern ((nClip i)))))
(assert (forall ((bits Int) (i Int)) (! (and (<= 0 (uClip bits i)) (< (uClip bits i) (uHi bits)) (=> (and (<= 0 i) (< i (uHi bits))) (= i (uClip bits i)))) :pattern ((uClip bits i)))))
(assert (forall ((bits Int) (i Int)) (! (and (<= (iLo bits) (iClip bits i)) (< (iClip bits i) (iHi bits)) (=> (and (<= (iLo bits) i) (< i (iHi bits))) (= i (iClip bits i)))) :pattern ((iClip bits i)))))
(declare-fun uInv (Int Int) Bool)
(declare-fun iInv (Int Int) Bool)
(assert (forall ((bits Int) (i Int)) (! (= (uInv bits i) (and (<= 0 i) (< i (uHi bits)))) :pattern ((uInv bits i)))))
(assert (forall ((bits Int) (i Int)) (! (= (iInv bits i) (and (<= (iLo bits) i) (< i (iHi bits)))) :pattern ((iInv bits i)))))
(assert (forall ((x Int)) (! (has_type (I x) INT) :pattern ((has_type (I x) INT)))))
(assert (forall ((x Int)) (! (=> (<= 0 x) (has_type (I x) NAT)) :pattern ((has_type (I x) NAT)))))
(assert (forall ((bits Int) (x Int)) (! (=> (uInv bits x) (has_type (I x) (UINT bits))) :pattern ((has_type (I x) (UINT bits))))))
(assert (forall ((bits Int) (x Int)) (! (=> (iInv bits x) (has_type (I x) (SINT bits))) :pattern ((has_type (I x) (SINT bits))))))
(assert (forall ((x Poly)) (! (=> (has_type x NAT) (<= 0 (%I x))) :pattern ((has_type x NAT)))))
(assert (forall ((bits Int) (x Poly)) (! (=> (has_type x (UINT bits)) (uInv bits (%I x))) :pattern ((has_type x (UINT bits))))))
(assert (forall ((bits Int) (x Poly)) (! (=> (has_type x (SINT bits)) (iInv bits (%I x))) :pattern ((has_type x (SINT bits))))))
(declare-fun Add (Int Int) Int)
(declare-fun Sub (Int Int) Int)
(declare-fun Mul (Int Int) Int)
(declare-fun EucDiv (Int Int) Int)
(declare-fun EucMod (Int Int) Int)
(assert (forall ((x Int) (y Int)) (! (= (Add x y) (+ x y)) :pattern ((Add x y)))))
(assert (forall ((x Int) (y Int)) (! (= (Sub x y) (- x y)) :pattern ((Sub x y)))))
(assert (forall ((x Int) (y Int)) (! (= (Mul x y) (* x y)) :pattern ((Mul x y)))))
(assert (forall ((x Int) (y Int)) (! (= (EucDiv x y) (div x y)) :pattern ((EucDiv x y)))))
(assert (forall ((x Int) (y Int)) (! (= (EucMod x y) (mod x y)) :pattern ((EucMod x y)))))
(assert (forall ((x Int) (y Int)) (! (=> (and (<= 0 x) (<= 0 y)) (<= 0 (Mul x y))) :pattern ((Mul x y)))))
(assert (forall ((x Int) (y Int)) (! (=> (and (<= 0 x) (< 0 y)) (and (<= 0 (EucDiv x y)) (<= (EucDiv x y) x))) :pattern ((EucDiv x y)))))
(assert (forall ((x Int) (y Int)) (! (=> (and (<= 0 x) (< 0 y)) (and (<= 0 (EucMod x y)) (< (EucMod x y) y))) :pattern ((EucMod x y)))))
(assert (forall ((x Poly)) (! (=> (has_type x CHAR) (= x (C (%C x)))) :pattern ((has_type x CHAR)))))
(assert (forall ((x Char)) (! (= x (%C (C x))) :pattern ((C x)))))
(assert (forall ((x Char)) (! (has_type (C x) CHAR) :pattern ((has_type (C x) CHAR)))))
(assert (forall ((x Int)) (! (=> (and (<= 0 x) (< x (uHi 32))) (= x (char%to_unicode (char%from_unicode x)))) :pattern ((char%from_unicode x)))))
(assert (forall ((c Char)) (! (and (<= 0 (char%to_unicode c)) (< (char%to_unicode c) (uHi 32))) :pattern ((char%to_unicode c)))))
(declare-fun height (Poly) Height)
(declare-fun height_lt (Height Height) Bool)
(declare-fun partial-order (Height Height) Bool)
(assert (forall ((x Height)) (partial-order x x)))
(assert (forall ((x Height) (y Height)) (=> (and (partial-order x y) (partial-order y x)) (= x y))))
(assert (forall ((x Height) (y Height) (z Height)) (=> (and (partial-order x y) (partial-order y z)) (partial-order x z))))
(assert (forall ((x Height) (y Height)) (! (= (height_lt x y) (and (partial-order x y) (not (= x y)))) :pattern ((height_lt x y)))))
(declare-fun fun_from_recursive_field (Poly) Poly)
(declare-fun check_decrease_int (Int Int Bool) Bool)
(assert (forall ((cur Int) (prev Int) (otherwise Bool)) (! (= (check_decrease_int cur prev otherwise) (or (and (<= 0 cur) (< cur prev)) (and (= cur prev) otherwise))) :pattern ((check_decrease_int cur prev otherwise)))))
(declare-fun check_decrease_height (Poly Poly Bool) Bool)
(assert (forall ((cur Poly) (prev Poly) (otherwise Bool)) (! (= (check_decrease_height cur prev otherwise) (or (height_lt (height cur) (height prev)) (and (= (height cur) (height prev)) otherwise))) :pattern ((check_decrease_height cur prev otherwise)))))
(declare-fun uintxor (Int Poly Poly) Int)
(declare-fun uintand (Int Poly Poly) Int)
(declare-fun uintor (Int Poly Poly) Int)
(declare-fun uintshr (Int Poly Poly) Int)
(declare-fun uintshl (Int Poly Poly) Int)
(declare-fun uintnot (Int Poly) Int)
(declare-fun singular_mod (Int Int) Int)
(assert (forall ((x Int) (y Int)) (! (=> (not (= y 0)) (= (EucMod x y) (singular_mod x y))) :pattern ((singular_mod x y)))))
(declare-fun closure_req (Type Dcr Type Poly Poly) Bool)
(declare-fun closure_ens (Type Dcr Type Poly Poly Poly) Bool)
(set-info :comment ";; MODULE 'module tspec::math::integer'")
(set-info :comment ";; Fuel")
(declare-const fuel%verismo!tspec.math.bits_p.spec_has_bit_set. FuelId)
(declare-const fuel%verismo!tspec.math.bits_p.spec_bit64_or_properties. FuelId)
(declare-const fuel%verismo!tspec.math.cond_bound.is_upper_bound_satisfy_cond. FuelId)
(declare-const fuel%verismo!tspec.math.integer.has_bit_closure. FuelId)
(declare-const fuel%verismo!tspec.math.integer.has_bits_until. FuelId)
(declare-const fuel%verismo!tspec.math.integer.nbits_mask. FuelId)
(declare-const fuel%verismo!tspec.math.integer.is_highest_bit. FuelId)
(declare-const fuel%verismo!tspec.math.integer.spec_fill_ones_exe. FuelId)
(declare-const fuel%verismo!tspec.math.integer.spec_prev_power_of_two_exe. FuelId)
(declare-const fuel%verismo!tspec.math.integer.spec_next_power_of_two_exe. FuelId)
(declare-const fuel%verismo!tspec.math.integer.spec_highest_bit. FuelId)
(declare-const fuel%verismo!tspec.math.integer.spec_prev_power_of_two. FuelId)
(declare-const fuel%verismo!tspec.math.integer.spec_next_power_of_two. FuelId)
(declare-const fuel%verismo!tspec.math.integer.spec_is_prev_power_of_two. FuelId)
(declare-const fuel%verismo!tspec.math.integer.spec_is_next_power_of_two. FuelId)
(declare-const fuel%verismo!tspec.math.integer._fill_ones. FuelId)
(declare-const fuel%verismo!tspec.math.integer.fill_ones. FuelId)
(declare-const fuel%verismo!tspec.math.pow_s.spec_bit64_is_shl_by_bits. FuelId)
(assert (distinct fuel%verismo!tspec.math.bits_p.spec_has_bit_set. fuel%verismo!tspec.math.bits_p.spec_bit64_or_properties. fuel%verismo!tspec.math.cond_bound.is_upper_bound_satisfy_cond. fuel%verismo!tspec.math.integer.has_bit_closure. fuel%verismo!tspec.math.integer.has_bits_until. fuel%verismo!tspec.math.integer.nbits_mask. fuel%verismo!tspec.math.integer.is_highest_bit. fuel%verismo!tspec.math.integer.spec_fill_ones_exe. fuel%verismo!tspec.math.integer.spec_prev_power_of_two_exe. fuel%verismo!tspec.math.integer.spec_next_power_of_two_exe. fuel%verismo!tspec.math.integer.spec_highest_bit. fuel%verismo!tspec.math.integer.spec_prev_power_of_two. fuel%verismo!tspec.math.integer.spec_next_power_of_two. fuel%verismo!tspec.math.integer.spec_is_prev_power_of_two. fuel%verismo!tspec.math.integer.spec_is_next_power_of_two. fuel%verismo!tspec.math.integer._fill_ones. fuel%verismo!tspec.math.integer.fill_ones. fuel%verismo!tspec.math.pow_s.spec_bit64_is_shl_by_bits.))
(set-info :comment ";; Datatypes")
(declare-datatypes ((tuple%0. 0) (tuple%2. 0)) (((tuple%0./tuple%0 )) ((tuple%2./tuple%2 (tuple%2./tuple%2/?0 Poly) (tuple%2./tuple%2/?1 Poly)))))
(declare-fun tuple%2./tuple%2/0 (tuple%2.) Poly)
(declare-fun tuple%2./tuple%2/1 (tuple%2.) Poly)
(declare-fun TYPE%fun%1. (Dcr Type Dcr Type) Type)
(declare-const TYPE%tuple%0. Type)
(declare-fun TYPE%tuple%2. (Dcr Type Dcr Type) Type)
(declare-fun Poly%fun%1. (%%Function%%) Poly)
(declare-fun %Poly%fun%1. (Poly) %%Function%%)
(declare-fun Poly%tuple%0. (tuple%0.) Poly)
(declare-fun %Poly%tuple%0. (Poly) tuple%0.)
(declare-fun Poly%tuple%2. (tuple%2.) Poly)
(declare-fun %Poly%tuple%2. (Poly) tuple%2.)
(assert (forall ((x %%Function%%)) (! (= x (%Poly%fun%1. (Poly%fun%1. x))) :pattern ((Poly%fun%1. x)))))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (x Poly)) (! (=> (has_type x (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)) (= x (Poly%fun%1. (%Poly%fun%1. x)))) :pattern ((has_type x (TYPE%fun%1. T%0&. T%0& T%1&. T%1&))))))
(declare-fun %%apply%%0 (%%Function%% Poly) Poly)
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (x %%Function%%)) (! (=> (forall ((T%0 Poly)) (! (=> (has_type T%0 T%0&) (has_type (%%apply%%0 x T%0) T%1&)) :pattern ((has_type (%%apply%%0 x T%0) T%1&)))) (has_type (Poly%fun%1. (mk_fun x)) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&))) :pattern ((has_type (Poly%fun%1. (mk_fun x)) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&))))))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (T%0 Poly) (x %%Function%%)) (! (=> (and (has_type (Poly%fun%1. x) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)) (has_type T%0 T%0&)) (has_type (%%apply%%0 x T%0) T%1&)) :pattern ((%%apply%%0 x T%0) (has_type (Poly%fun%1. x) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&))))))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (T%0 Poly) (x %%Function%%)) (! (=> (and (has_type (Poly%fun%1. x) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)) (has_type T%0 T%0&)) (height_lt (height (%%apply%%0 x T%0)) (height (fun_from_recursive_field (Poly%fun%1. (mk_fun x)))))) :pattern ((height (%%apply%%0 x T%0)) (has_type (Poly%fun%1. x) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&))))))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (deep Bool) (x Poly) (y Poly)) (! (=> (and (has_type x (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)) (has_type y (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)) (forall ((T%0 Poly)) (! (=> (has_type T%0 T%0&) (ext_eq deep T%1& (%%apply%%0 (%Poly%fun%1. x) T%0) (%%apply%%0 (%Poly%fun%1. y) T%0))) :pattern ((ext_eq deep T%1& (%%apply%%0 (%Poly%fun%1. x) T%0) (%%apply%%0 (%Poly%fun%1. y) T%0)))))) (ext_eq deep (TYPE%fun%1. T%0&. T%0& T%1&. T%1&) x y)) :pattern ((ext_eq deep (TYPE%fun%1. T%0&. T%0& T%1&. T%1&) x y)))))
(assert (forall ((x tuple%0.)) (! (= x (%Poly%tuple%0. (Poly%tuple%0. x))) :pattern ((Poly%tuple%0. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%tuple%0.) (= x (Poly%tuple%0. (%Poly%tuple%0. x)))) :pattern ((has_type x TYPE%tuple%0.)))))
(assert (forall ((x tuple%0.)) (! (has_type (Poly%tuple%0. x) TYPE%tuple%0.) :pattern ((has_type (Poly%tuple%0. x) TYPE%tuple%0.)))))
(assert (forall ((x tuple%2.)) (! (= x (%Poly%tuple%2. (Poly%tuple%2. x))) :pattern ((Poly%tuple%2. x)))))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (x Poly)) (! (=> (has_type x (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&)) (= x (Poly%tuple%2. (%Poly%tuple%2. x)))) :pattern ((has_type x (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&))))))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (_0! Poly) (_1! Poly)) (! (=> (and (has_type _0! T%0&) (has_type _1! T%1&)) (has_type (Poly%tuple%2. (tuple%2./tuple%2 _0! _1!)) (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&))) :pattern ((has_type (Poly%tuple%2. (tuple%2./tuple%2 _0! _1!)) (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&))))))
(assert (forall ((x tuple%2.)) (! (= (tuple%2./tuple%2/0 x) (tuple%2./tuple%2/?0 x)) :pattern ((tuple%2./tuple%2/0 x)))))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (x Poly)) (! (=> (has_type x (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&)) (has_type (tuple%2./tuple%2/0 (%Poly%tuple%2. x)) T%0&)) :pattern ((tuple%2./tuple%2/0 (%Poly%tuple%2. x)) (has_type x (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&))))))
(assert (forall ((x tuple%2.)) (! (= (tuple%2./tuple%2/1 x) (tuple%2./tuple%2/?1 x)) :pattern ((tuple%2./tuple%2/1 x)))))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (x Poly)) (! (=> (has_type x (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&)) (has_type (tuple%2./tuple%2/1 (%Poly%tuple%2. x)) T%1&)) :pattern ((tuple%2./tuple%2/1 (%Poly%tuple%2. x)) (has_type x (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&))))))
(define-fun is-tuple%2./tuple%2_ ((c tuple%2.)) Bool ((_ is tuple%2./tuple%2) c))
(assert (forall ((x tuple%2.)) (! (=> (is-tuple%2./tuple%2_ x) (height_lt (height (tuple%2./tuple%2/0 x)) (height (Poly%tuple%2. x)))) :pattern ((height (tuple%2./tuple%2/0 x))))))
(assert (forall ((x tuple%2.)) (! (=> (is-tuple%2./tuple%2_ x) (height_lt (height (tuple%2./tuple%2/1 x)) (height (Poly%tuple%2. x)))) :pattern ((height (tuple%2./tuple%2/1 x))))))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (deep Bool) (x Poly) (y Poly)) (! (=> (and (has_type x (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&)) (has_type y (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&)) (ext_eq deep T%0& (tuple%2./tuple%2/0 (%Poly%tuple%2. x)) (tuple%2./tuple%2/0 (%Poly%tuple%2. y))) (ext_eq deep T%1& (tuple%2./tuple%2/1 (%Poly%tuple%2. x)) (tuple%2./tuple%2/1 (%Poly%tuple%2. y)))) (ext_eq deep (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&) x y)) :pattern ((ext_eq deep (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&) x y)))))
(set-info :comment ";; Function-Decl verismo::tspec::math::bits_p::spec_has_bit_set")
(declare-fun verismo!tspec.math.bits_p.spec_has_bit_set.? (Poly Poly) Bool)
(set-info :comment ";; Function-Decl verismo::tspec::math::bits_p::spec_bit64_or_properties")
(declare-fun verismo!tspec.math.bits_p.spec_bit64_or_properties.? (Poly Poly Poly) Bool)
(set-info :comment ";; Function-Decl verismo::tspec::math::cond_bound::is_upper_bound_satisfy_cond")
(declare-fun verismo!tspec.math.cond_bound.is_upper_bound_satisfy_cond.? (Poly Poly Poly) Bool)
(set-info :comment ";; Function-Decl verismo::tspec::math::integer::has_bit_closure")
(declare-fun verismo!tspec.math.integer.has_bit_closure.? (Poly) %%Function%%)
(set-info :comment ";; Function-Decl verismo::tspec::math::integer::has_bits_until")
(declare-fun verismo!tspec.math.integer.has_bits_until.? (Poly Poly Poly) Bool)
(set-info :comment ";; Function-Decl verismo::tspec::math::integer::nbits_mask")
(declare-fun verismo!tspec.math.integer.nbits_mask.? (Poly) Int)
(set-info :comment ";; Function-Decl verismo::tspec::math::integer::is_highest_bit")
(declare-fun verismo!tspec.math.integer.is_highest_bit.? (Poly Poly) Bool)
(set-info :comment ";; Function-Decl verismo::tspec::math::integer::spec_fill_ones_exe")
(declare-fun verismo!tspec.math.integer.spec_fill_ones_exe.? (Poly) Int)
(set-info :comment ";; Function-Decl verismo::tspec::math::integer::spec_prev_power_of_two_exe")
(declare-fun verismo!tspec.math.integer.spec_prev_power_of_two_exe.? (Poly) Int)
(set-info :comment ";; Function-Decl verismo::tspec::math::integer::spec_next_power_of_two_exe")
(declare-fun verismo!tspec.math.integer.spec_next_power_of_two_exe.? (Poly) Int)
(set-info :comment ";; Function-Decl verismo::tspec::math::integer::spec_highest_bit")
(declare-fun verismo!tspec.math.integer.spec_highest_bit.? (Poly) Int)
(set-info :comment ";; Function-Decl verismo::tspec::math::integer::spec_prev_power_of_two")
(declare-fun verismo!tspec.math.integer.spec_prev_power_of_two.? (Poly) Int)
(set-info :comment ";; Function-Decl verismo::tspec::math::integer::spec_next_power_of_two")
(declare-fun verismo!tspec.math.integer.spec_next_power_of_two.? (Poly) Int)
(set-info :comment ";; Function-Decl verismo::tspec::math::integer::spec_is_prev_power_of_two")
(declare-fun verismo!tspec.math.integer.spec_is_prev_power_of_two.? (Poly Poly) Bool)
(set-info :comment ";; Function-Decl verismo::tspec::math::integer::spec_is_next_power_of_two")
(declare-fun verismo!tspec.math.integer.spec_is_next_power_of_two.? (Poly Poly) Bool)
(set-info :comment ";; Function-Decl verismo::tspec::math::integer::_fill_ones")
(declare-fun verismo!tspec.math.integer._fill_ones.? (Poly Poly Poly) Int)
(declare-fun verismo!tspec.math.integer.rec%_fill_ones.? (Poly Poly Poly Fuel) Int)
(set-info :comment ";; Function-Decl verismo::tspec::math::integer::fill_ones")
(declare-fun verismo!tspec.math.integer.fill_ones.? (Poly) Int)
(set-info :comment ";; Function-Decl verismo::tspec::math::pow_s::spec_bit64_is_shl_by_bits")
(declare-fun verismo!tspec.math.pow_s.spec_bit64_is_shl_by_bits.? (Poly) Bool)
(set-info :comment ";; Function-Axioms verismo::tspec::math::bits_p::spec_has_bit_set")
(assert (fuel_bool_default fuel%verismo!tspec.math.bits_p.spec_has_bit_set.))
(assert (=> (fuel_bool fuel%verismo!tspec.math.bits_p.spec_has_bit_set.) (forall ((val! Poly) (bit! Poly)) (! (= (verismo!tspec.math.bits_p.spec_has_bit_set.? val! bit!) (= (uClip 64 (uintshl 64 (I 1) (I (%I bit!)))) (uClip 64 (uintand 64 (I (%I val!)) (I (uClip 64 (uintshl 64 (I 1) (I (%I bit!))))))))) :pattern ((verismo!tspec.math.bits_p.spec_has_bit_set.? val! bit!))))))
(set-info :comment ";; Function-Axioms verismo::tspec::math::bits_p::spec_bit64_or_properties")
(assert (fuel_bool_default fuel%verismo!tspec.math.bits_p.spec_bit64_or_properties.))
(assert (=> (fuel_bool fuel%verismo!tspec.math.bits_p.spec_bit64_or_properties.) (forall ((a! Poly) (b! Poly) (ret! Poly)) (! (= (verismo!tspec.math.bits_p.spec_bit64_or_properties.? a! b! ret!) (and (and (and (and (and (and (= (%I ret!) (uClip 64 (uintor 64 (I (%I a!)) (I (%I b!))))) (= (%I ret!) (uClip 64 (uintor 64 (I (%I b!)) (I (%I a!)))))) (and (<= 0 (%I ret!)) (<= (%I ret!) 18446744073709551615))) (= (uClip 64 (uintand 64 (I (%I ret!)) (I (%I b!)))) (%I b!))) (>= (%I ret!) (%I a!))) (>= (%I ret!) (%I b!))) (= (uClip 64 (uintand 64 (I (%I ret!)) (I (uClip 64 (uintnot 64 (I (%I b!))))))) (uClip 64 (uintand 64 (I (%I a!)) (I (uClip 64 (uintnot 64 (I (%I b!)))))))))) :pattern ((verismo!tspec.math.bits_p.spec_bit64_or_properties.? a! b! ret!))))))
(set-info :comment ";; Function-Axioms verismo::tspec::math::cond_bound::is_upper_bound_satisfy_cond")
(assert (fuel_bool_default fuel%verismo!tspec.math.cond_bound.is_upper_bound_satisfy_cond.))
(assert (=> (fuel_bool fuel%verismo!tspec.math.cond_bound.is_upper_bound_satisfy_cond.) (forall ((cond_fn! Poly) (bound! Poly) (max! Poly)) (! (= (verismo!tspec.math.cond_bound.is_upper_bound_satisfy_cond.? cond_fn! bound! max!) (and (and (%B (%%apply%%0 (%Poly%fun%1. cond_fn!) bound!)) (<= (%I bound!) (%I max!))) (forall ((b$ Poly)) (! (=> (has_type b$ (UINT 64)) (=> (and (%B (%%apply%%0 (%Poly%fun%1. cond_fn!) b$)) (<= (%I b$) (%I max!))) (<= (%I b$) (%I bound!)))) :pattern ((%%apply%%0 (%Poly%fun%1. cond_fn!) b$)))))) :pattern ((verismo!tspec.math.cond_bound.is_upper_bound_satisfy_cond.? cond_fn! bound! max!))))))
(set-info :comment ";; Function-Axioms verismo::tspec::math::integer::has_bit_closure")
(assert (fuel_bool_default fuel%verismo!tspec.math.integer.has_bit_closure.))
(declare-fun %%lambda%%0 (Int Poly Int Int Poly Int Int Poly Int Int Poly Int) %%Function%%)
(assert (forall ((%%hole%%0 Int) (%%hole%%1 Poly) (%%hole%%2 Int) (%%hole%%3 Int) (%%hole%%4 Poly) (%%hole%%5 Int) (%%hole%%6 Int) (%%hole%%7 Poly) (%%hole%%8 Int) (%%hole%%9 Int) (%%hole%%10 Poly) (%%hole%%11 Int) (b$ Poly)) (! (= (%%apply%%0 (%%lambda%%0 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5 %%hole%%6 %%hole%%7 %%hole%%8 %%hole%%9 %%hole%%10 %%hole%%11) b$) (B (= (uClip %%hole%%2 (uintshl %%hole%%0 %%hole%%1 (I (%I b$)))) (uClip %%hole%%8 (uintand %%hole%%6 %%hole%%7 (I (uClip %%hole%%5 (uintshl %%hole%%3 %%hole%%4 (I (%I b$)))))))))) :pattern ((%%apply%%0 (%%lambda%%0 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5 %%hole%%6 %%hole%%7 %%hole%%8 %%hole%%9 %%hole%%10 %%hole%%11) b$)) :pattern ((uClip %%hole%%11 (uintshl %%hole%%9 %%hole%%10 (I (%I b$))))))))
(assert (=> (fuel_bool fuel%verismo!tspec.math.integer.has_bit_closure.) (forall ((input! Poly)) (! (= (verismo!tspec.math.integer.has_bit_closure.? input!) (mk_fun (%%lambda%%0 64 (I 1) 64 64 (I 1) 64 64 (I (%I input!)) 64 64 (I 1) 64))) :pattern ((verismo!tspec.math.integer.has_bit_closure.? input!))))))
(assert (forall ((input! Poly)) (! (=> (has_type input! (UINT 64)) (has_type (Poly%fun%1. (verismo!tspec.math.integer.has_bit_closure.? input!)) (TYPE%fun%1. $ (UINT 64) $ BOOL))) :pattern ((verismo!tspec.math.integer.has_bit_closure.? input!)))))
(set-info :comment ";; Function-Axioms verismo::tspec::math::integer::has_bits_until")
(assert (fuel_bool_default fuel%verismo!tspec.math.integer.has_bits_until.))
(assert (=> (fuel_bool fuel%verismo!tspec.math.integer.has_bits_until.) (forall ((input! Poly) (nbits! Poly) (h! Poly)) (! (= (verismo!tspec.math.integer.has_bits_until.? input! nbits! h!) (and (forall ((b$ Poly)) (! (=> (has_type b$ (UINT 64)) (=> (and (<= (%I b$) (%I h!)) (< (uClip 64 (Sub (%I h!) (%I b$))) (%I nbits!))) (= (uClip 64 (uintshl 64 (I 1) (I (%I b$)))) (uClip 64 (uintand 64 (I (%I input!)) (I (uClip 64 (uintshl 64 (I 1) (I (%I b$)))))))))) :pattern ((uClip 64 (uintshl 64 (I 1) (I (%I b$))))))) (forall ((b$ Poly)) (! (=> (has_type b$ (UINT 64)) (=> (and (< (%I h!) (%I b$)) (< (%I b$) 64)) (not (= (uClip 64 (uintshl 64 (I 1) (I (%I b$)))) (uClip 64 (uintand 64 (I (%I input!)) (I (uClip 64 (uintshl 64 (I 1) (I (%I b$))))))))))) :pattern ((uClip 64 (uintshl 64 (I 1) (I (%I b$))))))))) :pattern ((verismo!tspec.math.integer.has_bits_until.? input! nbits! h!))))))
(set-info :comment ";; Function-Specs verismo::tspec::math::integer::nbits_mask")
(declare-fun req%verismo!tspec.math.integer.nbits_mask. (Poly) Bool)
(declare-const %%global_location_label%%0 Bool)
(assert (forall ((nbits! Poly)) (! (= (req%verismo!tspec.math.integer.nbits_mask. nbits!) (=> %%global_location_label%%0 (and (< 0 (%I nbits!)) (<= (%I nbits!) 64)))) :pattern ((req%verismo!tspec.math.integer.nbits_mask. nbits!)))))
(set-info :comment ";; Function-Axioms verismo::tspec::math::integer::nbits_mask")
(assert (fuel_bool_default fuel%verismo!tspec.math.integer.nbits_mask.))
(assert (=> (fuel_bool fuel%verismo!tspec.math.integer.nbits_mask.) (forall ((nbits! Poly)) (! (= (verismo!tspec.math.integer.nbits_mask.? nbits!) (uClip 64 (uintor 64 (I (uClip 64 (uintshl 64 (I (uClip 64 (Sub (uClip 64 (uintshl 64 (I 1) (I (uClip 64 (uClip 64 (Sub (%I nbits!) 1)))))) 1))) (I 1)))) (I 1)))) :pattern ((verismo!tspec.math.integer.nbits_mask.? nbits!))))))
(assert (forall ((nbits! Poly)) (! (=> (has_type nbits! (UINT 64)) (uInv 64 (verismo!tspec.math.integer.nbits_mask.? nbits!))) :pattern ((verismo!tspec.math.integer.nbits_mask.? nbits!)))))
(set-info :comment ";; Function-Axioms verismo::tspec::math::integer::is_highest_bit")
(assert (fuel_bool_default fuel%verismo!tspec.math.integer.is_highest_bit.))
(assert (=> (fuel_bool fuel%verismo!tspec.math.integer.is_highest_bit.) (forall ((input! Poly) (bit! Poly)) (! (= (verismo!tspec.math.integer.is_highest_bit.? input! bit!) (verismo!tspec.math.cond_bound.is_upper_bound_satisfy_cond.? (Poly%fun%1. (verismo!tspec.math.integer.has_bit_closure.? input!)) bit! (I 63))) :pattern ((verismo!tspec.math.integer.is_highest_bit.? input! bit!))))))
(set-info :comment ";; Function-Axioms verismo::tspec::math::integer::spec_fill_ones_exe")
(assert (fuel_bool_default fuel%verismo!tspec.math.integer.spec_fill_ones_exe.))
(assert (=> (fuel_bool fuel%verismo!tspec.math.integer.spec_fill_ones_exe.) (forall ((input! Poly)) (! (= (verismo!tspec.math.integer.spec_fill_ones_exe.? input!) (let ((ret$ (%I input!))) (let ((ret$1 (uClip 64 (uintor 64 (I ret$) (I (uClip 64 (uintshr 64 (I ret$) (I 1)))))))) (let ((ret$2 (uClip 64 (uintor 64 (I ret$1) (I (uClip 64 (uintshr 64 (I ret$1) (I 2)))))))) (let ((ret$3 (uClip 64 (uintor 64 (I ret$2) (I (uClip 64 (uintshr 64 (I ret$2) (I 4)))))))) (let ((ret$4 (uClip 64 (uintor 64 (I ret$3) (I (uClip 64 (uintshr 64 (I ret$3) (I 8)))))))) (let ((ret$5 (uClip 64 (uintor 64 (I ret$4) (I (uClip 64 (uintshr 64 (I ret$4) (I 16)))))))) (let ((ret$6 (uClip 64 (uintor 64 (I ret$5) (I (uClip 64 (uintshr 64 (I ret$5) (I 32)))))))) ret$6)))))))) :pattern ((verismo!tspec.math.integer.spec_fill_ones_exe.? input!))))))
(assert (forall ((input! Poly)) (! (=> (has_type input! (UINT 64)) (uInv 64 (verismo!tspec.math.integer.spec_fill_ones_exe.? input!))) :pattern ((verismo!tspec.math.integer.spec_fill_ones_exe.? input!)))))
(set-info :comment ";; Function-Axioms verismo::tspec::math::integer::spec_prev_power_of_two_exe")
(assert (fuel_bool_default fuel%verismo!tspec.math.integer.spec_prev_power_of_two_exe.))
(assert (=> (fuel_bool fuel%verismo!tspec.math.integer.spec_prev_power_of_two_exe.) (forall ((input! Poly)) (! (= (verismo!tspec.math.integer.spec_prev_power_of_two_exe.? input!) (ite (= (%I input!) 0) 0 (let ((ret$ (let ((ret$$0 (%I input!))) (let ((ret$$1 (uClip 64 (uintor 64 (I ret$$0) (I (uClip 64 (uintshr 64 (I ret$$0) (I 1)))))))) (let ((ret$$2 (uClip 64 (uintor 64 (I ret$$1) (I (uClip 64 (uintshr 64 (I ret$$1) (I 2)))))))) (let ((ret$$3 (uClip 64 (uintor 64 (I ret$$2) (I (uClip 64 (uintshr 64 (I ret$$2) (I 4)))))))) (let ((ret$$4 (uClip 64 (uintor 64 (I ret$$3) (I (uClip 64 (uintshr 64 (I ret$$3) (I 8)))))))) (let ((ret$$5 (uClip 64 (uintor 64 (I ret$$4) (I (uClip 64 (uintshr 64 (I ret$$4) (I 16)))))))) (let ((ret$$6 (uClip 64 (uintor 64 (I ret$$5) (I (uClip 64 (uintshr 64 (I ret$$5) (I 32)))))))) ret$$6))))))))) (uClip 64 (Add (uClip 64 (uintshr 64 (I ret$) (I 1))) 1))))) :pattern ((verismo!tspec.math.integer.spec_prev_power_of_two_exe.? input!))))))
(assert (forall ((input! Poly)) (! (=> (has_type input! (UINT 64)) (uInv 64 (verismo!tspec.math.integer.spec_prev_power_of_two_exe.? input!))) :pattern ((verismo!tspec.math.integer.spec_prev_power_of_two_exe.? input!)))))
(set-info :comment ";; Function-Axioms verismo::tspec::math::integer::spec_next_power_of_two_exe")
(assert (fuel_bool_default fuel%verismo!tspec.math.integer.spec_next_power_of_two_exe.))
(assert (=> (fuel_bool fuel%verismo!tspec.math.integer.spec_next_power_of_two_exe.) (forall ((input! Poly)) (! (= (verismo!tspec.math.integer.spec_next_power_of_two_exe.? input!) (ite (<= (%I input!) 1) 1 (let ((ret$ (let ((ret$$0 (%I (I (uClip 64 (Sub (%I input!) 1)))))) (let ((ret$$1 (uClip 64 (uintor 64 (I ret$$0) (I (uClip 64 (uintshr 64 (I ret$$0) (I 1)))))))) (let ((ret$$2 (uClip 64 (uintor 64 (I ret$$1) (I (uClip 64 (uintshr 64 (I ret$$1) (I 2)))))))) (let ((ret$$3 (uClip 64 (uintor 64 (I ret$$2) (I (uClip 64 (uintshr 64 (I ret$$2) (I 4)))))))) (let ((ret$$4 (uClip 64 (uintor 64 (I ret$$3) (I (uClip 64 (uintshr 64 (I ret$$3) (I 8)))))))) (let ((ret$$5 (uClip 64 (uintor 64 (I ret$$4) (I (uClip 64 (uintshr 64 (I ret$$4) (I 16)))))))) (let ((ret$$6 (uClip 64 (uintor 64 (I ret$$5) (I (uClip 64 (uintshr 64 (I ret$$5) (I 32)))))))) ret$$6))))))))) (uClip 64 (Add ret$ 1))))) :pattern ((verismo!tspec.math.integer.spec_next_power_of_two_exe.? input!))))))
(assert (forall ((input! Poly)) (! (=> (has_type input! (UINT 64)) (uInv 64 (verismo!tspec.math.integer.spec_next_power_of_two_exe.? input!))) :pattern ((verismo!tspec.math.integer.spec_next_power_of_two_exe.? input!)))))
(set-info :comment ";; Function-Specs verismo::tspec::math::integer::spec_highest_bit")
(declare-fun req%verismo!tspec.math.integer.spec_highest_bit. (Poly) Bool)
(declare-const %%global_location_label%%1 Bool)
(assert (forall ((input! Poly)) (! (= (req%verismo!tspec.math.integer.spec_highest_bit. input!) (=> %%global_location_label%%1 (not (= (%I input!) 0)))) :pattern ((req%verismo!tspec.math.integer.spec_highest_bit. input!)))))
(set-info :comment ";; Function-Axioms verismo::tspec::math::integer::spec_highest_bit")
(assert (fuel_bool_default fuel%verismo!tspec.math.integer.spec_highest_bit.))
(declare-fun %%choose%%0 (Type Poly Poly) Poly)
(assert (forall ((%%hole%%0 Type) (%%hole%%1 Poly) (%%hole%%2 Poly)) (! (=> (exists ((b$ Poly)) (! (and (has_type b$ %%hole%%0) (verismo!tspec.math.integer.is_highest_bit.? %%hole%%1 b$)) :pattern ((verismo!tspec.math.integer.is_highest_bit.? %%hole%%2 b$)))) (exists ((b$ Poly)) (! (and (and (has_type b$ %%hole%%0) (verismo!tspec.math.integer.is_highest_bit.? %%hole%%1 b$)) (= (%%choose%%0 %%hole%%0 %%hole%%1 %%hole%%2) b$)) :pattern ((verismo!tspec.math.integer.is_highest_bit.? %%hole%%2 b$))))) :pattern ((%%choose%%0 %%hole%%0 %%hole%%1 %%hole%%2)))))
(assert (=> (fuel_bool fuel%verismo!tspec.math.integer.spec_highest_bit.) (forall ((input! Poly)) (! (= (verismo!tspec.math.integer.spec_highest_bit.? input!) (%I (as_type (%%choose%%0 (UINT 64) input! input!) (UINT 64)))) :pattern ((verismo!tspec.math.integer.spec_highest_bit.? input!))))))
(assert (forall ((input! Poly)) (! (=> (has_type input! (UINT 64)) (uInv 64 (verismo!tspec.math.integer.spec_highest_bit.? input!))) :pattern ((verismo!tspec.math.integer.spec_highest_bit.? input!)))))
(set-info :comment ";; Function-Axioms verismo::tspec::math::integer::spec_prev_power_of_two")
(assert (fuel_bool_default fuel%verismo!tspec.math.integer.spec_prev_power_of_two.))
(assert (=> (fuel_bool fuel%verismo!tspec.math.integer.spec_prev_power_of_two.) (forall ((input! Poly)) (! (= (verismo!tspec.math.integer.spec_prev_power_of_two.? input!) (ite (not (= (%I input!) 0)) (let ((high_bit$ (%I (as_type (%%choose%%0 (UINT 64) input! input!) (UINT 64))))) (uClip 64 (uintshl 64 (I 1) (I (uClip 64 high_bit$))))) 0)) :pattern ((verismo!tspec.math.integer.spec_prev_power_of_two.? input!))))))
(assert (forall ((input! Poly)) (! (=> (has_type input! (UINT 64)) (uInv 64 (verismo!tspec.math.integer.spec_prev_power_of_two.? input!))) :pattern ((verismo!tspec.math.integer.spec_prev_power_of_two.? input!)))))
(set-info :comment ";; Function-Axioms verismo::tspec::math::integer::spec_next_power_of_two")
(assert (fuel_bool_default fuel%verismo!tspec.math.integer.spec_next_power_of_two.))
(assert (=> (fuel_bool fuel%verismo!tspec.math.integer.spec_next_power_of_two.) (forall ((input! Poly)) (! (= (verismo!tspec.math.integer.spec_next_power_of_two.? input!) (ite (not (= (%I input!) 0)) (let ((high_bit$ (%I (as_type (%%choose%%0 (UINT 64) input! input!) (UINT 64))))) (ite (not (= (%I input!) (uClip 64 (uintshl 64 (I 1) (I (uClip 64 high_bit$)))))) (uClip 64 (uintshl 64 (I 1) (I (uClip 64 (uClip 64 (Add high_bit$ 1)))))) (%I input!))) 1)) :pattern ((verismo!tspec.math.integer.spec_next_power_of_two.? input!))))))
(assert (forall ((input! Poly)) (! (=> (has_type input! (UINT 64)) (uInv 64 (verismo!tspec.math.integer.spec_next_power_of_two.? input!))) :pattern ((verismo!tspec.math.integer.spec_next_power_of_two.? input!)))))
(set-info :comment ";; Function-Axioms verismo::tspec::math::pow_s::spec_bit64_is_shl_by_bits")
(assert (fuel_bool_default fuel%verismo!tspec.math.pow_s.spec_bit64_is_shl_by_bits.))
(assert (=> (fuel_bool fuel%verismo!tspec.math.pow_s.spec_bit64_is_shl_by_bits.) (forall ((val! Poly)) (! (= (verismo!tspec.math.pow_s.spec_bit64_is_shl_by_bits.? val!) (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 0)))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 1))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 2))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 3))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 4))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 5))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 6))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 7))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 8))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 9))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 10))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 11))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 12))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 13))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 14))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 15))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 16))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 17))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 18))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 19))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 20))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 21))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 22))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 23))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 24))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 25))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 26))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 27))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 28))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 29))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 30))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 31))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 32))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 33))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 34))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 35))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 36))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 37))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 38))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 39))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 40))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 41))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 42))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 43))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 44))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 45))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 46))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 47))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 48))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 49))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 50))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 51))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 52))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 53))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 54))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 55))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 56))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 57))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 58))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 59))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 60))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 61))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 62))))) (= (%I val!) (uClip 64 (uintshl 64 (I 1) (I 63)))))) :pattern ((verismo!tspec.math.pow_s.spec_bit64_is_shl_by_bits.? val!))))))
(set-info :comment ";; Function-Axioms verismo::tspec::math::integer::spec_is_prev_power_of_two")
(assert (fuel_bool_default fuel%verismo!tspec.math.integer.spec_is_prev_power_of_two.))
(assert (=> (fuel_bool fuel%verismo!tspec.math.integer.spec_is_prev_power_of_two.) (forall ((input! Poly) (ret! Poly)) (! (= (verismo!tspec.math.integer.spec_is_prev_power_of_two.? input! ret!) (=> (not (= (%I input!) 0)) (and (and (< (nClip (EucDiv (%I input!) 2)) (%I ret!)) (<= (%I ret!) (%I input!))) (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 0)))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 1))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 2))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 3))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 4))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 5))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 6))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 7))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 8))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 9))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 10))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 11))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 12))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 13))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 14))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 15))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 16))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 17))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 18))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 19))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 20))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 21))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 22))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 23))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 24))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 25))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 26))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 27))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 28))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 29))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 30))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 31))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 32))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 33))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 34))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 35))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 36))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 37))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 38))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 39))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 40))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 41))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 42))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 43))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 44))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 45))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 46))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 47))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 48))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 49))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 50))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 51))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 52))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 53))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 54))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 55))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 56))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 57))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 58))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 59))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 60))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 61))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 62))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 63)))))))) :pattern ((verismo!tspec.math.integer.spec_is_prev_power_of_two.? input! ret!))))))
(set-info :comment ";; Function-Axioms verismo::tspec::math::integer::spec_is_next_power_of_two")
(assert (fuel_bool_default fuel%verismo!tspec.math.integer.spec_is_next_power_of_two.))
(assert (=> (fuel_bool fuel%verismo!tspec.math.integer.spec_is_next_power_of_two.) (forall ((input! Poly) (ret! Poly)) (! (= (verismo!tspec.math.integer.spec_is_next_power_of_two.? input! ret!) (and (and (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 0)))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 1))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 2))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 3))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 4))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 5))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 6))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 7))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 8))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 9))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 10))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 11))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 12))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 13))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 14))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 15))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 16))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 17))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 18))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 19))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 20))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 21))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 22))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 23))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 24))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 25))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 26))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 27))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 28))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 29))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 30))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 31))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 32))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 33))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 34))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 35))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 36))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 37))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 38))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 39))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 40))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 41))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 42))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 43))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 44))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 45))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 46))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 47))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 48))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 49))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 50))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 51))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 52))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 53))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 54))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 55))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 56))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 57))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 58))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 59))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 60))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 61))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 62))))) (= (%I (I (uClip 64 (%I ret!)))) (uClip 64 (uintshl 64 (I 1) (I 63))))) (= (%I ret!) (ite (<= (%I (I (uClip 64 (%I input!)))) 1) 1 (let ((ret$$0 (let ((ret$$1 (%I (I (uClip 64 (Sub (%I (I (uClip 64 (%I input!)))) 1)))))) (let ((ret$$2 (uClip 64 (uintor 64 (I ret$$1) (I (uClip 64 (uintshr 64 (I ret$$1) (I 1)))))))) (let ((ret$$3 (uClip 64 (uintor 64 (I ret$$2) (I (uClip 64 (uintshr 64 (I ret$$2) (I 2)))))))) (let ((ret$$4 (uClip 64 (uintor 64 (I ret$$3) (I (uClip 64 (uintshr 64 (I ret$$3) (I 4)))))))) (let ((ret$$5 (uClip 64 (uintor 64 (I ret$$4) (I (uClip 64 (uintshr 64 (I ret$$4) (I 8)))))))) (let ((ret$$6 (uClip 64 (uintor 64 (I ret$$5) (I (uClip 64 (uintshr 64 (I ret$$5) (I 16)))))))) (let ((ret$$7 (uClip 64 (uintor 64 (I ret$$6) (I (uClip 64 (uintshr 64 (I ret$$6) (I 32)))))))) ret$$7))))))))) (uClip 64 (Add ret$$0 1)))))) (=> (not (= (%I input!) 0)) (and (<= (%I input!) (%I ret!)) (< (%I ret!) (nClip (Mul (%I input!) 2))))))) :pattern ((verismo!tspec.math.integer.spec_is_next_power_of_two.? input! ret!))))))
(set-info :comment ";; Function-Specs verismo::tspec::math::integer::_fill_ones")
(declare-fun req%verismo!tspec.math.integer._fill_ones. (Poly Poly Poly) Bool)
(declare-const %%global_location_label%%2 Bool)
(declare-const %%global_location_label%%3 Bool)
(assert (forall ((input! Poly) (nbits! Poly) (round! Poly)) (! (= (req%verismo!tspec.math.integer._fill_ones. input! nbits! round!) (and (=> %%global_location_label%%2 (<= (%I round!) 6)) (=> %%global_location_label%%3 (= (%I nbits!) (uClip 64 (uintshl 64 (I 1) (I (uClip 64 (%I round!))))))))) :pattern ((req%verismo!tspec.math.integer._fill_ones. input! nbits! round!)))))
(set-info :comment ";; Spec-Termination verismo::tspec::math::integer::_fill_ones")
(set-info :comment ";; verismo/src/tspec/math/integer.rs:292:10: 292:66 (#0)")
(set-info :comment ";; Function-Axioms verismo::tspec::math::integer::_fill_ones")
(assert (fuel_bool_default fuel%verismo!tspec.math.integer._fill_ones.))
(declare-const fuel_nat%verismo!tspec.math.integer._fill_ones. Fuel)
(assert (forall ((input! Poly) (nbits! Poly) (round! Poly) (fuel% Fuel)) (! (= (verismo!tspec.math.integer.rec%_fill_ones.? input! nbits! round! fuel%) (verismo!tspec.math.integer.rec%_fill_ones.? input! nbits! round! zero)) :pattern ((verismo!tspec.math.integer.rec%_fill_ones.? input! nbits! round! fuel%)))))
(assert (forall ((input! Poly) (nbits! Poly) (round! Poly) (fuel% Fuel)) (! (=> (and (has_type input! (UINT 64)) (has_type nbits! (UINT 64)) (has_type round! (UINT 64))) (= (verismo!tspec.math.integer.rec%_fill_ones.? input! nbits! round! (succ fuel%)) (ite (< (%I round!) 6) (let ((t$ (uClip 64 (uintor 64 (I (%I input!)) (I (uClip 64 (uintshr 64 (I (%I input!)) (I (%I nbits!))))))))) (verismo!tspec.math.integer.rec%_fill_ones.? (I t$) (I (uClip 64 (uintshl 64 (I 1) (I (uClip 64 (uClip 64 (Add (%I round!) 1))))))) (I (uClip 64 (Add (%I round!) 1))) fuel%)) (%I input!)))) :pattern ((verismo!tspec.math.integer.rec%_fill_ones.? input! nbits! round! (succ fuel%))))))
(assert (=> (fuel_bool fuel%verismo!tspec.math.integer._fill_ones.) (forall ((input! Poly) (nbits! Poly) (round! Poly)) (! (=> (and (has_type input! (UINT 64)) (has_type nbits! (UINT 64)) (has_type round! (UINT 64))) (= (verismo!tspec.math.integer._fill_ones.? input! nbits! round!) (verismo!tspec.math.integer.rec%_fill_ones.? input! nbits! round! (succ fuel_nat%verismo!tspec.math.integer._fill_ones.)))) :pattern ((verismo!tspec.math.integer._fill_ones.? input! nbits! round!))))))
(assert (forall ((input! Poly) (nbits! Poly) (round! Poly)) (! (=> (and (has_type input! (UINT 64)) (has_type nbits! (UINT 64)) (has_type round! (UINT 64))) (uInv 64 (verismo!tspec.math.integer._fill_ones.? input! nbits! round!))) :pattern ((verismo!tspec.math.integer._fill_ones.? input! nbits! round!)))))
(set-info :comment ";; Function-Axioms verismo::tspec::math::integer::fill_ones")
(assert (fuel_bool_default fuel%verismo!tspec.math.integer.fill_ones.))
(assert (=> (fuel_bool fuel%verismo!tspec.math.integer.fill_ones.) (forall ((input! Poly)) (! (= (verismo!tspec.math.integer.fill_ones.? input!) (verismo!tspec.math.integer._fill_ones.? input! (I 1) (I 0))) :pattern ((verismo!tspec.math.integer.fill_ones.? input!))))))
(assert (forall ((input! Poly)) (! (=> (has_type input! (UINT 64)) (uInv 64 (verismo!tspec.math.integer.fill_ones.? input!))) :pattern ((verismo!tspec.math.integer.fill_ones.? input!)))))
(set-info :comment ";; Function-Specs verismo::tspec::math::bits_p::bit64_shl_auto")
(declare-fun ens%verismo!tspec.math.bits_p.bit64_shl_auto. (Int) Bool)
(assert (forall ((no%param Int)) (! (= (ens%verismo!tspec.math.bits_p.bit64_shl_auto. no%param) (and (forall ((a$ Poly)) (! (=> (has_type a$ (UINT 64)) (= (uClip 64 (uintshl 64 (I (%I a$)) (I 0))) (%I a$))) :pattern ((uClip 64 (uintshl 64 (I (%I a$)) (I 0)))))) (forall ((a$ Poly)) (! (=> (has_type a$ (UINT 64)) (=> (< (%I a$) 64) (> (uClip 64 (uintshl 64 (I 1) (I (%I a$)))) 0))) :pattern ((uClip 64 (uintshl 64 (I 1) (I (%I a$))))))) (forall ((a$ Poly) (b$ Poly)) (! (=> (and (has_type a$ (UINT 64)) (has_type b$ (UINT 64))) (=> (< (%I b$) 64) (or (= (uClip 64 (uintand 64 (I (%I a$)) (I (uClip 64 (uintshl 64 (I 1) (I (%I b$))))))) (uClip 64 (uintshl 64 (I 1) (I (%I b$))))) (= (uClip 64 (uintand 64 (I (%I a$)) (I (uClip 64 (uintshl 64 (I 1) (I (%I b$))))))) 0)))) :pattern ((uClip 64 (uintand 64 (I (%I a$)) (I (uClip 64 (uintshl 64 (I 1) (I (%I b$)))))))))) (=> (< 0 64) (= (uClip 64 (uintshl 64 (I 1) (I 0))) 1)) (=> (< 1 64) (= (uClip 64 (uintshl 64 (I 1) (I 1))) 2)) (=> (< 2 64) (= (uClip 64 (uintshl 64 (I 1) (I 2))) 4)) (=> (< 3 64) (= (uClip 64 (uintshl 64 (I 1) (I 3))) 8)) (=> (< 4 64) (= (uClip 64 (uintshl 64 (I 1) (I 4))) 16)) (=> (< 5 64) (= (uClip 64 (uintshl 64 (I 1) (I 5))) 32)) (=> (< 6 64) (= (uClip 64 (uintshl 64 (I 1) (I 6))) 64)) (=> (< 7 64) (= (uClip 64 (uintshl 64 (I 1) (I 7))) 128)) (=> (< 8 64) (= (uClip 64 (uintshl 64 (I 1) (I 8))) 256)) (=> (< 9 64) (= (uClip 64 (uintshl 64 (I 1) (I 9))) 512)) (=> (< 10 64) (= (uClip 64 (uintshl 64 (I 1) (I 10))) 1024)) (=> (< 11 64) (= (uClip 64 (uintshl 64 (I 1) (I 11))) 2048)) (=> (< 12 64) (= (uClip 64 (uintshl 64 (I 1) (I 12))) 4096)) (=> (< 13 64) (= (uClip 64 (uintshl 64 (I 1) (I 13))) 8192)) (=> (< 14 64) (= (uClip 64 (uintshl 64 (I 1) (I 14))) 16384)) (=> (< 15 64) (= (uClip 64 (uintshl 64 (I 1) (I 15))) 32768)) (=> (< 16 64) (= (uClip 64 (uintshl 64 (I 1) (I 16))) 65536)) (=> (< 17 64) (= (uClip 64 (uintshl 64 (I 1) (I 17))) 131072)) (=> (< 18 64) (= (uClip 64 (uintshl 64 (I 1) (I 18))) 262144)) (=> (< 19 64) (= (uClip 64 (uintshl 64 (I 1) (I 19))) 524288)) (=> (< 20 64) (= (uClip 64 (uintshl 64 (I 1) (I 20))) 1048576)) (=> (< 21 64) (= (uClip 64 (uintshl 64 (I 1) (I 21))) 2097152)) (=> (< 22 64) (= (uClip 64 (uintshl 64 (I 1) (I 22))) 4194304)) (=> (< 23 64) (= (uClip 64 (uintshl 64 (I 1) (I 23))) 8388608)) (=> (< 24 64) (= (uClip 64 (uintshl 64 (I 1) (I 24))) 16777216)) (=> (< 25 64) (= (uClip 64 (uintshl 64 (I 1) (I 25))) 33554432)) (=> (< 26 64) (= (uClip 64 (uintshl 64 (I 1) (I 26))) 67108864)) (=> (< 27 64) (= (uClip 64 (uintshl 64 (I 1) (I 27))) 134217728)) (=> (< 28 64) (= (uClip 64 (uintshl 64 (I 1) (I 28))) 268435456)) (=> (< 29 64) (= (uClip 64 (uintshl 64 (I 1) (I 29))) 536870912)) (=> (< 30 64) (= (uClip 64 (uintshl 64 (I 1) (I 30))) 1073741824)) (=> (< 31 64) (= (uClip 64 (uintshl 64 (I 1) (I 31))) 2147483648)) (=> (< 32 64) (= (uClip 64 (uintshl 64 (I 1) (I 32))) 4294967296)) (=> (< 33 64) (= (uClip 64 (uintshl 64 (I 1) (I 33))) 8589934592)) (=> (< 34 64) (= (uClip 64 (uintshl 64 (I 1) (I 34))) 17179869184)) (=> (< 35 64) (= (uClip 64 (uintshl 64 (I 1) (I 35))) 34359738368)) (=> (< 36 64) (= (uClip 64 (uintshl 64 (I 1) (I 36))) 68719476736)) (=> (< 37 64) (= (uClip 64 (uintshl 64 (I 1) (I 37))) 137438953472)) (=> (< 38 64) (= (uClip 64 (uintshl 64 (I 1) (I 38))) 274877906944)) (=> (< 39 64) (= (uClip 64 (uintshl 64 (I 1) (I 39))) 549755813888)) (=> (< 40 64) (= (uClip 64 (uintshl 64 (I 1) (I 40))) 1099511627776)) (=> (< 41 64) (= (uClip 64 (uintshl 64 (I 1) (I 41))) 2199023255552)) (=> (< 42 64) (= (uClip 64 (uintshl 64 (I 1) (I 42))) 4398046511104)) (=> (< 43 64) (= (uClip 64 (uintshl 64 (I 1) (I 43))) 8796093022208)) (=> (< 44 64) (= (uClip 64 (uintshl 64 (I 1) (I 44))) 17592186044416)) (=> (< 45 64) (= (uClip 64 (uintshl 64 (I 1) (I 45))) 35184372088832)) (=> (< 46 64) (= (uClip 64 (uintshl 64 (I 1) (I 46))) 70368744177664)) (=> (< 47 64) (= (uClip 64 (uintshl 64 (I 1) (I 47))) 140737488355328)) (=> (< 48 64) (= (uClip 64 (uintshl 64 (I 1) (I 48))) 281474976710656)) (=> (< 49 64) (= (uClip 64 (uintshl 64 (I 1) (I 49))) 562949953421312)) (=> (< 50 64) (= (uClip 64 (uintshl 64 (I 1) (I 50))) 1125899906842624)) (=> (< 51 64) (= (uClip 64 (uintshl 64 (I 1) (I 51))) 2251799813685248)) (=> (< 52 64) (= (uClip 64 (uintshl 64 (I 1) (I 52))) 4503599627370496)) (=> (< 53 64) (= (uClip 64 (uintshl 64 (I 1) (I 53))) 9007199254740992)) (=> (< 54 64) (= (uClip 64 (uintshl 64 (I 1) (I 54))) 18014398509481984)) (=> (< 55 64) (= (uClip 64 (uintshl 64 (I 1) (I 55))) 36028797018963968)) (=> (< 56 64) (= (uClip 64 (uintshl 64 (I 1) (I 56))) 72057594037927936)) (=> (< 57 64) (= (uClip 64 (uintshl 64 (I 1) (I 57))) 144115188075855872)) (=> (< 58 64) (= (uClip 64 (uintshl 64 (I 1) (I 58))) 288230376151711744)) (=> (< 59 64) (= (uClip 64 (uintshl 64 (I 1) (I 59))) 576460752303423488)) (=> (< 60 64) (= (uClip 64 (uintshl 64 (I 1) (I 60))) 1152921504606846976)) (=> (< 61 64) (= (uClip 64 (uintshl 64 (I 1) (I 61))) 2305843009213693952)) (=> (< 62 64) (= (uClip 64 (uintshl 64 (I 1) (I 62))) 4611686018427387904)) (=> (< 63 64) (= (uClip 64 (uintshl 64 (I 1) (I 63))) 9223372036854775808)))) :pattern ((ens%verismo!tspec.math.bits_p.bit64_shl_auto. no%param)))))
(set-info :comment ";; Function-Specs verismo::tspec::math::bits_p::bit64_shl_values_auto")
(declare-fun ens%verismo!tspec.math.bits_p.bit64_shl_values_auto. (Int) Bool)
(assert (forall ((no%param Int)) (! (= (ens%verismo!tspec.math.bits_p.bit64_shl_values_auto. no%param) (and (=> (< 0 64) (= (uClip 64 (uintshl 64 (I 1) (I 0))) 1)) (=> (< 1 64) (= (uClip 64 (uintshl 64 (I 1) (I 1))) 2)) (=> (< 2 64) (= (uClip 64 (uintshl 64 (I 1) (I 2))) 4)) (=> (< 3 64) (= (uClip 64 (uintshl 64 (I 1) (I 3))) 8)) (=> (< 4 64) (= (uClip 64 (uintshl 64 (I 1) (I 4))) 16)) (=> (< 5 64) (= (uClip 64 (uintshl 64 (I 1) (I 5))) 32)) (=> (< 6 64) (= (uClip 64 (uintshl 64 (I 1) (I 6))) 64)) (=> (< 7 64) (= (uClip 64 (uintshl 64 (I 1) (I 7))) 128)) (=> (< 8 64) (= (uClip 64 (uintshl 64 (I 1) (I 8))) 256)) (=> (< 9 64) (= (uClip 64 (uintshl 64 (I 1) (I 9))) 512)) (=> (< 10 64) (= (uClip 64 (uintshl 64 (I 1) (I 10))) 1024)) (=> (< 11 64) (= (uClip 64 (uintshl 64 (I 1) (I 11))) 2048)) (=> (< 12 64) (= (uClip 64 (uintshl 64 (I 1) (I 12))) 4096)) (=> (< 13 64) (= (uClip 64 (uintshl 64 (I 1) (I 13))) 8192)) (=> (< 14 64) (= (uClip 64 (uintshl 64 (I 1) (I 14))) 16384)) (=> (< 15 64) (= (uClip 64 (uintshl 64 (I 1) (I 15))) 32768)) (=> (< 16 64) (= (uClip 64 (uintshl 64 (I 1) (I 16))) 65536)) (=> (< 17 64) (= (uClip 64 (uintshl 64 (I 1) (I 17))) 131072)) (=> (< 18 64) (= (uClip 64 (uintshl 64 (I 1) (I 18))) 262144)) (=> (< 19 64) (= (uClip 64 (uintshl 64 (I 1) (I 19))) 524288)) (=> (< 20 64) (= (uClip 64 (uintshl 64 (I 1) (I 20))) 1048576)) (=> (< 21 64) (= (uClip 64 (uintshl 64 (I 1) (I 21))) 2097152)) (=> (< 22 64) (= (uClip 64 (uintshl 64 (I 1) (I 22))) 4194304)) (=> (< 23 64) (= (uClip 64 (uintshl 64 (I 1) (I 23))) 8388608)) (=> (< 24 64) (= (uClip 64 (uintshl 64 (I 1) (I 24))) 16777216)) (=> (< 25 64) (= (uClip 64 (uintshl 64 (I 1) (I 25))) 33554432)) (=> (< 26 64) (= (uClip 64 (uintshl 64 (I 1) (I 26))) 67108864)) (=> (< 27 64) (= (uClip 64 (uintshl 64 (I 1) (I 27))) 134217728)) (=> (< 28 64) (= (uClip 64 (uintshl 64 (I 1) (I 28))) 268435456)) (=> (< 29 64) (= (uClip 64 (uintshl 64 (I 1) (I 29))) 536870912)) (=> (< 30 64) (= (uClip 64 (uintshl 64 (I 1) (I 30))) 1073741824)) (=> (< 31 64) (= (uClip 64 (uintshl 64 (I 1) (I 31))) 2147483648)) (=> (< 32 64) (= (uClip 64 (uintshl 64 (I 1) (I 32))) 4294967296)) (=> (< 33 64) (= (uClip 64 (uintshl 64 (I 1) (I 33))) 8589934592)) (=> (< 34 64) (= (uClip 64 (uintshl 64 (I 1) (I 34))) 17179869184)) (=> (< 35 64) (= (uClip 64 (uintshl 64 (I 1) (I 35))) 34359738368)) (=> (< 36 64) (= (uClip 64 (uintshl 64 (I 1) (I 36))) 68719476736)) (=> (< 37 64) (= (uClip 64 (uintshl 64 (I 1) (I 37))) 137438953472)) (=> (< 38 64) (= (uClip 64 (uintshl 64 (I 1) (I 38))) 274877906944)) (=> (< 39 64) (= (uClip 64 (uintshl 64 (I 1) (I 39))) 549755813888)) (=> (< 40 64) (= (uClip 64 (uintshl 64 (I 1) (I 40))) 1099511627776)) (=> (< 41 64) (= (uClip 64 (uintshl 64 (I 1) (I 41))) 2199023255552)) (=> (< 42 64) (= (uClip 64 (uintshl 64 (I 1) (I 42))) 4398046511104)) (=> (< 43 64) (= (uClip 64 (uintshl 64 (I 1) (I 43))) 8796093022208)) (=> (< 44 64) (= (uClip 64 (uintshl 64 (I 1) (I 44))) 17592186044416)) (=> (< 45 64) (= (uClip 64 (uintshl 64 (I 1) (I 45))) 35184372088832)) (=> (< 46 64) (= (uClip 64 (uintshl 64 (I 1) (I 46))) 70368744177664)) (=> (< 47 64) (= (uClip 64 (uintshl 64 (I 1) (I 47))) 140737488355328)) (=> (< 48 64) (= (uClip 64 (uintshl 64 (I 1) (I 48))) 281474976710656)) (=> (< 49 64) (= (uClip 64 (uintshl 64 (I 1) (I 49))) 562949953421312)) (=> (< 50 64) (= (uClip 64 (uintshl 64 (I 1) (I 50))) 1125899906842624)) (=> (< 51 64) (= (uClip 64 (uintshl 64 (I 1) (I 51))) 2251799813685248)) (=> (< 52 64) (= (uClip 64 (uintshl 64 (I 1) (I 52))) 4503599627370496)) (=> (< 53 64) (= (uClip 64 (uintshl 64 (I 1) (I 53))) 9007199254740992)) (=> (< 54 64) (= (uClip 64 (uintshl 64 (I 1) (I 54))) 18014398509481984)) (=> (< 55 64) (= (uClip 64 (uintshl 64 (I 1) (I 55))) 36028797018963968)) (=> (< 56 64) (= (uClip 64 (uintshl 64 (I 1) (I 56))) 72057594037927936)) (=> (< 57 64) (= (uClip 64 (uintshl 64 (I 1) (I 57))) 144115188075855872)) (=> (< 58 64) (= (uClip 64 (uintshl 64 (I 1) (I 58))) 288230376151711744)) (=> (< 59 64) (= (uClip 64 (uintshl 64 (I 1) (I 59))) 576460752303423488)) (=> (< 60 64) (= (uClip 64 (uintshl 64 (I 1) (I 60))) 1152921504606846976)) (=> (< 61 64) (= (uClip 64 (uintshl 64 (I 1) (I 61))) 2305843009213693952)) (=> (< 62 64) (= (uClip 64 (uintshl 64 (I 1) (I 62))) 4611686018427387904)) (=> (< 63 64) (= (uClip 64 (uintshl 64 (I 1) (I 63))) 9223372036854775808)))) :pattern ((ens%verismo!tspec.math.bits_p.bit64_shl_values_auto. no%param)))))
(set-info :comment ";; Function-Specs verismo::tspec::math::bits_p::bit64_and_auto")
(declare-fun ens%verismo!tspec.math.bits_p.bit64_and_auto. (Int) Bool)
(assert (forall ((no%param Int)) (! (= (ens%verismo!tspec.math.bits_p.bit64_and_auto. no%param) (and (forall ((a$ Poly) (b$ Poly)) (! (=> (and (has_type a$ (UINT 64)) (has_type b$ (UINT 64))) (= (uClip 64 (uintand 64 (I (%I a$)) (I (%I b$)))) (uClip 64 (uintand 64 (I (%I b$)) (I (%I a$)))))) :pattern ((uClip 64 (uintand 64 (I (%I a$)) (I (%I b$))))))) (forall ((a$ Poly) (b$ Poly) (c$ Poly)) (! (=> (and (has_type a$ (UINT 64)) (has_type b$ (UINT 64)) (has_type c$ (UINT 64))) (= (uClip 64 (uintand 64 (I (uClip 64 (uintand 64 (I (%I a$)) (I (%I b$))))) (I (%I c$)))) (uClip 64 (uintand 64 (I (%I a$)) (I (uClip 64 (uintand 64 (I (%I b$)) (I (%I c$))))))))) :pattern ((uClip 64 (uintand 64 (I (uClip 64 (uintand 64 (I (%I a$)) (I (%I b$))))) (I (%I c$))))))) (forall ((a$ Poly)) (! (=> (has_type a$ (UINT 64)) (= (uClip 64 (uintand 64 (I (%I a$)) (I (%I a$)))) (%I a$))) :pattern ((uClip 64 (uintand 64 (I (%I a$)) (I (%I a$))))))) (forall ((a$ Poly)) (! (=> (has_type a$ (UINT 64)) (= (uClip 64 (uintand 64 (I (%I a$)) (I 0))) 0)) :pattern ((uClip 64 (uintand 64 (I (%I a$)) (I 0)))))) (forall ((a$ Poly)) (! (=> (has_type a$ (UINT 64)) (= (uClip 64 (uintand 64 (I (%I a$)) (I 18446744073709551615))) (%I a$))) :pattern ((uClip 64 (uintand 64 (I (%I a$)) (I 18446744073709551615)))))) (forall ((a$ Poly) (b$ Poly)) (! (=> (and (has_type a$ (UINT 64)) (has_type b$ (UINT 64))) (and (<= (uClip 64 (uintand 64 (I (%I a$)) (I (%I b$)))) (%I b$)) (<= (uClip 64 (uintand 64 (I (%I a$)) (I (%I b$)))) (%I a$)))) :pattern ((uClip 64 (uintand 64 (I (%I a$)) (I (%I b$))))))) (forall ((a$ Poly) (b$ Poly)) (! (=> (and (has_type a$ (UINT 32)) (has_type b$ (UINT 32))) (<= (uClip 32 (uintand 32 (I (%I a$)) (I (%I b$)))) (%I b$))) :pattern ((uClip 32 (uintand 32 (I (%I a$)) (I (%I b$))))))) (forall ((a$ Poly) (b$ Poly)) (! (=> (and (has_type a$ (UINT 16)) (has_type b$ (UINT 16))) (<= (uClip 16 (uintand 16 (I (%I a$)) (I (%I b$)))) (%I b$))) :pattern ((uClip 16 (uintand 16 (I (%I a$)) (I (%I b$))))))) (forall ((a$ Poly) (b$ Poly)) (! (=> (and (has_type a$ (UINT 8)) (has_type b$ (UINT 8))) (<= (uClip 8 (uintand 8 (I (%I a$)) (I (%I b$)))) (%I b$))) :pattern ((uClip 8 (uintand 8 (I (%I a$)) (I (%I b$))))))))) :pattern ((ens%verismo!tspec.math.bits_p.bit64_and_auto. no%param)))))
(set-info :comment ";; Function-Specs verismo::tspec::math::bits_p::bit64_or_auto")
(declare-fun ens%verismo!tspec.math.bits_p.bit64_or_auto. (Int) Bool)
(assert (forall ((no%param Int)) (! (= (ens%verismo!tspec.math.bits_p.bit64_or_auto. no%param) (and (forall ((a$ Poly) (b$ Poly)) (! (=> (and (has_type a$ (UINT 64)) (has_type b$ (UINT 64))) (and (and (and (and (and (and (= (%I (I (uClip 64 (uintor 64 (I (%I a$)) (I (%I b$)))))) (uClip 64 (uintor 64 (I (%I a$)) (I (%I b$))))) (= (%I (I (uClip 64 (uintor 64 (I (%I a$)) (I (%I b$)))))) (uClip 64 (uintor 64 (I (%I b$)) (I (%I a$)))))) (and (<= 0 (%I (I (uClip 64 (uintor 64 (I (%I a$)) (I (%I b$))))))) (<= (%I (I (uClip 64 (uintor 64 (I (%I a$)) (I (%I b$)))))) 18446744073709551615))) (= (uClip 64 (uintand 64 (I (%I (I (uClip 64 (uintor 64 (I (%I a$)) (I (%I b$))))))) (I (%I b$)))) (%I b$))) (>= (%I (I (uClip 64 (uintor 64 (I (%I a$)) (I (%I b$)))))) (%I a$))) (>= (%I (I (uClip 64 (uintor 64 (I (%I a$)) (I (%I b$)))))) (%I b$))) (= (uClip 64 (uintand 64 (I (%I (I (uClip 64 (uintor 64 (I (%I a$)) (I (%I b$))))))) (I (uClip 64 (uintnot 64 (I (%I b$))))))) (uClip 64 (uintand 64 (I (%I a$)) (I (uClip 64 (uintnot 64 (I (%I b$)))))))))) :pattern ((uClip 64 (uintor 64 (I (%I a$)) (I (%I b$))))))) (forall ((a$ Poly)) (! (=> (has_type a$ (UINT 64)) (= (uClip 64 (uintor 64 (I (%I a$)) (I (%I a$)))) (%I a$))) :pattern ((uClip 64 (uintor 64 (I (%I a$)) (I (%I a$))))))) (forall ((a$ Poly)) (! (=> (has_type a$ (UINT 64)) (= (uClip 64 (uintor 64 (I (%I a$)) (I 0))) (%I a$))) :pattern ((uClip 64 (uintor 64 (I (%I a$)) (I 0)))))) (forall ((a$ Poly)) (! (=> (has_type a$ (UINT 64)) (= (uClip 64 (uintor 64 (I (%I a$)) (I 18446744073709551615))) 18446744073709551615)) :pattern ((uClip 64 (uintor 64 (I (%I a$)) (I 18446744073709551615)))))))) :pattern ((ens%verismo!tspec.math.bits_p.bit64_or_auto. no%param)))))
(set-info :comment ";; Function-Specs verismo::tspec::math::bits_p::proof_bit64_has_bit_property")
(declare-fun req%verismo!tspec.math.bits_p.proof_bit64_has_bit_property. (Int Int Int) Bool)
(declare-const %%global_location_label%%4 Bool)
(assert (forall ((val! Int) (x! Int) (bit! Int)) (! (= (req%verismo!tspec.math.bits_p.proof_bit64_has_bit_property. val! x! bit!) (=> %%global_location_label%%4 (< bit! 64))) :pattern ((req%verismo!tspec.math.bits_p.proof_bit64_has_bit_property. val! x! bit!)))))
(declare-fun ens%verismo!tspec.math.bits_p.proof_bit64_has_bit_property. (Int Int Int) Bool)
(assert (forall ((val! Int) (x! Int) (bit! Int)) (! (= (ens%verismo!tspec.math.bits_p.proof_bit64_has_bit_property. val! x! bit!) (and (=> (= (uClip 64 (uintshl 64 (I 1) (I (%I (I bit!))))) (uClip 64 (uintand 64 (I (%I (I val!))) (I (uClip 64 (uintshl 64 (I 1) (I (%I (I bit!))))))))) (= (uClip 64 (uintshl 64 (I 1) (I (%I (I bit!))))) (uClip 64 (uintand 64 (I (%I (I (uClip 64 (uintor 64 (I val!) (I x!)))))) (I (uClip 64 (uintshl 64 (I 1) (I (%I (I bit!)))))))))) (=> (not (= (uClip 64 (uintshl 64 (I 1) (I (%I (I bit!))))) (uClip 64 (uintand 64 (I (%I (I val!))) (I (uClip 64 (uintshl 64 (I 1) (I (%I (I bit!)))))))))) (not (= (uClip 64 (uintshl 64 (I 1) (I (%I (I bit!))))) (uClip 64 (uintand 64 (I (%I (I (uClip 64 (uintand 64 (I val!) (I x!)))))) (I (uClip 64 (uintshl 64 (I 1) (I (%I (I bit!))))))))))))) :pattern ((ens%verismo!tspec.math.bits_p.proof_bit64_has_bit_property. val! x! bit!)))))
(set-info :comment ";; Function-Specs verismo::tspec::math::cond_bound::proof_has_conditional_upper_bound")
(declare-fun ens%verismo!tspec.math.cond_bound.proof_has_conditional_upper_bound. (%%Function%% Int) Bool)
(assert (forall ((cond_fn! %%Function%%) (max! Int)) (! (= (ens%verismo!tspec.math.cond_bound.proof_has_conditional_upper_bound. cond_fn! max!) (=> (exists ((val$ Poly)) (! (and (has_type val$ (UINT 64)) (and (%B (%%apply%%0 cond_fn! val$)) (<= (%I val$) max!))) :pattern ((%%apply%%0 cond_fn! val$)))) (exists ((val$ Poly)) (! (and (has_type val$ (UINT 64)) (verismo!tspec.math.cond_bound.is_upper_bound_satisfy_cond.? (Poly%fun%1. cond_fn!) val$ (I max!))) :pattern ((verismo!tspec.math.cond_bound.is_upper_bound_satisfy_cond.? (Poly%fun%1. cond_fn!) val$ (I max!))))))) :pattern ((ens%verismo!tspec.math.cond_bound.proof_has_conditional_upper_bound. cond_fn! max!)))))
(set-info :comment ";; Function-Specs verismo::tspec::math::integer::lemma_zeroval_bits")
(declare-fun req%verismo!tspec.math.integer.lemma_zeroval_bits. (Int) Bool)
(declare-const %%global_location_label%%5 Bool)
(assert (forall ((input! Int)) (! (= (req%verismo!tspec.math.integer.lemma_zeroval_bits. input!) (=> %%global_location_label%%5 (forall ((b$ Poly)) (! (=> (has_type b$ (UINT 64)) (=> (and (<= 0 (%I b$)) (< (%I b$) 64)) (not (= (uClip 64 (uintshl 64 (I 1) (I (%I b$)))) (uClip 64 (uintand 64 (I (%I (I input!))) (I (uClip 64 (uintshl 64 (I 1) (I (%I b$))))))))))) :pattern ((uClip 64 (uintshl 64 (I 1) (I (%I b$))))))))) :pattern ((req%verismo!tspec.math.integer.lemma_zeroval_bits. input!)))))
(declare-fun ens%verismo!tspec.math.integer.lemma_zeroval_bits. (Int) Bool)
(assert (forall ((input! Int)) (! (= (ens%verismo!tspec.math.integer.lemma_zeroval_bits. input!) (= input! 0)) :pattern ((ens%verismo!tspec.math.integer.lemma_zeroval_bits. input!)))))
(set-info :comment ";; Function-Def verismo::tspec::math::integer::lemma_zeroval_bits")
(set-info :comment ";; verismo/src/tspec/math/integer.rs:33:11: 33:44 (#0)")
(set-info :comment ";; Function-Specs verismo::tspec::math::integer::lemma_has_64bits_until_to_mask")
(declare-fun req%verismo!tspec.math.integer.lemma_has_64bits_until_to_mask. (Int Int) Bool)
(declare-const %%global_location_label%%6 Bool)
(declare-const %%global_location_label%%7 Bool)
(assert (forall ((val! Int) (h! Int)) (! (= (req%verismo!tspec.math.integer.lemma_has_64bits_until_to_mask. val! h!) (and (=> %%global_location_label%%6 (< h! 64)) (=> %%global_location_label%%7 (and (forall ((b$$0 Poly)) (! (=> (has_type b$$0 (UINT 64)) (=> (and (<= (%I b$$0) (%I (I h!))) (< (uClip 64 (Sub (%I (I h!)) (%I b$$0))) (%I (I 64)))) (= (uClip 64 (uintshl 64 (I 1) (I (%I b$$0)))) (uClip 64 (uintand 64 (I (%I (I val!))) (I (uClip 64 (uintshl 64 (I 1) (I (%I b$$0)))))))))) :pattern ((uClip 64 (uintshl 64 (I 1) (I (%I b$$0))))))) (forall ((b$$0 Poly)) (! (=> (has_type b$$0 (UINT 64)) (=> (and (< (%I (I h!)) (%I b$$0)) (< (%I b$$0) 64)) (not (= (uClip 64 (uintshl 64 (I 1) (I (%I b$$0)))) (uClip 64 (uintand 64 (I (%I (I val!))) (I (uClip 64 (uintshl 64 (I 1) (I (%I b$$0))))))))))) :pattern ((uClip 64 (uintshl 64 (I 1) (I (%I b$$0))))))))))) :pattern ((req%verismo!tspec.math.integer.lemma_has_64bits_until_to_mask. val! h!)))))
(declare-fun ens%verismo!tspec.math.integer.lemma_has_64bits_until_to_mask. (Int Int) Bool)
(assert (forall ((val! Int) (h! Int)) (! (= (ens%verismo!tspec.math.integer.lemma_has_64bits_until_to_mask. val! h!) (= val! (uClip 64 (uintor 64 (I (uClip 64 (uintshl 64 (I (uClip 64 (Sub (uClip 64 (uintshl 64 (I 1) (I (uClip 64 (uClip 64 (Sub (%I (I (uClip 64 (Add h! 1)))) 1)))))) 1))) (I 1)))) (I 1))))) :pattern ((ens%verismo!tspec.math.integer.lemma_has_64bits_until_to_mask. val! h!)))))
(set-info :comment ";; Function-Def verismo::tspec::math::integer::lemma_has_64bits_until_to_mask")
(set-info :comment ";; verismo/src/tspec/math/integer.rs:47:11: 47:62 (#0)")
(set-info :comment ";; Function-Specs verismo::tspec::math::integer::proof_get_highest_bit")
(declare-fun req%verismo!tspec.math.integer.proof_get_highest_bit. (Int) Bool)
(declare-const %%global_location_label%%8 Bool)
(assert (forall ((input! Int)) (! (= (req%verismo!tspec.math.integer.proof_get_highest_bit. input!) (=> %%global_location_label%%8 (not (= input! 0)))) :pattern ((req%verismo!tspec.math.integer.proof_get_highest_bit. input!)))))
(declare-fun ens%verismo!tspec.math.integer.proof_get_highest_bit. (Int Int) Bool)
(assert (forall ((input! Int) (ret! Int)) (! (= (ens%verismo!tspec.math.integer.proof_get_highest_bit. input! ret!) (and (uInv 64 ret!) (verismo!tspec.math.integer.is_highest_bit.? (I input!) (I ret!)) (= ret! (%I (as_type (%%choose%%0 (UINT 64) (I input!) (I input!)) (UINT 64)))) (and (<= 0 ret!) (< ret! 64)))) :pattern ((ens%verismo!tspec.math.integer.proof_get_highest_bit. input! ret!)))))
(set-info :comment ";; Function-Def verismo::tspec::math::integer::proof_get_highest_bit")
(set-info :comment ";; verismo/src/tspec/math/integer.rs:110:5: 110:64 (#0)")
(set-info :comment ";; Function-Specs verismo::tspec::math::integer::lemma_fill_ones_bit_step")
(declare-fun req%verismo!tspec.math.integer.lemma_fill_ones_bit_step. (Int Int Int Int) Bool)
(declare-const %%global_location_label%%9 Bool)
(declare-const %%global_location_label%%10 Bool)
(declare-const %%global_location_label%%11 Bool)
(declare-const %%global_location_label%%12 Bool)
(assert (forall ((input! Int) (nbits! Int) (h! Int) (round! Int)) (! (= (req%verismo!tspec.math.integer.lemma_fill_ones_bit_step. input! nbits! h! round!) (and (=> %%global_location_label%%9 (= nbits! (uClip 64 (uintshl 64 (I 1) (I (uClip 64 round!)))))) (=> %%global_location_label%%10 (< round! 6)) (=> %%global_location_label%%11 (< h! 64)) (=> %%global_location_label%%12 (and (forall ((b$$0 Poly)) (! (=> (has_type b$$0 (UINT 64)) (=> (and (<= (%I b$$0) (%I (I h!))) (< (uClip 64 (Sub (%I (I h!)) (%I b$$0))) (%I (I nbits!)))) (= (uClip 64 (uintshl 64 (I 1) (I (%I b$$0)))) (uClip 64 (uintand 64 (I (%I (I input!))) (I (uClip 64 (uintshl 64 (I 1) (I (%I b$$0)))))))))) :pattern ((uClip 64 (uintshl 64 (I 1) (I (%I b$$0))))))) (forall ((b$$0 Poly)) (! (=> (has_type b$$0 (UINT 64)) (=> (and (< (%I (I h!)) (%I b$$0)) (< (%I b$$0) 64)) (not (= (uClip 64 (uintshl 64 (I 1) (I (%I b$$0)))) (uClip 64 (uintand 64 (I (%I (I input!))) (I (uClip 64 (uintshl 64 (I 1) (I (%I b$$0))))))))))) :pattern ((uClip 64 (uintshl 64 (I 1) (I (%I b$$0))))))))))) :pattern ((req%verismo!tspec.math.integer.lemma_fill_ones_bit_step. input! nbits! h! round!)))))
(declare-fun ens%verismo!tspec.math.integer.lemma_fill_ones_bit_step. (Int Int Int Int tuple%2.) Bool)
(assert (forall ((input! Int) (nbits! Int) (h! Int) (round! Int) (ret! tuple%2.)) (! (= (ens%verismo!tspec.math.integer.lemma_fill_ones_bit_step. input! nbits! h! round! ret!) (and (has_type (Poly%tuple%2. ret!) (TYPE%tuple%2. $ (UINT 64) $ (UINT 64))) (= (%I (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. ret!)))) (uClip 64 (uintor 64 (I input!) (I (uClip 64 (uintshr 64 (I input!) (I nbits!))))))) (= (%I (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. ret!)))) (uClip 64 (uintshl 64 (I 1) (I (uClip 64 (uClip 64 (Add round! 1))))))) (and (forall ((b$$0 Poly)) (! (=> (has_type b$$0 (UINT 64)) (=> (and (<= (%I b$$0) (%I (I h!))) (< (uClip 64 (Sub (%I (I h!)) (%I b$$0))) (%I (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. ret!)))))) (= (uClip 64 (uintshl 64 (I 1) (I (%I b$$0)))) (uClip 64 (uintand 64 (I (%I (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. ret!))))) (I (uClip 64 (uintshl 64 (I 1) (I (%I b$$0)))))))))) :pattern ((uClip 64 (uintshl 64 (I 1) (I (%I b$$0))))))) (forall ((b$$0 Poly)) (! (=> (has_type b$$0 (UINT 64)) (=> (and (< (%I (I h!)) (%I b$$0)) (< (%I b$$0) 64)) (not (= (uClip 64 (uintshl 64 (I 1) (I (%I b$$0)))) (uClip 64 (uintand 64 (I (%I (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. ret!))))) (I (uClip 64 (uintshl 64 (I 1) (I (%I b$$0))))))))))) :pattern ((uClip 64 (uintshl 64 (I 1) (I (%I b$$0)))))))))) :pattern ((ens%verismo!tspec.math.integer.lemma_fill_ones_bit_step. input! nbits! h! round! ret!)))))
(set-info :comment ";; Function-Def verismo::tspec::math::integer::lemma_fill_ones_bit_step")
(set-info :comment ";; verismo/src/tspec/math/integer.rs:311:11: 311:102 (#0)")
(declare-const ret! tuple%2.)
(declare-const input! Int)
(declare-const nbits! Int)
(declare-const h! Int)
(declare-const round! Int)
(declare-const b@ Poly)
(declare-const tmp%1 Int)
(declare-const tmp%2 Bool)
(declare-const tmp%3 Int)
(declare-const b$1@ Poly)
(declare-const tmp%4 Bool)
(declare-const nbits2@ Int)
(declare-const ret@ Int)
(assert fuel_defaults)
(assert (uInv 64 input!))
(assert (uInv 64 nbits!))
(assert (uInv 64 h!))
(assert (uInv 64 round!))
(assert (= nbits! (uClip 64 (uintshl 64 (I 1) (I (uClip 64 round!))))))
(assert (< round! 6))
(assert (< h! 64))
(assert (and (forall ((b$$0 Poly)) (! (=> (has_type b$$0 (UINT 64)) (=> (and (<= (%I b$$0) (%I (I h!))) (< (uClip 64 (Sub (%I (I h!)) (%I b$$0))) (%I (I nbits!)))) (= (uClip 64 (uintshl 64 (I 1) (I (%I b$$0)))) (uClip 64 (uintand 64 (I (%I (I input!))) (I (uClip 64 (uintshl 64 (I 1) (I (%I b$$0)))))))))) :pattern ((uClip 64 (uintshl 64 (I 1) (I (%I b$$0))))))) (forall ((b$$0 Poly)) (! (=> (has_type b$$0 (UINT 64)) (=> (and (< (%I (I h!)) (%I b$$0)) (< (%I b$$0) 64)) (not (= (uClip 64 (uintshl 64 (I 1) (I (%I b$$0)))) (uClip 64 (uintand 64 (I (%I (I input!))) (I (uClip 64 (uintshl 64 (I 1) (I (%I b$$0))))))))))) :pattern ((uClip 64 (uintshl 64 (I 1) (I (%I b$$0)))))))))
(declare-const %%switch_label%%0 Bool)
(declare-const %%switch_label%%1 Bool)
(set-info :comment ";; requires not satisfied")
(declare-const %%location_label%%0 Bool)
(set-info :comment ";; assertion failed")
(declare-const %%location_label%%1 Bool)
(set-info :comment ";; requires not satisfied")
(declare-const %%location_label%%2 Bool)
(set-info :comment ";; requires not satisfied")
(declare-const %%location_label%%3 Bool)
(set-info :comment ";; requires not satisfied")
(declare-const %%location_label%%4 Bool)
(set-info :comment ";; requires not satisfied")
(declare-const %%location_label%%5 Bool)
(set-info :comment ";; precondition not satisfied")
(declare-const %%location_label%%6 Bool)
(set-info :comment ";; assertion failed")
(declare-const %%location_label%%7 Bool)
(set-info :comment ";; requires not satisfied")
(declare-const %%location_label%%8 Bool)
(set-info :comment ";; requires not satisfied")
(declare-const %%location_label%%9 Bool)
(set-info :comment ";; requires not satisfied")
(declare-const %%location_label%%10 Bool)
(set-info :comment ";; requires not satisfied")
(declare-const %%location_label%%11 Bool)
(set-info :comment ";; requires not satisfied")
(declare-const %%location_label%%12 Bool)
(set-info :comment ";; precondition not satisfied")
(declare-const %%location_label%%13 Bool)
(set-info :comment ";; assertion failed")
(declare-const %%location_label%%14 Bool)
(set-info :comment ";; assertion failed")
(declare-const %%location_label%%15 Bool)
(set-info :comment ";; assertion failed")
(declare-const %%location_label%%16 Bool)
(set-info :comment ";; requires not satisfied")
(declare-const %%location_label%%17 Bool)
(set-info :comment ";; requires not satisfied")
(declare-const %%location_label%%18 Bool)
(set-info :comment ";; requires not satisfied")
(declare-const %%location_label%%19 Bool)
(set-info :comment ";; requires not satisfied")
(declare-const %%location_label%%20 Bool)
(set-info :comment ";; requires not satisfied")
(declare-const %%location_label%%21 Bool)
(set-info :comment ";; requires not satisfied")
(declare-const %%location_label%%22 Bool)
(set-info :comment ";; requires not satisfied")
(declare-const %%location_label%%23 Bool)
(set-info :comment ";; assertion failed")
(declare-const %%location_label%%24 Bool)
(set-info :comment ";; requires not satisfied")
(declare-const %%location_label%%25 Bool)
(set-info :comment ";; requires not satisfied")
(declare-const %%location_label%%26 Bool)
(set-info :comment ";; requires not satisfied")
(declare-const %%location_label%%27 Bool)
(set-info :comment ";; requires not satisfied")
(declare-const %%location_label%%28 Bool)
(set-info :comment ";; assertion failed")
(declare-const %%location_label%%29 Bool)
(set-info :comment ";; postcondition not satisfied")
(declare-const %%location_label%%30 Bool)
(set-info :comment ";; postcondition not satisfied")
(declare-const %%location_label%%31 Bool)
(set-info :comment ";; postcondition not satisfied")
(declare-const %%location_label%%32 Bool)
(assert (not (and (=> (ens%verismo!tspec.math.bits_p.bit64_shl_auto. 0) (and (=> %%location_label%%0 (< round! 6)) (=> (< (uClip 64 (uintshl 64 (I 1) (I (uClip 64 round!)))) (uClip 64 (uintshl 64 (I 1) (I (uClip 64 6))))) (=> %%location_label%%1 (and (< 0 nbits!) (< nbits! 64)))))) (=> (and (< 0 nbits!) (< nbits! 64)) (=> (= nbits2@ (uClip 64 (uintshl 64 (I 1) (I (uClip 64 (uClip 64 (Add round! 1))))))) (and (=> %%location_label%%2 (= nbits! (uClip 64 (uintshl 64 (I 1) (I (uClip 64 round!)))))) (and (=> %%location_label%%3 (= nbits2@ (uClip 64 (uintshl 64 (I 1) (I (uClip 64 (uClip 64 (Add round! 1)))))))) (and (=> %%location_label%%4 (< round! 6)) (=> (= nbits2@ (uClip 64 (Add nbits! nbits!))) (and (=> %%location_label%%5 (< round! 6)) (=> (<= (uClip 64 (uintshl 64 (I 1) (I (uClip 64 round!)))) 32) (=> (= ret@ (uClip 64 (uintor 64 (I input!) (I (uClip 64 (uintshr 64 (I input!) (I nbits!))))))) (and (=> (has_type b@ (UINT 64)) (=> (and (<= (%I b@) h!) (< (uClip 64 (Sub h! (%I b@))) nbits2@)) (=> (ens%verismo!tspec.math.bits_p.bit64_or_auto. 0) (=> (ens%verismo!tspec.math.bits_p.bit64_and_auto. 0) (or (and (=> (and (<= (%I b@) h!) (< (uClip 64 (Sub h! (%I b@))) nbits!)) (=> (= tmp%1 (uClip 64 (uintshr 64 (I input!) (I nbits!)))) (and (=> %%location_label%%6 (req%verismo!tspec.math.bits_p.proof_bit64_has_bit_property. input! tmp%1 (%I b@))) (=> (ens%verismo!tspec.math.bits_p.proof_bit64_has_bit_property. input! tmp%1 (%I b@)) (=> (= tmp%2 (= (uClip 64 (uintshl 64 (I 1) (I (%I b@)))) (uClip 64 (uintand 64 (I (%I (I input!))) (I (uClip 64 (uintshl 64 (I 1) (I (%I b@))))))))) (and (=> %%location_label%%7 tmp%2) (=> tmp%2 %%switch_label%%1))))))) (=> (not (and (<= (%I b@) h!) (< (uClip 64 (Sub h! (%I b@))) nbits!))) (and (=> %%location_label%%8 (and (< 0 h!) (< h! 64))) (and (=> %%location_label%%9 (and (< 0 nbits!) (< nbits! 64))) (and (=> %%location_label%%10 (= (uClip 64 (uintshl 64 (I 1) (I (%I (I (uClip 64 (Add (%I b@) nbits!))))))) (uClip 64 (uintand 64 (I (%I (I input!))) (I (uClip 64 (uintshl 64 (I 1) (I (%I (I (uClip 64 (Add (%I b@) nbits!)))))))))))) (and (=> %%location_label%%11 (<= (%I b@) h!)) (and (=> %%location_label%%12 (< (uClip 64 (Sub h! (uClip 64 (Add (%I b@) nbits!)))) nbits!)) (=> (= (uClip 64 (uintshl 64 (I 1) (I (%I b@)))) (uClip 64 (uintand 64 (I (%I (I (uClip 64 (uintshr 64 (I input!) (I nbits!)))))) (I (uClip 64 (uintshl 64 (I 1) (I (%I b@)))))))) (and (=> (= tmp%3 (uClip 64 (uintshr 64 (I input!) (I nbits!)))) (and (=> %%location_label%%13 (req%verismo!tspec.math.bits_p.proof_bit64_has_bit_property. tmp%3 input! (%I b@))) (=> (ens%verismo!tspec.math.bits_p.proof_bit64_has_bit_property. tmp%3 input! (%I b@)) (=> %%location_label%%14 (= (uClip 64 (uintshl 64 (I 1) (I (%I b@)))) (uClip 64 (uintand 64 (I (%I (I ret@))) (I (uClip 64 (uintshl 64 (I 1) (I (%I b@)))))))))))) (=> (= (uClip 64 (uintshl 64 (I 1) (I (%I b@)))) (uClip 64 (uintand 64 (I (%I (I ret@))) (I (uClip 64 (uintshl 64 (I 1) (I (%I b@)))))))) %%switch_label%%1)))))))))) (and (not %%switch_label%%1) (=> %%location_label%%15 (= (uClip 64 (uintshl 64 (I 1) (I (%I b@)))) (uClip 64 (uintand 64 (I (%I (I ret@))) (I (uClip 64 (uintshl 64 (I 1) (I (%I b@))))))))))))))) (=> (forall ((b$ Poly)) (! (=> (has_type b$ (UINT 64)) (=> (and (<= (%I b$) h!) (< (uClip 64 (Sub h! (%I b$))) nbits2@)) (= (uClip 64 (uintshl 64 (I 1) (I (%I b$)))) (uClip 64 (uintand 64 (I (%I (I ret@))) (I (uClip 64 (uintshl 64 (I 1) (I (%I b$)))))))))) :pattern ((uClip 64 (uintshl 64 (I 1) (I (%I b$))))))) (and (=> (has_type b$1@ (UINT 64)) (=> (and (< h! (%I b$1@)) (< (%I b$1@) 64)) (=> (= tmp%4 (not (= (uClip 64 (uintshl 64 (I 1) (I (%I b$1@)))) (uClip 64 (uintand 64 (I (%I (I input!))) (I (uClip 64 (uintshl 64 (I 1) (I (%I b$1@)))))))))) (and (=> %%location_label%%16 tmp%4) (=> tmp%4 (and (or (and (=> (< (uClip 64 (Add (%I b$1@) nbits!)) 64) (and (=> %%location_label%%17 (< (%I b$1@) 64)) (and (=> %%location_label%%18 (< nbits! 64)) (and (=> %%location_label%%19 (< (uClip 64 (Add (%I b$1@) nbits!)) 64)) (and (=> %%location_label%%20 (not (= (uClip 64 (uintshl 64 (I 1) (I (%I (I (uClip 64 (Add (%I b$1@) nbits!))))))) (uClip 64 (uintand 64 (I (%I (I input!))) (I (uClip 64 (uintshl 64 (I 1) (I (%I (I (uClip 64 (Add (%I b$1@) nbits!))))))))))))) (=> (not (= (uClip 64 (uintshl 64 (I 1) (I (%I b$1@)))) (uClip 64 (uintand 64 (I (%I (I (uClip 64 (uintshr 64 (I input!) (I nbits!)))))) (I (uClip 64 (uintshl 64 (I 1) (I (%I b$1@))))))))) %%switch_label%%0)))))) (=> (not (< (uClip 64 (Add (%I b$1@) nbits!)) 64)) (and (=> %%location_label%%21 (< (%I b$1@) 64)) (and (=> %%location_label%%22 (< nbits! 64)) (and (=> %%location_label%%23 (>= (uClip 64 (Add (%I b$1@) nbits!)) 64)) (=> (not (= (uClip 64 (uintshl 64 (I 1) (I (%I b$1@)))) (uClip 64 (uintand 64 (I (%I (I (uClip 64 (uintshr 64 (I input!) (I nbits!)))))) (I (uClip 64 (uintshl 64 (I 1) (I (%I b$1@))))))))) %%switch_label%%0)))))) (and (not %%switch_label%%0) (=> %%location_label%%24 (not (= (uClip 64 (uintshl 64 (I 1) (I (%I b$1@)))) (uClip 64 (uintand 64 (I (%I (I (uClip 64 (uintshr 64 (I input!) (I nbits!)))))) (I (uClip 64 (uintshl 64 (I 1) (I (%I b$1@)))))))))))) (=> (not (= (uClip 64 (uintshl 64 (I 1) (I (%I b$1@)))) (uClip 64 (uintand 64 (I (%I (I (uClip 64 (uintshr 64 (I input!) (I nbits!)))))) (I (uClip 64 (uintshl 64 (I 1) (I (%I b$1@))))))))) (and (=> %%location_label%%25 (and (< 0 nbits!) (< nbits! 64))) (and (=> %%location_label%%26 (and (< h! (%I b$1@)) (< (%I b$1@) 64))) (and (=> %%location_label%%27 (not (= (uClip 64 (uintshl 64 (I 1) (I (%I b$1@)))) (uClip 64 (uintand 64 (I (%I (I input!))) (I (uClip 64 (uintshl 64 (I 1) (I (%I b$1@)))))))))) (and (=> %%location_label%%28 (not (= (uClip 64 (uintshl 64 (I 1) (I (%I b$1@)))) (uClip 64 (uintand 64 (I (%I (I (uClip 64 (uintshr 64 (I input!) (I nbits!)))))) (I (uClip 64 (uintshl 64 (I 1) (I (%I b$1@)))))))))) (=> (not (= (uClip 64 (uintshl 64 (I 1) (I (%I b$1@)))) (uClip 64 (uintand 64 (I (%I (I (uClip 64 (uintor 64 (I input!) (I (uClip 64 (uintshr 64 (I input!) (I nbits!))))))))) (I (uClip 64 (uintshl 64 (I 1) (I (%I b$1@))))))))) (=> %%location_label%%29 (not (= (uClip 64 (uintshl 64 (I 1) (I (%I b$1@)))) (uClip 64 (uintand 64 (I (%I (I ret@))) (I (uClip 64 (uintshl 64 (I 1) (I (%I b$1@)))))))))))))))))))))) (=> (forall ((b$ Poly)) (! (=> (has_type b$ (UINT 64)) (=> (and (< h! (%I b$)) (< (%I b$) 64)) (not (= (uClip 64 (uintshl 64 (I 1) (I (%I b$)))) (uClip 64 (uintand 64 (I (%I (I ret@))) (I (uClip 64 (uintshl 64 (I 1) (I (%I b$))))))))))) :pattern ((uClip 64 (uintshl 64 (I 1) (I (%I b$))))))) (=> (= ret! (tuple%2./tuple%2 (I ret@) (I nbits2@))) (and (=> %%location_label%%30 (= (%I (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. ret!)))) (uClip 64 (uintor 64 (I input!) (I (uClip 64 (uintshr 64 (I input!) (I nbits!)))))))) (and (=> %%location_label%%31 (= (%I (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. ret!)))) (uClip 64 (uintshl 64 (I 1) (I (uClip 64 (uClip 64 (Add round! 1)))))))) (=> %%location_label%%32 (and (forall ((b$$0 Poly)) (! (=> (has_type b$$0 (UINT 64)) (=> (and (<= (%I b$$0) (%I (I h!))) (< (uClip 64 (Sub (%I (I h!)) (%I b$$0))) (%I (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. ret!)))))) (= (uClip 64 (uintshl 64 (I 1) (I (%I b$$0)))) (uClip 64 (uintand 64 (I (%I (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. ret!))))) (I (uClip 64 (uintshl 64 (I 1) (I (%I b$$0)))))))))) :pattern ((uClip 64 (uintshl 64 (I 1) (I (%I b$$0))))))) (forall ((b$$0 Poly)) (! (=> (has_type b$$0 (UINT 64)) (=> (and (< (%I (I h!)) (%I b$$0)) (< (%I b$$0) 64)) (not (= (uClip 64 (uintshl 64 (I 1) (I (%I b$$0)))) (uClip 64 (uintand 64 (I (%I (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. ret!))))) (I (uClip 64 (uintshl 64 (I 1) (I (%I b$$0))))))))))) :pattern ((uClip 64 (uintshl 64 (I 1) (I (%I b$$0))))))))))))))))))))))))))))
(check-sat)
(exit)
