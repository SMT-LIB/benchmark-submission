(set-info :smt-lib-version 2.6)
(set-logic UFDTNIA)
(set-info :source |
Generated by: Amar Shah
Generated on: 2024-12-11
Generator: Verus
Application: Verification of Rust Program
Target solver: z3
Time limit: 10
Benchmarks generated by the Rust verifier Verus (https://verus-lang.github.io/verus/guide/) on the project Atmosphere (https://mars-research.github.io/projects/atmo/) and processed using Mariposa (https://github.com/secure-foundations/mariposa). z3 solves this without nonlinear, but it cannot be expressed in SMTLib without a nonlinear theory.
|)
(set-info :license "https://creativecommons.org/licenses/by/4.0/")
(set-info :category "industrial")
(set-info :status unsat)
(set-option :auto_config false)
(set-option :smt.mbqi false)
(set-option :smt.case_split 3)
(set-option :smt.qi.eager_threshold 100.0)
(set-option :smt.delay_units true)
(set-option :smt.arith.solver 2)
(set-option :smt.arith.nl false)
(set-option :pi.enabled false)
(set-option :rewriter.sort_disjunctions false)
(set-info :comment ";; Prelude")
(set-info :comment ";; AIR prelude")
(declare-sort %%Function%% 0)
(declare-sort FuelId 0)
(declare-sort Fuel 0)
(declare-const zero Fuel)
(declare-fun succ (Fuel) Fuel)
(declare-fun fuel_bool (FuelId) Bool)
(declare-fun fuel_bool_default (FuelId) Bool)
(declare-const fuel_defaults Bool)
(assert (=> fuel_defaults (forall ((id FuelId)) (! (= (fuel_bool id) (fuel_bool_default id)) :pattern ((fuel_bool id))))))
(declare-datatypes ((fndef 0)) (((fndef_singleton ))))
(declare-sort Poly 0)
(declare-sort Height 0)
(declare-fun I (Int) Poly)
(declare-fun B (Bool) Poly)
(declare-fun F (fndef) Poly)
(declare-fun %I (Poly) Int)
(declare-fun %B (Poly) Bool)
(declare-fun %F (Poly) fndef)
(declare-sort Type 0)
(declare-const BOOL Type)
(declare-const INT Type)
(declare-const NAT Type)
(declare-const CHAR Type)
(declare-fun UINT (Int) Type)
(declare-fun SINT (Int) Type)
(declare-fun CONST_INT (Int) Type)
(declare-sort Dcr 0)
(declare-const $ Dcr)
(declare-fun REF (Dcr) Dcr)
(declare-fun MUT_REF (Dcr) Dcr)
(declare-fun BOX (Dcr Type Dcr) Dcr)
(declare-fun RC (Dcr Type Dcr) Dcr)
(declare-fun ARC (Dcr Type Dcr) Dcr)
(declare-fun GHOST (Dcr) Dcr)
(declare-fun TRACKED (Dcr) Dcr)
(declare-fun NEVER (Dcr) Dcr)
(declare-fun CONST_PTR (Dcr) Dcr)
(declare-fun ARRAY (Dcr Type Dcr Type) Type)
(declare-fun SLICE (Dcr Type) Type)
(declare-const STRSLICE Type)
(declare-const ALLOCATOR_GLOBAL Type)
(declare-fun PTR (Dcr Type) Type)
(declare-fun has_type (Poly Type) Bool)
(declare-fun as_type (Poly Type) Poly)
(declare-fun mk_fun (%%Function%%) %%Function%%)
(declare-fun const_int (Type) Int)
(assert (forall ((i Int)) (! (= i (const_int (CONST_INT i))) :pattern ((CONST_INT i)))))
(assert (forall ((b Bool)) (! (has_type (B b) BOOL) :pattern ((has_type (B b) BOOL)))))
(assert (forall ((x Poly) (True Type)) (! (and (has_type (as_type x True) True) (=> (has_type x True) (= x (as_type x True)))) :pattern ((as_type x True)))))
(assert (forall ((x %%Function%%)) (! (= (mk_fun x) x) :pattern ((mk_fun x)))))
(assert (forall ((x Bool)) (! (= x (%B (B x))) :pattern ((B x)))))
(assert (forall ((x Int)) (! (= x (%I (I x))) :pattern ((I x)))))
(assert (forall ((x Poly)) (! (=> (has_type x BOOL) (= x (B (%B x)))) :pattern ((has_type x BOOL)))))
(assert (forall ((x Poly)) (! (=> (has_type x INT) (= x (I (%I x)))) :pattern ((has_type x INT)))))
(assert (forall ((x Poly)) (! (=> (has_type x NAT) (= x (I (%I x)))) :pattern ((has_type x NAT)))))
(assert (forall ((bits Int) (x Poly)) (! (=> (has_type x (UINT bits)) (= x (I (%I x)))) :pattern ((has_type x (UINT bits))))))
(assert (forall ((bits Int) (x Poly)) (! (=> (has_type x (SINT bits)) (= x (I (%I x)))) :pattern ((has_type x (SINT bits))))))
(assert (forall ((x Poly)) (! (=> (has_type x CHAR) (= x (I (%I x)))) :pattern ((has_type x CHAR)))))
(declare-fun ext_eq (Bool Type Poly Poly) Bool)
(assert (forall ((deep Bool) (True Type) (x Poly) (y Poly)) (! (= (= x y) (ext_eq deep True x y)) :pattern ((ext_eq deep True x y)))))
(declare-const SZ Int)
(assert (= SZ 64))
(declare-fun uHi (Int) Int)
(declare-fun iLo (Int) Int)
(declare-fun iHi (Int) Int)
(assert (= (uHi 8) 256))
(assert (= (uHi 16) 65536))
(assert (= (uHi 32) 4294967296))
(assert (= (uHi 64) 18446744073709551616))
(assert (= (uHi 128) (+ 1 340282366920938463463374607431768211455)))
(assert (= (iLo 8) (- 128)))
(assert (= (iLo 16) (- 32768)))
(assert (= (iLo 32) (- 2147483648)))
(assert (= (iLo 64) (- 9223372036854775808)))
(assert (= (iLo 128) (- 170141183460469231731687303715884105728)))
(assert (= (iHi 8) 128))
(assert (= (iHi 16) 32768))
(assert (= (iHi 32) 2147483648))
(assert (= (iHi 64) 9223372036854775808))
(assert (= (iHi 128) 170141183460469231731687303715884105728))
(declare-fun nClip (Int) Int)
(declare-fun uClip (Int Int) Int)
(declare-fun iClip (Int Int) Int)
(declare-fun charClip (Int) Int)
(assert (forall ((i Int)) (! (and (<= 0 (nClip i)) (=> (<= 0 i) (= i (nClip i)))) :pattern ((nClip i)))))
(assert (forall ((bits Int) (i Int)) (! (and (<= 0 (uClip bits i)) (< (uClip bits i) (uHi bits)) (=> (and (<= 0 i) (< i (uHi bits))) (= i (uClip bits i)))) :pattern ((uClip bits i)))))
(assert (forall ((bits Int) (i Int)) (! (and (<= (iLo bits) (iClip bits i)) (< (iClip bits i) (iHi bits)) (=> (and (<= (iLo bits) i) (< i (iHi bits))) (= i (iClip bits i)))) :pattern ((iClip bits i)))))
(assert (forall ((i Int)) (! (and (or (and (<= 0 (charClip i)) (<= (charClip i) 55295)) (and (<= 57344 (charClip i)) (<= (charClip i) 1114111))) (=> (or (and (<= 0 i) (<= i 55295)) (and (<= 57344 i) (<= i 1114111))) (= i (charClip i)))) :pattern ((charClip i)))))
(declare-fun uInv (Int Int) Bool)
(declare-fun iInv (Int Int) Bool)
(declare-fun charInv (Int) Bool)
(assert (forall ((bits Int) (i Int)) (! (= (uInv bits i) (and (<= 0 i) (< i (uHi bits)))) :pattern ((uInv bits i)))))
(assert (forall ((bits Int) (i Int)) (! (= (iInv bits i) (and (<= (iLo bits) i) (< i (iHi bits)))) :pattern ((iInv bits i)))))
(assert (forall ((i Int)) (! (= (charInv i) (or (and (<= 0 i) (<= i 55295)) (and (<= 57344 i) (<= i 1114111)))) :pattern ((charInv i)))))
(assert (forall ((x Int)) (! (has_type (I x) INT) :pattern ((has_type (I x) INT)))))
(assert (forall ((x Int)) (! (=> (<= 0 x) (has_type (I x) NAT)) :pattern ((has_type (I x) NAT)))))
(assert (forall ((bits Int) (x Int)) (! (=> (uInv bits x) (has_type (I x) (UINT bits))) :pattern ((has_type (I x) (UINT bits))))))
(assert (forall ((bits Int) (x Int)) (! (=> (iInv bits x) (has_type (I x) (SINT bits))) :pattern ((has_type (I x) (SINT bits))))))
(assert (forall ((x Int)) (! (=> (charInv x) (has_type (I x) CHAR)) :pattern ((has_type (I x) CHAR)))))
(assert (forall ((x Poly)) (! (=> (has_type x NAT) (<= 0 (%I x))) :pattern ((has_type x NAT)))))
(assert (forall ((bits Int) (x Poly)) (! (=> (has_type x (UINT bits)) (uInv bits (%I x))) :pattern ((has_type x (UINT bits))))))
(assert (forall ((bits Int) (x Poly)) (! (=> (has_type x (SINT bits)) (iInv bits (%I x))) :pattern ((has_type x (SINT bits))))))
(declare-fun Add (Int Int) Int)
(declare-fun Sub (Int Int) Int)
(declare-fun Mul (Int Int) Int)
(declare-fun EucDiv (Int Int) Int)
(declare-fun EucMod (Int Int) Int)
(assert (forall ((x Int) (y Int)) (! (= (Add x y) (+ x y)) :pattern ((Add x y)))))
(assert (forall ((x Int) (y Int)) (! (= (Sub x y) (- x y)) :pattern ((Sub x y)))))
(assert (forall ((x Int) (y Int)) (! (= (Mul x y) (* x y)) :pattern ((Mul x y)))))
(assert (forall ((x Int) (y Int)) (! (= (EucDiv x y) (div x y)) :pattern ((EucDiv x y)))))
(assert (forall ((x Int) (y Int)) (! (= (EucMod x y) (mod x y)) :pattern ((EucMod x y)))))
(assert (forall ((x Int) (y Int)) (! (=> (and (<= 0 x) (<= 0 y)) (<= 0 (Mul x y))) :pattern ((Mul x y)))))
(assert (forall ((x Int) (y Int)) (! (=> (and (<= 0 x) (< 0 y)) (and (<= 0 (EucDiv x y)) (<= (EucDiv x y) x))) :pattern ((EucDiv x y)))))
(assert (forall ((x Int) (y Int)) (! (=> (and (<= 0 x) (< 0 y)) (and (<= 0 (EucMod x y)) (< (EucMod x y) y))) :pattern ((EucMod x y)))))
(declare-fun bitxor (Poly Poly) Int)
(declare-fun bitand (Poly Poly) Int)
(declare-fun bitor (Poly Poly) Int)
(declare-fun bitshr (Poly Poly) Int)
(declare-fun bitshl (Poly Poly) Int)
(declare-fun bitnot (Poly) Int)
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (uInv bits (%I x)) (uInv bits (%I y))) (uInv bits (bitxor x y))) :pattern ((uClip bits (bitxor x y))))))
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (iInv bits (%I x)) (iInv bits (%I y))) (iInv bits (bitxor x y))) :pattern ((iClip bits (bitxor x y))))))
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (uInv bits (%I x)) (uInv bits (%I y))) (uInv bits (bitor x y))) :pattern ((uClip bits (bitor x y))))))
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (iInv bits (%I x)) (iInv bits (%I y))) (iInv bits (bitor x y))) :pattern ((iClip bits (bitor x y))))))
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (uInv bits (%I x)) (uInv bits (%I y))) (uInv bits (bitand x y))) :pattern ((uClip bits (bitand x y))))))
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (iInv bits (%I x)) (iInv bits (%I y))) (iInv bits (bitand x y))) :pattern ((iClip bits (bitand x y))))))
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (uInv bits (%I x)) (<= 0 (%I y))) (uInv bits (bitshr x y))) :pattern ((uClip bits (bitshr x y))))))
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (iInv bits (%I x)) (<= 0 (%I y))) (iInv bits (bitshr x y))) :pattern ((iClip bits (bitshr x y))))))
(declare-fun singular_mod (Int Int) Int)
(assert (forall ((x Int) (y Int)) (! (=> (not (= y 0)) (= (EucMod x y) (singular_mod x y))) :pattern ((singular_mod x y)))))
(declare-fun closure_req (Type Dcr Type Poly Poly) Bool)
(declare-fun closure_ens (Type Dcr Type Poly Poly Poly) Bool)
(declare-fun height (Poly) Height)
(declare-fun height_lt (Height Height) Bool)
(declare-fun fun_from_recursive_field (Poly) Poly)
(declare-fun check_decrease_int (Int Int Bool) Bool)
(assert (forall ((cur Int) (prev Int) (otherwise Bool)) (! (= (check_decrease_int cur prev otherwise) (or (and (<= 0 cur) (< cur prev)) (and (= cur prev) otherwise))) :pattern ((check_decrease_int cur prev otherwise)))))
(declare-fun check_decrease_height (Poly Poly Bool) Bool)
(assert (forall ((cur Poly) (prev Poly) (otherwise Bool)) (! (= (check_decrease_height cur prev otherwise) (or (height_lt (height cur) (height prev)) (and (= (height cur) (height prev)) otherwise))) :pattern ((check_decrease_height cur prev otherwise)))))
(declare-fun partial-order (Height Height) Bool)
(assert (forall ((x Height)) (partial-order x x)))
(assert (forall ((x Height) (y Height)) (=> (and (partial-order x y) (partial-order y x)) (= x y))))
(assert (forall ((x Height) (y Height) (z Height)) (=> (and (partial-order x y) (partial-order y z)) (partial-order x z))))
(assert (forall ((x Height) (y Height)) (! (= (height_lt x y) (and (partial-order x y) (not (= x y)))) :pattern ((height_lt x y)))))
(set-info :comment ";; MODULE 'module va_range'")
(set-info :comment ";; Fuel")
(declare-const fuel%vstd!seq.impl&%0.spec_index. FuelId)
(declare-const fuel%vstd!seq.axiom_seq_index_decreases. FuelId)
(declare-const fuel%vstd!seq.axiom_seq_new_len. FuelId)
(declare-const fuel%vstd!seq.axiom_seq_new_index. FuelId)
(declare-const fuel%vstd!seq.axiom_seq_ext_equal. FuelId)
(declare-const fuel%vstd!seq.axiom_seq_ext_equal_deep. FuelId)
(declare-const fuel%vstd!seq_lib.impl&%0.no_duplicates. FuelId)
(declare-const fuel%lib!util.page_ptr_util_u.spec_va_4k_range_valid. FuelId)
(declare-const fuel%lib!util.page_ptr_util_u.spec_va_4k_valid. FuelId)
(declare-const fuel%lib!util.page_ptr_util_u.spec_va_add_range. FuelId)
(declare-const fuel%lib!define.KERNEL_MEM_END_L4INDEX. FuelId)
(declare-const fuel%lib!define.MEM_4k_MASK. FuelId)
(declare-const fuel%lib!va_range.spec_va_range_disjoint. FuelId)
(declare-const fuel%lib!va_range.impl&%2.view. FuelId)
(declare-const fuel%lib!va_range.impl&%2.wf. FuelId)
(declare-const fuel%lib!va_range.impl&%2.view_match_spec. FuelId)
(declare-const fuel%vstd!array.group_array_axioms. FuelId)
(declare-const fuel%vstd!map.group_map_axioms. FuelId)
(declare-const fuel%vstd!multiset.group_multiset_axioms. FuelId)
(declare-const fuel%vstd!raw_ptr.group_raw_ptr_axioms. FuelId)
(declare-const fuel%vstd!seq.group_seq_axioms. FuelId)
(declare-const fuel%vstd!seq_lib.group_seq_lib_default. FuelId)
(declare-const fuel%vstd!set.group_set_axioms. FuelId)
(declare-const fuel%vstd!set_lib.group_set_lib_axioms. FuelId)
(declare-const fuel%vstd!slice.group_slice_axioms. FuelId)
(declare-const fuel%vstd!string.group_string_axioms. FuelId)
(declare-const fuel%vstd!std_specs.bits.group_bits_axioms. FuelId)
(declare-const fuel%vstd!std_specs.control_flow.group_control_flow_axioms. FuelId)
(declare-const fuel%vstd!std_specs.range.group_range_axioms. FuelId)
(declare-const fuel%vstd!std_specs.vec.group_vec_axioms. FuelId)
(declare-const fuel%vstd!group_vstd_default. FuelId)
(assert (distinct fuel%vstd!seq.impl&%0.spec_index. fuel%vstd!seq.axiom_seq_index_decreases. fuel%vstd!seq.axiom_seq_new_len. fuel%vstd!seq.axiom_seq_new_index. fuel%vstd!seq.axiom_seq_ext_equal. fuel%vstd!seq.axiom_seq_ext_equal_deep. fuel%vstd!seq_lib.impl&%0.no_duplicates. fuel%lib!util.page_ptr_util_u.spec_va_4k_range_valid. fuel%lib!util.page_ptr_util_u.spec_va_4k_valid. fuel%lib!util.page_ptr_util_u.spec_va_add_range. fuel%lib!define.KERNEL_MEM_END_L4INDEX. fuel%lib!define.MEM_4k_MASK. fuel%lib!va_range.spec_va_range_disjoint. fuel%lib!va_range.impl&%2.view. fuel%lib!va_range.impl&%2.wf. fuel%lib!va_range.impl&%2.view_match_spec. fuel%vstd!array.group_array_axioms. fuel%vstd!map.group_map_axioms. fuel%vstd!multiset.group_multiset_axioms. fuel%vstd!raw_ptr.group_raw_ptr_axioms. fuel%vstd!seq.group_seq_axioms. fuel%vstd!seq_lib.group_seq_lib_default. fuel%vstd!set.group_set_axioms. fuel%vstd!set_lib.group_set_lib_axioms. fuel%vstd!slice.group_slice_axioms. fuel%vstd!string.group_string_axioms. fuel%vstd!std_specs.bits.group_bits_axioms. fuel%vstd!std_specs.control_flow.group_control_flow_axioms. fuel%vstd!std_specs.range.group_range_axioms. fuel%vstd!std_specs.vec.group_vec_axioms. fuel%vstd!group_vstd_default.))
(assert (=> (fuel_bool_default fuel%vstd!seq.group_seq_axioms.) (and (fuel_bool_default fuel%vstd!seq.axiom_seq_index_decreases.) (fuel_bool_default fuel%vstd!seq.axiom_seq_new_len.) (fuel_bool_default fuel%vstd!seq.axiom_seq_new_index.) (fuel_bool_default fuel%vstd!seq.axiom_seq_ext_equal.) (fuel_bool_default fuel%vstd!seq.axiom_seq_ext_equal_deep.))))
(assert (fuel_bool_default fuel%vstd!group_vstd_default.))
(assert (=> (fuel_bool_default fuel%vstd!group_vstd_default.) (and (fuel_bool_default fuel%vstd!seq.group_seq_axioms.) (fuel_bool_default fuel%vstd!seq_lib.group_seq_lib_default.) (fuel_bool_default fuel%vstd!map.group_map_axioms.) (fuel_bool_default fuel%vstd!set.group_set_axioms.) (fuel_bool_default fuel%vstd!set_lib.group_set_lib_axioms.) (fuel_bool_default fuel%vstd!std_specs.bits.group_bits_axioms.) (fuel_bool_default fuel%vstd!std_specs.control_flow.group_control_flow_axioms.) (fuel_bool_default fuel%vstd!std_specs.vec.group_vec_axioms.) (fuel_bool_default fuel%vstd!slice.group_slice_axioms.) (fuel_bool_default fuel%vstd!array.group_array_axioms.) (fuel_bool_default fuel%vstd!multiset.group_multiset_axioms.) (fuel_bool_default fuel%vstd!string.group_string_axioms.) (fuel_bool_default fuel%vstd!std_specs.range.group_range_axioms.) (fuel_bool_default fuel%vstd!raw_ptr.group_raw_ptr_axioms.))))
(set-info :comment ";; Datatypes")
(declare-sort vstd!seq.Seq<usize.>. 0)
(declare-datatypes ((lib!va_range.VaRange4K. 0) (tuple%0. 0)) (((lib!va_range.VaRange4K./VaRange4K (lib!va_range.VaRange4K./VaRange4K/?start Int) (lib!va_range.VaRange4K./VaRange4K/?len Int) (lib!va_range.VaRange4K./VaRange4K/?view vstd!seq.Seq<usize.>.))) ((tuple%0./tuple%0 ))))
(declare-fun lib!va_range.VaRange4K./VaRange4K/start (lib!va_range.VaRange4K.) Int)
(declare-fun lib!va_range.VaRange4K./VaRange4K/len (lib!va_range.VaRange4K.) Int)
(declare-fun lib!va_range.VaRange4K./VaRange4K/view (lib!va_range.VaRange4K.) vstd!seq.Seq<usize.>.)
(declare-fun TYPE%fun%1. (Dcr Type Dcr Type) Type)
(declare-fun TYPE%vstd!seq.Seq. (Dcr Type) Type)
(declare-const TYPE%lib!va_range.VaRange4K. Type)
(declare-const TYPE%tuple%0. Type)
(declare-fun Poly%fun%1. (%%Function%%) Poly)
(declare-fun %Poly%fun%1. (Poly) %%Function%%)
(declare-fun Poly%vstd!seq.Seq<usize.>. (vstd!seq.Seq<usize.>.) Poly)
(declare-fun %Poly%vstd!seq.Seq<usize.>. (Poly) vstd!seq.Seq<usize.>.)
(declare-fun Poly%lib!va_range.VaRange4K. (lib!va_range.VaRange4K.) Poly)
(declare-fun %Poly%lib!va_range.VaRange4K. (Poly) lib!va_range.VaRange4K.)
(declare-fun Poly%tuple%0. (tuple%0.) Poly)
(declare-fun %Poly%tuple%0. (Poly) tuple%0.)
(assert (forall ((x %%Function%%)) (! (= x (%Poly%fun%1. (Poly%fun%1. x))) :pattern ((Poly%fun%1. x)))))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (x Poly)) (! (=> (has_type x (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)) (= x (Poly%fun%1. (%Poly%fun%1. x)))) :pattern ((has_type x (TYPE%fun%1. T%0&. T%0& T%1&. T%1&))))))
(declare-fun %%apply%%0 (%%Function%% Poly) Poly)
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (x %%Function%%)) (! (=> (forall ((T%0 Poly)) (! (=> (has_type T%0 T%0&) (has_type (%%apply%%0 x T%0) T%1&)) :pattern ((has_type (%%apply%%0 x T%0) T%1&)))) (has_type (Poly%fun%1. (mk_fun x)) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&))) :pattern ((has_type (Poly%fun%1. (mk_fun x)) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&))))))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (T%0 Poly) (x %%Function%%)) (! (=> (and (has_type (Poly%fun%1. x) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)) (has_type T%0 T%0&)) (has_type (%%apply%%0 x T%0) T%1&)) :pattern ((%%apply%%0 x T%0) (has_type (Poly%fun%1. x) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&))))))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (T%0 Poly) (x %%Function%%)) (! (=> (and (has_type (Poly%fun%1. x) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)) (has_type T%0 T%0&)) (height_lt (height (%%apply%%0 x T%0)) (height (fun_from_recursive_field (Poly%fun%1. (mk_fun x)))))) :pattern ((height (%%apply%%0 x T%0)) (has_type (Poly%fun%1. x) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&))))))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (deep Bool) (x Poly) (y Poly)) (! (=> (and (has_type x (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)) (has_type y (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)) (forall ((T%0 Poly)) (! (=> (has_type T%0 T%0&) (ext_eq deep T%1& (%%apply%%0 (%Poly%fun%1. x) T%0) (%%apply%%0 (%Poly%fun%1. y) T%0))) :pattern ((ext_eq deep T%1& (%%apply%%0 (%Poly%fun%1. x) T%0) (%%apply%%0 (%Poly%fun%1. y) T%0)))))) (ext_eq deep (TYPE%fun%1. T%0&. T%0& T%1&. T%1&) x y)) :pattern ((ext_eq deep (TYPE%fun%1. T%0&. T%0& T%1&. T%1&) x y)))))
(assert (forall ((x vstd!seq.Seq<usize.>.)) (! (= x (%Poly%vstd!seq.Seq<usize.>. (Poly%vstd!seq.Seq<usize.>. x))) :pattern ((Poly%vstd!seq.Seq<usize.>. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x (TYPE%vstd!seq.Seq. $ (UINT SZ))) (= x (Poly%vstd!seq.Seq<usize.>. (%Poly%vstd!seq.Seq<usize.>. x)))) :pattern ((has_type x (TYPE%vstd!seq.Seq. $ (UINT SZ)))))))
(assert (forall ((x vstd!seq.Seq<usize.>.)) (! (has_type (Poly%vstd!seq.Seq<usize.>. x) (TYPE%vstd!seq.Seq. $ (UINT SZ))) :pattern ((has_type (Poly%vstd!seq.Seq<usize.>. x) (TYPE%vstd!seq.Seq. $ (UINT SZ)))))))
(assert (forall ((x lib!va_range.VaRange4K.)) (! (= x (%Poly%lib!va_range.VaRange4K. (Poly%lib!va_range.VaRange4K. x))) :pattern ((Poly%lib!va_range.VaRange4K. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!va_range.VaRange4K.) (= x (Poly%lib!va_range.VaRange4K. (%Poly%lib!va_range.VaRange4K. x)))) :pattern ((has_type x TYPE%lib!va_range.VaRange4K.)))))
(assert (forall ((_start! Int) (_len! Int) (_view! vstd!seq.Seq<usize.>.)) (! (=> (and (uInv SZ _start!) (uInv SZ _len!)) (has_type (Poly%lib!va_range.VaRange4K. (lib!va_range.VaRange4K./VaRange4K _start! _len! _view!)) TYPE%lib!va_range.VaRange4K.)) :pattern ((has_type (Poly%lib!va_range.VaRange4K. (lib!va_range.VaRange4K./VaRange4K _start! _len! _view!)) TYPE%lib!va_range.VaRange4K.)))))
(assert (forall ((x lib!va_range.VaRange4K.)) (! (= (lib!va_range.VaRange4K./VaRange4K/start x) (lib!va_range.VaRange4K./VaRange4K/?start x)) :pattern ((lib!va_range.VaRange4K./VaRange4K/start x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!va_range.VaRange4K.) (uInv SZ (lib!va_range.VaRange4K./VaRange4K/start (%Poly%lib!va_range.VaRange4K. x)))) :pattern ((lib!va_range.VaRange4K./VaRange4K/start (%Poly%lib!va_range.VaRange4K. x)) (has_type x TYPE%lib!va_range.VaRange4K.)))))
(assert (forall ((x lib!va_range.VaRange4K.)) (! (= (lib!va_range.VaRange4K./VaRange4K/len x) (lib!va_range.VaRange4K./VaRange4K/?len x)) :pattern ((lib!va_range.VaRange4K./VaRange4K/len x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!va_range.VaRange4K.) (uInv SZ (lib!va_range.VaRange4K./VaRange4K/len (%Poly%lib!va_range.VaRange4K. x)))) :pattern ((lib!va_range.VaRange4K./VaRange4K/len (%Poly%lib!va_range.VaRange4K. x)) (has_type x TYPE%lib!va_range.VaRange4K.)))))
(assert (forall ((x lib!va_range.VaRange4K.)) (! (= (lib!va_range.VaRange4K./VaRange4K/view x) (lib!va_range.VaRange4K./VaRange4K/?view x)) :pattern ((lib!va_range.VaRange4K./VaRange4K/view x)))))
(assert (forall ((x tuple%0.)) (! (= x (%Poly%tuple%0. (Poly%tuple%0. x))) :pattern ((Poly%tuple%0. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%tuple%0.) (= x (Poly%tuple%0. (%Poly%tuple%0. x)))) :pattern ((has_type x TYPE%tuple%0.)))))
(assert (forall ((x tuple%0.)) (! (has_type (Poly%tuple%0. x) TYPE%tuple%0.) :pattern ((has_type (Poly%tuple%0. x) TYPE%tuple%0.)))))
(set-info :comment ";; Function-Decl vstd::seq::Seq::len")
(declare-fun vstd!seq.Seq.len.? (Dcr Type Poly) Int)
(set-info :comment ";; Function-Decl vstd::seq::Seq::new")
(declare-fun vstd!seq.Seq.new.? (Dcr Type Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::seq::Seq::index")
(declare-fun vstd!seq.Seq.index.? (Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::seq::impl&%0::spec_index")
(declare-fun vstd!seq.impl&%0.spec_index.? (Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::seq_lib::impl&%0::no_duplicates")
(declare-fun vstd!seq_lib.impl&%0.no_duplicates.? (Dcr Type Poly) Bool)
(set-info :comment ";; Function-Decl lib::define::MEM_4k_MASK")
(declare-fun lib!define.MEM_4k_MASK.? () Int)
(set-info :comment ";; Function-Decl lib::define::KERNEL_MEM_END_L4INDEX")
(declare-fun lib!define.KERNEL_MEM_END_L4INDEX.? () Int)
(set-info :comment ";; Function-Decl lib::util::page_ptr_util_u::spec_va_4k_valid")
(declare-fun lib!util.page_ptr_util_u.spec_va_4k_valid.? (Poly) Bool)
(set-info :comment ";; Function-Decl lib::va_range::VaRange4K::view")
(declare-fun lib!va_range.impl&%2.view.? (Poly) vstd!seq.Seq<usize.>.)
(set-info :comment ";; Function-Decl lib::util::page_ptr_util_u::spec_va_add_range")
(declare-fun lib!util.page_ptr_util_u.spec_va_add_range.? (Poly Poly) Int)
(set-info :comment ";; Function-Decl lib::va_range::VaRange4K::view_match_spec")
(declare-fun lib!va_range.impl&%2.view_match_spec.? (Poly) Bool)
(set-info :comment ";; Function-Decl lib::va_range::VaRange4K::wf")
(declare-fun lib!va_range.impl&%2.wf.? (Poly) Bool)
(set-info :comment ";; Function-Decl lib::util::page_ptr_util_u::spec_va_4k_range_valid")
(declare-fun lib!util.page_ptr_util_u.spec_va_4k_range_valid.? (Poly Poly) Bool)
(set-info :comment ";; Function-Decl lib::va_range::spec_va_range_disjoint")
(declare-fun lib!va_range.spec_va_range_disjoint.? (Poly Poly) Bool)
(set-info :comment ";; Function-Axioms vstd::seq::Seq::len")
(assert (forall ((A&. Dcr) (A& Type) (self! Poly)) (! (=> (has_type self! (TYPE%vstd!seq.Seq. A&. A&)) (<= 0 (vstd!seq.Seq.len.? A&. A& self!))) :pattern ((vstd!seq.Seq.len.? A&. A& self!)))))
(set-info :comment ";; Function-Axioms vstd::seq::Seq::new")
(assert (forall ((A&. Dcr) (A& Type) (impl%1&. Dcr) (impl%1& Type) (len! Poly) (f! Poly)) (! (=> (and (has_type len! NAT) (has_type f! impl%1&)) (has_type (vstd!seq.Seq.new.? A&. A& impl%1&. impl%1& len! f!) (TYPE%vstd!seq.Seq. A&. A&))) :pattern ((vstd!seq.Seq.new.? A&. A& impl%1&. impl%1& len! f!)))))
(set-info :comment ";; Function-Specs vstd::seq::Seq::index")
(declare-fun req%vstd!seq.Seq.index. (Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%0 Bool)
(assert (forall ((A&. Dcr) (A& Type) (self! Poly) (i! Poly)) (! (= (req%vstd!seq.Seq.index. A&. A& self! i!) (=> %%global_location_label%%0 (and (<= 0 (%I i!)) (< (%I i!) (vstd!seq.Seq.len.? A&. A& self!))))) :pattern ((req%vstd!seq.Seq.index. A&. A& self! i!)))))
(set-info :comment ";; Function-Axioms vstd::seq::Seq::index")
(assert (forall ((A&. Dcr) (A& Type) (self! Poly) (i! Poly)) (! (=> (and (has_type self! (TYPE%vstd!seq.Seq. A&. A&)) (has_type i! INT)) (has_type (vstd!seq.Seq.index.? A&. A& self! i!) A&)) :pattern ((vstd!seq.Seq.index.? A&. A& self! i!)))))
(set-info :comment ";; Function-Specs vstd::seq::impl&%0::spec_index")
(declare-fun req%vstd!seq.impl&%0.spec_index. (Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%1 Bool)
(assert (forall ((A&. Dcr) (A& Type) (self! Poly) (i! Poly)) (! (= (req%vstd!seq.impl&%0.spec_index. A&. A& self! i!) (=> %%global_location_label%%1 (and (<= 0 (%I i!)) (< (%I i!) (vstd!seq.Seq.len.? A&. A& self!))))) :pattern ((req%vstd!seq.impl&%0.spec_index. A&. A& self! i!)))))
(set-info :comment ";; Function-Axioms vstd::seq::impl&%0::spec_index")
(assert (fuel_bool_default fuel%vstd!seq.impl&%0.spec_index.))
(assert (=> (fuel_bool fuel%vstd!seq.impl&%0.spec_index.) (forall ((A&. Dcr) (A& Type) (self! Poly) (i! Poly)) (! (= (vstd!seq.impl&%0.spec_index.? A&. A& self! i!) (vstd!seq.Seq.index.? A&. A& self! i!)) :pattern ((vstd!seq.impl&%0.spec_index.? A&. A& self! i!))))))
(assert (forall ((A&. Dcr) (A& Type) (self! Poly) (i! Poly)) (! (=> (and (has_type self! (TYPE%vstd!seq.Seq. A&. A&)) (has_type i! INT)) (has_type (vstd!seq.impl&%0.spec_index.? A&. A& self! i!) A&)) :pattern ((vstd!seq.impl&%0.spec_index.? A&. A& self! i!)))))
(set-info :comment ";; Broadcast vstd::seq::axiom_seq_index_decreases")
(assert (=> (fuel_bool fuel%vstd!seq.axiom_seq_index_decreases.) (forall ((A&. Dcr) (A& Type) (s! Poly) (i! Poly)) (! (=> (and (has_type s! (TYPE%vstd!seq.Seq. A&. A&)) (has_type i! INT)) (=> (and (<= 0 (%I i!)) (< (%I i!) (vstd!seq.Seq.len.? A&. A& s!))) (height_lt (height (vstd!seq.Seq.index.? A&. A& s! i!)) (height s!)))) :pattern ((height (vstd!seq.Seq.index.? A&. A& s! i!)))))))
(set-info :comment ";; Broadcast vstd::seq::axiom_seq_new_len")
(assert (=> (fuel_bool fuel%vstd!seq.axiom_seq_new_len.) (forall ((A&. Dcr) (A& Type) (len! Poly) (f! Poly)) (! (=> (and (has_type len! NAT) (has_type f! (TYPE%fun%1. $ INT A&. A&))) (= (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.new.? A&. A& $ (TYPE%fun%1. $ INT A&. A&) len! f!)) (%I len!))) :pattern ((vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.new.? A&. A& $ (TYPE%fun%1. $ INT A&. A&) len! f!)))))))
(set-info :comment ";; Broadcast vstd::seq::axiom_seq_new_index")
(assert (=> (fuel_bool fuel%vstd!seq.axiom_seq_new_index.) (forall ((A&. Dcr) (A& Type) (len! Poly) (f! Poly) (i! Poly)) (! (=> (and (has_type len! NAT) (has_type f! (TYPE%fun%1. $ INT A&. A&)) (has_type i! INT)) (=> (and (<= 0 (%I i!)) (< (%I i!) (%I len!))) (= (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.new.? A&. A& $ (TYPE%fun%1. $ INT A&. A&) len! f!) i!) (%%apply%%0 (%Poly%fun%1. f!) i!)))) :pattern ((vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.new.? A&. A& $ (TYPE%fun%1. $ INT A&. A&) len! f!) i!))))))
(set-info :comment ";; Broadcast vstd::seq::axiom_seq_ext_equal")
(assert (=> (fuel_bool fuel%vstd!seq.axiom_seq_ext_equal.) (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly)) (! (=> (and (has_type s1! (TYPE%vstd!seq.Seq. A&. A&)) (has_type s2! (TYPE%vstd!seq.Seq. A&. A&))) (= (ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) (and (= (vstd!seq.Seq.len.? A&. A& s1!) (vstd!seq.Seq.len.? A&. A& s2!)) (forall ((i$ Poly)) (! (=> (has_type i$ INT) (=> (and (<= 0 (%I i$)) (< (%I i$) (vstd!seq.Seq.len.? A&. A& s1!))) (= (vstd!seq.Seq.index.? A&. A& s1! i$) (vstd!seq.Seq.index.? A&. A& s2! i$)))) :pattern ((vstd!seq.Seq.index.? A&. A& s1! i$)) :pattern ((vstd!seq.Seq.index.? A&. A& s2! i$))))))) :pattern ((ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!))))))
(set-info :comment ";; Broadcast vstd::seq::axiom_seq_ext_equal_deep")
(assert (=> (fuel_bool fuel%vstd!seq.axiom_seq_ext_equal_deep.) (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly)) (! (=> (and (has_type s1! (TYPE%vstd!seq.Seq. A&. A&)) (has_type s2! (TYPE%vstd!seq.Seq. A&. A&))) (= (ext_eq true (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) (and (= (vstd!seq.Seq.len.? A&. A& s1!) (vstd!seq.Seq.len.? A&. A& s2!)) (forall ((i$ Poly)) (! (=> (has_type i$ INT) (=> (and (<= 0 (%I i$)) (< (%I i$) (vstd!seq.Seq.len.? A&. A& s1!))) (ext_eq true A& (vstd!seq.Seq.index.? A&. A& s1! i$) (vstd!seq.Seq.index.? A&. A& s2! i$)))) :pattern ((vstd!seq.Seq.index.? A&. A& s1! i$)) :pattern ((vstd!seq.Seq.index.? A&. A& s2! i$))))))) :pattern ((ext_eq true (TYPE%vstd!seq.Seq. A&. A&) s1! s2!))))))
(set-info :comment ";; Function-Axioms vstd::seq_lib::impl&%0::no_duplicates")
(assert (fuel_bool_default fuel%vstd!seq_lib.impl&%0.no_duplicates.))
(assert (=> (fuel_bool fuel%vstd!seq_lib.impl&%0.no_duplicates.) (forall ((A&. Dcr) (A& Type) (self! Poly)) (! (= (vstd!seq_lib.impl&%0.no_duplicates.? A&. A& self!) (forall ((i$ Poly) (j$ Poly)) (! (=> (and (has_type i$ INT) (has_type j$ INT)) (=> (and (and (and (<= 0 (%I i$)) (< (%I i$) (vstd!seq.Seq.len.? A&. A& self!))) (and (<= 0 (%I j$)) (< (%I j$) (vstd!seq.Seq.len.? A&. A& self!)))) (not (= i$ j$))) (not (= (vstd!seq.Seq.index.? A&. A& self! i$) (vstd!seq.Seq.index.? A&. A& self! j$))))) :pattern ((vstd!seq.Seq.index.? A&. A& self! i$) (vstd!seq.Seq.index.? A&. A& self! j$))))) :pattern ((vstd!seq_lib.impl&%0.no_duplicates.? A&. A& self!))))))
(set-info :comment ";; Function-Axioms lib::define::MEM_4k_MASK")
(assert (fuel_bool_default fuel%lib!define.MEM_4k_MASK.))
(assert (=> (fuel_bool fuel%lib!define.MEM_4k_MASK.) (= lib!define.MEM_4k_MASK.? 281474976706560)))
(assert (uInv 64 lib!define.MEM_4k_MASK.?))
(set-info :comment ";; Function-Axioms lib::define::KERNEL_MEM_END_L4INDEX")
(assert (fuel_bool_default fuel%lib!define.KERNEL_MEM_END_L4INDEX.))
(assert (=> (fuel_bool fuel%lib!define.KERNEL_MEM_END_L4INDEX.) (= lib!define.KERNEL_MEM_END_L4INDEX.? 1)))
(assert (uInv SZ lib!define.KERNEL_MEM_END_L4INDEX.?))
(set-info :comment ";; Function-Axioms lib::util::page_ptr_util_u::spec_va_4k_valid")
(assert (fuel_bool_default fuel%lib!util.page_ptr_util_u.spec_va_4k_valid.))
(assert (=> (fuel_bool fuel%lib!util.page_ptr_util_u.spec_va_4k_valid.) (forall ((va! Poly)) (! (= (lib!util.page_ptr_util_u.spec_va_4k_valid.? va!) (and (= (uClip SZ (bitand (I (%I va!)) (I (uClip SZ (uClip 64 (bitnot (I lib!define.MEM_4k_MASK.?))))))) 0) (>= (uClip 64 (bitand (I (uClip 64 (bitshr (I (uClip 64 (%I va!))) (I 39)))) (I 511))) (uClip 64 lib!define.KERNEL_MEM_END_L4INDEX.?)))) :pattern ((lib!util.page_ptr_util_u.spec_va_4k_valid.? va!))))))
(set-info :comment ";; Function-Axioms lib::va_range::VaRange4K::view")
(assert (fuel_bool_default fuel%lib!va_range.impl&%2.view.))
(assert (=> (fuel_bool fuel%lib!va_range.impl&%2.view.) (forall ((self! Poly)) (! (= (lib!va_range.impl&%2.view.? self!) (lib!va_range.VaRange4K./VaRange4K/view (%Poly%lib!va_range.VaRange4K. self!))) :pattern ((lib!va_range.impl&%2.view.? self!))))))
(set-info :comment ";; Function-Axioms lib::util::page_ptr_util_u::spec_va_add_range")
(assert (fuel_bool_default fuel%lib!util.page_ptr_util_u.spec_va_add_range.))
(assert (=> (fuel_bool fuel%lib!util.page_ptr_util_u.spec_va_add_range.) (forall ((va! Poly) (i! Poly)) (! (= (lib!util.page_ptr_util_u.spec_va_add_range.? va! i!) (uClip SZ (Add (%I va!) (Mul (%I i!) 4096)))) :pattern ((lib!util.page_ptr_util_u.spec_va_add_range.? va! i!))))))
(assert (forall ((va! Poly) (i! Poly)) (! (=> (and (has_type va! (UINT SZ)) (has_type i! (UINT SZ))) (uInv SZ (lib!util.page_ptr_util_u.spec_va_add_range.? va! i!))) :pattern ((lib!util.page_ptr_util_u.spec_va_add_range.? va! i!)))))
(set-info :comment ";; Function-Axioms lib::va_range::VaRange4K::view_match_spec")
(assert (fuel_bool_default fuel%lib!va_range.impl&%2.view_match_spec.))
(assert (=> (fuel_bool fuel%lib!va_range.impl&%2.view_match_spec.) (forall ((self! Poly)) (! (= (lib!va_range.impl&%2.view_match_spec.? self!) (forall ((i$ Poly)) (! (=> (has_type i$ (UINT SZ)) (=> (and (<= 0 (%I i$)) (< (%I i$) (lib!va_range.VaRange4K./VaRange4K/len (%Poly%lib!va_range.VaRange4K. self!)))) (= (lib!util.page_ptr_util_u.spec_va_add_range.? (I (lib!va_range.VaRange4K./VaRange4K/start (%Poly%lib!va_range.VaRange4K. self!))) i$) (%I (vstd!seq.Seq.index.? $ (UINT SZ) (Poly%vstd!seq.Seq<usize.>. (lib!va_range.impl&%2.view.? self!)) i$))))) :pattern ((lib!util.page_ptr_util_u.spec_va_add_range.? (I (lib!va_range.VaRange4K./VaRange4K/start (%Poly%lib!va_range.VaRange4K. self!))) i$))))) :pattern ((lib!va_range.impl&%2.view_match_spec.? self!))))))
(set-info :comment ";; Function-Axioms lib::va_range::VaRange4K::wf")
(assert (fuel_bool_default fuel%lib!va_range.impl&%2.wf.))
(assert (=> (fuel_bool fuel%lib!va_range.impl&%2.wf.) (forall ((self! Poly)) (! (= (lib!va_range.impl&%2.wf.? self!) (and (and (and (and (and (< (Add (lib!va_range.VaRange4K./VaRange4K/start (%Poly%lib!va_range.VaRange4K. self!)) (Mul (lib!va_range.VaRange4K./VaRange4K/len (%Poly%lib!va_range.VaRange4K. self!)) 4096)) (- (uHi SZ) 1)) (lib!util.page_ptr_util_u.spec_va_4k_valid.? (I (lib!va_range.VaRange4K./VaRange4K/start (%Poly%lib!va_range.VaRange4K. self!))))) (= (vstd!seq.Seq.len.? $ (UINT SZ) (Poly%vstd!seq.Seq<usize.>. (lib!va_range.impl&%2.view.? self!))) (lib!va_range.VaRange4K./VaRange4K/len (%Poly%lib!va_range.VaRange4K. self!)))) (vstd!seq_lib.impl&%0.no_duplicates.? $ (UINT SZ) (Poly%vstd!seq.Seq<usize.>. (lib!va_range.impl&%2.view.? self!)))) (forall ((i$ Poly)) (! (=> (has_type i$ INT) (=> (and (<= 0 (%I i$)) (< (%I i$) (lib!va_range.VaRange4K./VaRange4K/len (%Poly%lib!va_range.VaRange4K. self!)))) (lib!util.page_ptr_util_u.spec_va_4k_valid.? (vstd!seq.Seq.index.? $ (UINT SZ) (Poly%vstd!seq.Seq<usize.>. (lib!va_range.impl&%2.view.? self!)) i$)))) :pattern ((vstd!seq.Seq.index.? $ (UINT SZ) (Poly%vstd!seq.Seq<usize.>. (lib!va_range.impl&%2.view.? self!)) i$))))) (lib!va_range.impl&%2.view_match_spec.? self!))) :pattern ((lib!va_range.impl&%2.wf.? self!))))))
(set-info :comment ";; Function-Specs lib::util::page_ptr_util_u::va_add_range")
(declare-fun ens%lib!util.page_ptr_util_u.va_add_range. (Int Int Int) Bool)
(assert (forall ((va! Int) (i! Int) (ret! Int)) (! (= (ens%lib!util.page_ptr_util_u.va_add_range. va! i! ret!) (and (uInv SZ ret!) (= ret! (lib!util.page_ptr_util_u.spec_va_add_range.? (I va!) (I i!))) (=> (not (= i! 0)) (not (= ret! va!))))) :pattern ((ens%lib!util.page_ptr_util_u.va_add_range. va! i! ret!)))))
(set-info :comment ";; Function-Axioms lib::util::page_ptr_util_u::spec_va_4k_range_valid")
(assert (fuel_bool_default fuel%lib!util.page_ptr_util_u.spec_va_4k_range_valid.))
(assert (=> (fuel_bool fuel%lib!util.page_ptr_util_u.spec_va_4k_range_valid.) (forall ((va! Poly) (len! Poly)) (! (= (lib!util.page_ptr_util_u.spec_va_4k_range_valid.? va! len!) (forall ((i$ Poly)) (! (=> (has_type i$ (UINT SZ)) (=> (and (<= 0 (%I i$)) (< (%I i$) (%I len!))) (lib!util.page_ptr_util_u.spec_va_4k_valid.? (I (lib!util.page_ptr_util_u.spec_va_add_range.? va! i$))))) :pattern ((lib!util.page_ptr_util_u.spec_va_add_range.? va! i$))))) :pattern ((lib!util.page_ptr_util_u.spec_va_4k_range_valid.? va! len!))))))
(set-info :comment ";; Function-Specs lib::util::page_ptr_util_u::va_range_lemma")
(declare-fun ens%lib!util.page_ptr_util_u.va_range_lemma. (Int) Bool)
(assert (forall ((no%param Int)) (! (= (ens%lib!util.page_ptr_util_u.va_range_lemma. no%param) (forall ((va$ Poly) (len$ Poly) (i$ Poly) (j$ Poly)) (! (=> (and (has_type va$ (UINT SZ)) (has_type len$ (UINT SZ)) (has_type i$ (UINT SZ)) (has_type j$ (UINT SZ))) (=> (and (and (and (lib!util.page_ptr_util_u.spec_va_4k_valid.? va$) (lib!util.page_ptr_util_u.spec_va_4k_range_valid.? va$ len$)) (and (<= 0 (%I i$)) (< (%I i$) (%I len$)))) (and (<= 0 (%I i$)) (< (%I i$) (%I len$)))) (= (= i$ j$) (= (lib!util.page_ptr_util_u.spec_va_add_range.? va$ i$) (lib!util.page_ptr_util_u.spec_va_add_range.? va$ j$))))) :pattern ((lib!util.page_ptr_util_u.spec_va_4k_range_valid.? va$ len$) (lib!util.page_ptr_util_u.spec_va_add_range.? va$ i$) (lib!util.page_ptr_util_u.spec_va_add_range.? va$ j$))))) :pattern ((ens%lib!util.page_ptr_util_u.va_range_lemma. no%param)))))
(set-info :comment ";; Function-Axioms lib::va_range::spec_va_range_disjoint")
(assert (fuel_bool_default fuel%lib!va_range.spec_va_range_disjoint.))
(assert (=> (fuel_bool fuel%lib!va_range.spec_va_range_disjoint.) (forall ((va_range_1! Poly) (va_range_2! Poly)) (! (= (lib!va_range.spec_va_range_disjoint.? va_range_1! va_range_2!) (forall ((i$ Poly) (j$ Poly)) (! (=> (and (has_type i$ INT) (has_type j$ INT)) (=> (and (and (<= 0 (%I i$)) (< (%I i$) (lib!va_range.VaRange4K./VaRange4K/len (%Poly%lib!va_range.VaRange4K. va_range_1!)))) (and (<= 0 (%I j$)) (< (%I j$) (lib!va_range.VaRange4K./VaRange4K/len (%Poly%lib!va_range.VaRange4K. va_range_2!))))) (not (= (vstd!seq.Seq.index.? $ (UINT SZ) (Poly%vstd!seq.Seq<usize.>. (lib!va_range.impl&%2.view.? va_range_1!)) i$) (vstd!seq.Seq.index.? $ (UINT SZ) (Poly%vstd!seq.Seq<usize.>. (lib!va_range.impl&%2.view.? va_range_2!)) j$))))) :pattern ((vstd!seq.Seq.index.? $ (UINT SZ) (Poly%vstd!seq.Seq<usize.>. (lib!va_range.impl&%2.view.? va_range_1!)) i$) (vstd!seq.Seq.index.? $ (UINT SZ) (Poly%vstd!seq.Seq<usize.>. (lib!va_range.impl&%2.view.? va_range_2!)) j$))))) :pattern ((lib!va_range.spec_va_range_disjoint.? va_range_1! va_range_2!))))))
(set-info :comment ";; Function-Specs lib::va_range::va_range_disjoint")
(declare-fun req%lib!va_range.va_range_disjoint. (lib!va_range.VaRange4K. lib!va_range.VaRange4K.) Bool)
(declare-const %%global_location_label%%2 Bool)
(declare-const %%global_location_label%%3 Bool)
(assert (forall ((va_range_1! lib!va_range.VaRange4K.) (va_range_2! lib!va_range.VaRange4K.)) (! (= (req%lib!va_range.va_range_disjoint. va_range_1! va_range_2!) (and (=> %%global_location_label%%2 (lib!va_range.impl&%2.wf.? (Poly%lib!va_range.VaRange4K. va_range_1!))) (=> %%global_location_label%%3 (lib!va_range.impl&%2.wf.? (Poly%lib!va_range.VaRange4K. va_range_2!))))) :pattern ((req%lib!va_range.va_range_disjoint. va_range_1! va_range_2!)))))
(declare-fun ens%lib!va_range.va_range_disjoint. (lib!va_range.VaRange4K. lib!va_range.VaRange4K. Bool) Bool)
(assert (forall ((va_range_1! lib!va_range.VaRange4K.) (va_range_2! lib!va_range.VaRange4K.) (ret! Bool)) (! (= (ens%lib!va_range.va_range_disjoint. va_range_1! va_range_2! ret!) (= ret! (lib!va_range.spec_va_range_disjoint.? (Poly%lib!va_range.VaRange4K. va_range_1!) (Poly%lib!va_range.VaRange4K. va_range_2!)))) :pattern ((ens%lib!va_range.va_range_disjoint. va_range_1! va_range_2! ret!)))))
(set-info :comment ";; Function-Specs lib::va_range::VaRange4K::va_range_lemma")
(declare-fun req%lib!va_range.impl&%2.va_range_lemma. (lib!va_range.VaRange4K.) Bool)
(declare-const %%global_location_label%%4 Bool)
(assert (forall ((self! lib!va_range.VaRange4K.)) (! (= (req%lib!va_range.impl&%2.va_range_lemma. self!) (=> %%global_location_label%%4 (lib!va_range.impl&%2.wf.? (Poly%lib!va_range.VaRange4K. self!)))) :pattern ((req%lib!va_range.impl&%2.va_range_lemma. self!)))))
(declare-fun ens%lib!va_range.impl&%2.va_range_lemma. (lib!va_range.VaRange4K.) Bool)
(assert (forall ((self! lib!va_range.VaRange4K.)) (! (= (ens%lib!va_range.impl&%2.va_range_lemma. self!) (and (forall ((i$ Poly)) (! (=> (has_type i$ (UINT SZ)) (=> (and (<= 0 (%I i$)) (< (%I i$) (lib!va_range.VaRange4K./VaRange4K/len (%Poly%lib!va_range.VaRange4K. (Poly%lib!va_range.VaRange4K. self!))))) (= (%I (vstd!seq.Seq.index.? $ (UINT SZ) (Poly%vstd!seq.Seq<usize.>. (lib!va_range.impl&%2.view.? (Poly%lib!va_range.VaRange4K. self!))) i$)) (lib!util.page_ptr_util_u.spec_va_add_range.? (I (lib!va_range.VaRange4K./VaRange4K/start (%Poly%lib!va_range.VaRange4K. (Poly%lib!va_range.VaRange4K. self!)))) i$)))) :pattern ((vstd!seq.Seq.index.? $ (UINT SZ) (Poly%vstd!seq.Seq<usize.>. (lib!va_range.impl&%2.view.? (Poly%lib!va_range.VaRange4K. self!))) i$)) :pattern ((lib!util.page_ptr_util_u.spec_va_add_range.? (I (lib!va_range.VaRange4K./VaRange4K/start (%Poly%lib!va_range.VaRange4K. (Poly%lib!va_range.VaRange4K. self!)))) i$)))) (forall ((i$ Poly)) (! (=> (has_type i$ (UINT SZ)) (=> (and (<= 0 (%I i$)) (< (%I i$) (lib!va_range.VaRange4K./VaRange4K/len (%Poly%lib!va_range.VaRange4K. (Poly%lib!va_range.VaRange4K. self!))))) (= (%I (vstd!seq.Seq.index.? $ (UINT SZ) (Poly%vstd!seq.Seq<usize.>. (lib!va_range.impl&%2.view.? (Poly%lib!va_range.VaRange4K. self!))) i$)) (Add (lib!va_range.VaRange4K./VaRange4K/start (%Poly%lib!va_range.VaRange4K. (Poly%lib!va_range.VaRange4K. self!))) (Mul (%I i$) 4096))))) :pattern ((vstd!seq.Seq.index.? $ (UINT SZ) (Poly%vstd!seq.Seq<usize.>. (lib!va_range.impl&%2.view.? (Poly%lib!va_range.VaRange4K. self!))) i$)))))) :pattern ((ens%lib!va_range.impl&%2.va_range_lemma. self!)))))
(set-info :comment ";; Function-Specs lib::va_range::VaRange4K::index")
(declare-fun req%lib!va_range.impl&%2.index. (lib!va_range.VaRange4K. Int) Bool)
(declare-const %%global_location_label%%5 Bool)
(declare-const %%global_location_label%%6 Bool)
(assert (forall ((self! lib!va_range.VaRange4K.) (i! Int)) (! (= (req%lib!va_range.impl&%2.index. self! i!) (and (=> %%global_location_label%%5 (lib!va_range.impl&%2.wf.? (Poly%lib!va_range.VaRange4K. self!))) (=> %%global_location_label%%6 (and (<= 0 i!) (< i! (lib!va_range.VaRange4K./VaRange4K/len (%Poly%lib!va_range.VaRange4K. (Poly%lib!va_range.VaRange4K. self!)))))))) :pattern ((req%lib!va_range.impl&%2.index. self! i!)))))
(declare-fun ens%lib!va_range.impl&%2.index. (lib!va_range.VaRange4K. Int Int) Bool)
(assert (forall ((self! lib!va_range.VaRange4K.) (i! Int) (ret! Int)) (! (= (ens%lib!va_range.impl&%2.index. self! i! ret!) (and (uInv SZ ret!) (= ret! (%I (vstd!seq.Seq.index.? $ (UINT SZ) (Poly%vstd!seq.Seq<usize.>. (lib!va_range.impl&%2.view.? (Poly%lib!va_range.VaRange4K. self!))) (I i!)))))) :pattern ((ens%lib!va_range.impl&%2.index. self! i! ret!)))))
(set-info :comment ";; Function-Def lib::va_range::VaRange4K::index")
(set-info :comment ";; va_range.rs:131:5: 131:47 (#0)")
(set-info :comment ";; Function-Specs lib::va_range::VaRange4K::new")
(declare-fun req%lib!va_range.impl&%2.new. (Int Int) Bool)
(declare-const %%global_location_label%%7 Bool)
(declare-const %%global_location_label%%8 Bool)
(declare-const %%global_location_label%%9 Bool)
(assert (forall ((va! Int) (len! Int)) (! (= (req%lib!va_range.impl&%2.new. va! len!) (and (=> %%global_location_label%%7 (lib!util.page_ptr_util_u.spec_va_4k_valid.? (I va!))) (=> %%global_location_label%%8 (lib!util.page_ptr_util_u.spec_va_4k_range_valid.? (I va!) (I len!))) (=> %%global_location_label%%9 (< va! (Sub (- (uHi SZ) 1) (Mul len! 4096)))))) :pattern ((req%lib!va_range.impl&%2.new. va! len!)))))
(declare-fun ens%lib!va_range.impl&%2.new. (Int Int lib!va_range.VaRange4K.) Bool)
(assert (forall ((va! Int) (len! Int) (ret! lib!va_range.VaRange4K.)) (! (= (ens%lib!va_range.impl&%2.new. va! len! ret!) (and (has_type (Poly%lib!va_range.VaRange4K. ret!) TYPE%lib!va_range.VaRange4K.) (lib!va_range.impl&%2.wf.? (Poly%lib!va_range.VaRange4K. ret!)) (= (lib!va_range.VaRange4K./VaRange4K/start (%Poly%lib!va_range.VaRange4K. (Poly%lib!va_range.VaRange4K. ret!))) va!) (= (lib!va_range.VaRange4K./VaRange4K/len (%Poly%lib!va_range.VaRange4K. (Poly%lib!va_range.VaRange4K. ret!))) len!))) :pattern ((ens%lib!va_range.impl&%2.new. va! len! ret!)))))
(set-info :comment ";; Function-Def lib::va_range::VaRange4K::new")
(set-info :comment ";; va_range.rs:113:5: 113:49 (#0)")
(declare-const ret! lib!va_range.VaRange4K.)
(declare-const va! Int)
(declare-const len! Int)
(declare-const seq@ vstd!seq.Seq<usize.>.)
(assert fuel_defaults)
(assert (uInv SZ va!))
(assert (uInv SZ len!))
(assert (lib!util.page_ptr_util_u.spec_va_4k_valid.? (I va!)))
(assert (lib!util.page_ptr_util_u.spec_va_4k_range_valid.? (I va!) (I len!)))
(assert (< va! (Sub (- (uHi SZ) 1) (Mul len! 4096))))
(declare-fun %%lambda%%0 (Int Poly) %%Function%%)
(assert (forall ((%%hole%%0 Int) (%%hole%%1 Poly) (i$ Poly)) (! (= (%%apply%%0 (%%lambda%%0 %%hole%%0 %%hole%%1) i$) (I (lib!util.page_ptr_util_u.spec_va_add_range.? %%hole%%1 (I (uClip %%hole%%0 (%I i$)))))) :pattern ((%%apply%%0 (%%lambda%%0 %%hole%%0 %%hole%%1) i$)))))
(set-info :comment ";; postcondition not satisfied")
(declare-const %%location_label%%0 Bool)
(set-info :comment ";; postcondition not satisfied")
(declare-const %%location_label%%1 Bool)
(set-info :comment ";; postcondition not satisfied")
(declare-const %%location_label%%2 Bool)
(assert (not (=> (ens%lib!util.page_ptr_util_u.va_range_lemma. 0) (=> (= seq@ (%Poly%vstd!seq.Seq<usize.>. (vstd!seq.Seq.new.? $ (UINT SZ) $ (TYPE%fun%1. $ INT $ (UINT SZ)) (I len!) (Poly%fun%1. (mk_fun (%%lambda%%0 SZ (I va!))))))) (=> (= ret! (lib!va_range.VaRange4K./VaRange4K (%I (I va!)) (%I (I len!)) (%Poly%vstd!seq.Seq<usize.>. (Poly%vstd!seq.Seq<usize.>. seq@)))) (and (=> %%location_label%%0 (lib!va_range.impl&%2.wf.? (Poly%lib!va_range.VaRange4K. ret!))) (and (=> %%location_label%%1 (= (lib!va_range.VaRange4K./VaRange4K/start (%Poly%lib!va_range.VaRange4K. (Poly%lib!va_range.VaRange4K. ret!))) va!)) (=> %%location_label%%2 (= (lib!va_range.VaRange4K./VaRange4K/len (%Poly%lib!va_range.VaRange4K. (Poly%lib!va_range.VaRange4K. ret!))) len!)))))))))
(check-sat)
(exit)
