(set-info :smt-lib-version 2.6)
(set-logic UFDTNIA)
(set-info :source |
Generated by: Amar Shah
Generated on: 2024-12-11
Generator: Verus
Application: Verification of Rust Program
Target solver: z3
Time limit: 10
Benchmarks generated by the Rust verifier Verus (https://verus-lang.github.io/verus/guide/) on the project Verus Systems (https://dl.acm.org/doi/10.1145/3694715.3695952) and processed using Mariposa (https://github.com/secure-foundations/mariposa). z3 solves this without nonlinear, but it cannot be expressed in SMTLib without a nonlinear theory.
|)
(set-info :license "https://creativecommons.org/licenses/by/4.0/")
(set-info :category "industrial")
(set-info :status unsat)
(set-option :auto_config false)
(set-option :smt.mbqi false)
(set-option :smt.case_split 3)
(set-option :smt.qi.eager_threshold 100.0)
(set-option :smt.delay_units true)
(set-option :smt.arith.solver 2)
(set-option :smt.arith.nl false)
(set-option :pi.enabled false)
(set-option :rewriter.sort_disjunctions false)
(set-info :comment ";; Prelude")
(set-info :comment ";; AIR prelude")
(declare-sort %%Function%% 0)
(declare-sort FuelId 0)
(declare-sort Fuel 0)
(declare-const zero Fuel)
(declare-fun succ (Fuel) Fuel)
(declare-fun fuel_bool (FuelId) Bool)
(declare-fun fuel_bool_default (FuelId) Bool)
(declare-const fuel_defaults Bool)
(assert (=> fuel_defaults (forall ((id FuelId)) (! (= (fuel_bool id) (fuel_bool_default id)) :pattern ((fuel_bool id))))))
(declare-datatypes ((fndef 0)) (((fndef_singleton ))))
(declare-sort Poly 0)
(declare-sort Height 0)
(declare-fun I (Int) Poly)
(declare-fun B (Bool) Poly)
(declare-fun F (fndef) Poly)
(declare-fun %I (Poly) Int)
(declare-fun %B (Poly) Bool)
(declare-fun %F (Poly) fndef)
(declare-sort Type 0)
(declare-const BOOL Type)
(declare-const INT Type)
(declare-const NAT Type)
(declare-const CHAR Type)
(declare-fun UINT (Int) Type)
(declare-fun SINT (Int) Type)
(declare-fun CONST_INT (Int) Type)
(declare-sort Dcr 0)
(declare-const $ Dcr)
(declare-fun REF (Dcr) Dcr)
(declare-fun MUT_REF (Dcr) Dcr)
(declare-fun BOX (Dcr Type Dcr) Dcr)
(declare-fun RC (Dcr Type Dcr) Dcr)
(declare-fun ARC (Dcr Type Dcr) Dcr)
(declare-fun GHOST (Dcr) Dcr)
(declare-fun TRACKED (Dcr) Dcr)
(declare-fun NEVER (Dcr) Dcr)
(declare-fun CONST_PTR (Dcr) Dcr)
(declare-fun ARRAY (Dcr Type Dcr Type) Type)
(declare-fun SLICE (Dcr Type) Type)
(declare-const STRSLICE Type)
(declare-const ALLOCATOR_GLOBAL Type)
(declare-fun PTR (Dcr Type) Type)
(declare-fun has_type (Poly Type) Bool)
(declare-fun as_type (Poly Type) Poly)
(declare-fun mk_fun (%%Function%%) %%Function%%)
(declare-fun const_int (Type) Int)
(assert (forall ((i Int)) (! (= i (const_int (CONST_INT i))) :pattern ((CONST_INT i)))))
(assert (forall ((b Bool)) (! (has_type (B b) BOOL) :pattern ((has_type (B b) BOOL)))))
(assert (forall ((x Poly) (True Type)) (! (and (has_type (as_type x True) True) (=> (has_type x True) (= x (as_type x True)))) :pattern ((as_type x True)))))
(assert (forall ((x %%Function%%)) (! (= (mk_fun x) x) :pattern ((mk_fun x)))))
(assert (forall ((x Bool)) (! (= x (%B (B x))) :pattern ((B x)))))
(assert (forall ((x Int)) (! (= x (%I (I x))) :pattern ((I x)))))
(assert (forall ((x Poly)) (! (=> (has_type x BOOL) (= x (B (%B x)))) :pattern ((has_type x BOOL)))))
(assert (forall ((x Poly)) (! (=> (has_type x INT) (= x (I (%I x)))) :pattern ((has_type x INT)))))
(assert (forall ((x Poly)) (! (=> (has_type x NAT) (= x (I (%I x)))) :pattern ((has_type x NAT)))))
(assert (forall ((bits Int) (x Poly)) (! (=> (has_type x (UINT bits)) (= x (I (%I x)))) :pattern ((has_type x (UINT bits))))))
(assert (forall ((bits Int) (x Poly)) (! (=> (has_type x (SINT bits)) (= x (I (%I x)))) :pattern ((has_type x (SINT bits))))))
(assert (forall ((x Poly)) (! (=> (has_type x CHAR) (= x (I (%I x)))) :pattern ((has_type x CHAR)))))
(declare-fun ext_eq (Bool Type Poly Poly) Bool)
(assert (forall ((deep Bool) (True Type) (x Poly) (y Poly)) (! (= (= x y) (ext_eq deep True x y)) :pattern ((ext_eq deep True x y)))))
(declare-const SZ Int)
(assert (= SZ 64))
(declare-fun uHi (Int) Int)
(declare-fun iLo (Int) Int)
(declare-fun iHi (Int) Int)
(assert (= (uHi 8) 256))
(assert (= (uHi 16) 65536))
(assert (= (uHi 32) 4294967296))
(assert (= (uHi 64) 18446744073709551616))
(assert (= (uHi 128) (+ 1 340282366920938463463374607431768211455)))
(assert (= (iLo 8) (- 128)))
(assert (= (iLo 16) (- 32768)))
(assert (= (iLo 32) (- 2147483648)))
(assert (= (iLo 64) (- 9223372036854775808)))
(assert (= (iLo 128) (- 170141183460469231731687303715884105728)))
(assert (= (iHi 8) 128))
(assert (= (iHi 16) 32768))
(assert (= (iHi 32) 2147483648))
(assert (= (iHi 64) 9223372036854775808))
(assert (= (iHi 128) 170141183460469231731687303715884105728))
(declare-fun nClip (Int) Int)
(declare-fun uClip (Int Int) Int)
(declare-fun iClip (Int Int) Int)
(declare-fun charClip (Int) Int)
(assert (forall ((i Int)) (! (and (<= 0 (nClip i)) (=> (<= 0 i) (= i (nClip i)))) :pattern ((nClip i)))))
(assert (forall ((bits Int) (i Int)) (! (and (<= 0 (uClip bits i)) (< (uClip bits i) (uHi bits)) (=> (and (<= 0 i) (< i (uHi bits))) (= i (uClip bits i)))) :pattern ((uClip bits i)))))
(assert (forall ((bits Int) (i Int)) (! (and (<= (iLo bits) (iClip bits i)) (< (iClip bits i) (iHi bits)) (=> (and (<= (iLo bits) i) (< i (iHi bits))) (= i (iClip bits i)))) :pattern ((iClip bits i)))))
(assert (forall ((i Int)) (! (and (or (and (<= 0 (charClip i)) (<= (charClip i) 55295)) (and (<= 57344 (charClip i)) (<= (charClip i) 1114111))) (=> (or (and (<= 0 i) (<= i 55295)) (and (<= 57344 i) (<= i 1114111))) (= i (charClip i)))) :pattern ((charClip i)))))
(declare-fun uInv (Int Int) Bool)
(declare-fun iInv (Int Int) Bool)
(declare-fun charInv (Int) Bool)
(assert (forall ((bits Int) (i Int)) (! (= (uInv bits i) (and (<= 0 i) (< i (uHi bits)))) :pattern ((uInv bits i)))))
(assert (forall ((bits Int) (i Int)) (! (= (iInv bits i) (and (<= (iLo bits) i) (< i (iHi bits)))) :pattern ((iInv bits i)))))
(assert (forall ((i Int)) (! (= (charInv i) (or (and (<= 0 i) (<= i 55295)) (and (<= 57344 i) (<= i 1114111)))) :pattern ((charInv i)))))
(assert (forall ((x Int)) (! (has_type (I x) INT) :pattern ((has_type (I x) INT)))))
(assert (forall ((x Int)) (! (=> (<= 0 x) (has_type (I x) NAT)) :pattern ((has_type (I x) NAT)))))
(assert (forall ((bits Int) (x Int)) (! (=> (uInv bits x) (has_type (I x) (UINT bits))) :pattern ((has_type (I x) (UINT bits))))))
(assert (forall ((bits Int) (x Int)) (! (=> (iInv bits x) (has_type (I x) (SINT bits))) :pattern ((has_type (I x) (SINT bits))))))
(assert (forall ((x Int)) (! (=> (charInv x) (has_type (I x) CHAR)) :pattern ((has_type (I x) CHAR)))))
(assert (forall ((x Poly)) (! (=> (has_type x NAT) (<= 0 (%I x))) :pattern ((has_type x NAT)))))
(assert (forall ((bits Int) (x Poly)) (! (=> (has_type x (UINT bits)) (uInv bits (%I x))) :pattern ((has_type x (UINT bits))))))
(assert (forall ((bits Int) (x Poly)) (! (=> (has_type x (SINT bits)) (iInv bits (%I x))) :pattern ((has_type x (SINT bits))))))
(declare-fun Add (Int Int) Int)
(declare-fun Sub (Int Int) Int)
(declare-fun Mul (Int Int) Int)
(declare-fun EucDiv (Int Int) Int)
(declare-fun EucMod (Int Int) Int)
(assert (forall ((x Int) (y Int)) (! (= (Add x y) (+ x y)) :pattern ((Add x y)))))
(assert (forall ((x Int) (y Int)) (! (= (Sub x y) (- x y)) :pattern ((Sub x y)))))
(assert (forall ((x Int) (y Int)) (! (= (Mul x y) (* x y)) :pattern ((Mul x y)))))
(assert (forall ((x Int) (y Int)) (! (= (EucDiv x y) (div x y)) :pattern ((EucDiv x y)))))
(assert (forall ((x Int) (y Int)) (! (= (EucMod x y) (mod x y)) :pattern ((EucMod x y)))))
(assert (forall ((x Int) (y Int)) (! (=> (and (<= 0 x) (<= 0 y)) (<= 0 (Mul x y))) :pattern ((Mul x y)))))
(assert (forall ((x Int) (y Int)) (! (=> (and (<= 0 x) (< 0 y)) (and (<= 0 (EucDiv x y)) (<= (EucDiv x y) x))) :pattern ((EucDiv x y)))))
(assert (forall ((x Int) (y Int)) (! (=> (and (<= 0 x) (< 0 y)) (and (<= 0 (EucMod x y)) (< (EucMod x y) y))) :pattern ((EucMod x y)))))
(declare-fun bitxor (Poly Poly) Int)
(declare-fun bitand (Poly Poly) Int)
(declare-fun bitor (Poly Poly) Int)
(declare-fun bitshr (Poly Poly) Int)
(declare-fun bitshl (Poly Poly) Int)
(declare-fun bitnot (Poly) Int)
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (uInv bits (%I x)) (uInv bits (%I y))) (uInv bits (bitxor x y))) :pattern ((uClip bits (bitxor x y))))))
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (iInv bits (%I x)) (iInv bits (%I y))) (iInv bits (bitxor x y))) :pattern ((iClip bits (bitxor x y))))))
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (uInv bits (%I x)) (uInv bits (%I y))) (uInv bits (bitor x y))) :pattern ((uClip bits (bitor x y))))))
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (iInv bits (%I x)) (iInv bits (%I y))) (iInv bits (bitor x y))) :pattern ((iClip bits (bitor x y))))))
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (uInv bits (%I x)) (uInv bits (%I y))) (uInv bits (bitand x y))) :pattern ((uClip bits (bitand x y))))))
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (iInv bits (%I x)) (iInv bits (%I y))) (iInv bits (bitand x y))) :pattern ((iClip bits (bitand x y))))))
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (uInv bits (%I x)) (<= 0 (%I y))) (uInv bits (bitshr x y))) :pattern ((uClip bits (bitshr x y))))))
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (iInv bits (%I x)) (<= 0 (%I y))) (iInv bits (bitshr x y))) :pattern ((iClip bits (bitshr x y))))))
(declare-fun singular_mod (Int Int) Int)
(assert (forall ((x Int) (y Int)) (! (=> (not (= y 0)) (= (EucMod x y) (singular_mod x y))) :pattern ((singular_mod x y)))))
(declare-fun closure_req (Type Dcr Type Poly Poly) Bool)
(declare-fun closure_ens (Type Dcr Type Poly Poly Poly) Bool)
(declare-fun height (Poly) Height)
(declare-fun height_lt (Height Height) Bool)
(declare-fun fun_from_recursive_field (Poly) Poly)
(declare-fun check_decrease_int (Int Int Bool) Bool)
(assert (forall ((cur Int) (prev Int) (otherwise Bool)) (! (= (check_decrease_int cur prev otherwise) (or (and (<= 0 cur) (< cur prev)) (and (= cur prev) otherwise))) :pattern ((check_decrease_int cur prev otherwise)))))
(declare-fun check_decrease_height (Poly Poly Bool) Bool)
(assert (forall ((cur Poly) (prev Poly) (otherwise Bool)) (! (= (check_decrease_height cur prev otherwise) (or (height_lt (height cur) (height prev)) (and (= (height cur) (height prev)) otherwise))) :pattern ((check_decrease_height cur prev otherwise)))))
(declare-fun partial-order (Height Height) Bool)
(assert (forall ((x Height)) (partial-order x x)))
(assert (forall ((x Height) (y Height)) (=> (and (partial-order x y) (partial-order y x)) (= x y))))
(assert (forall ((x Height) (y Height) (z Height)) (=> (and (partial-order x y) (partial-order y z)) (partial-order x z))))
(assert (forall ((x Height) (y Height)) (! (= (height_lt x y) (and (partial-order x y) (not (= x y)))) :pattern ((height_lt x y)))))
(set-info :comment ";; MODULE 'module tokens'")
(set-info :comment ";; Fuel")
(declare-const fuel%vstd!array.array_view. FuelId)
(declare-const fuel%vstd!array.impl&%0.view. FuelId)
(declare-const fuel%vstd!array.impl&%2.spec_index. FuelId)
(declare-const fuel%vstd!array.lemma_array_index. FuelId)
(declare-const fuel%vstd!array.array_len_matches_n. FuelId)
(declare-const fuel%vstd!map.impl&%0.spec_index. FuelId)
(declare-const fuel%vstd!map.axiom_map_index_decreases_finite. FuelId)
(declare-const fuel%vstd!map.axiom_map_index_decreases_infinite. FuelId)
(declare-const fuel%vstd!map.axiom_map_ext_equal. FuelId)
(declare-const fuel%vstd!map.axiom_map_ext_equal_deep. FuelId)
(declare-const fuel%vstd!math.max. FuelId)
(declare-const fuel%vstd!raw_ptr.impl&%4.view. FuelId)
(declare-const fuel%vstd!raw_ptr.ptrs_mut_eq. FuelId)
(declare-const fuel%vstd!seq.impl&%0.spec_index. FuelId)
(declare-const fuel%vstd!seq.axiom_seq_index_decreases. FuelId)
(declare-const fuel%vstd!seq.axiom_seq_new_len. FuelId)
(declare-const fuel%vstd!seq.axiom_seq_new_index. FuelId)
(declare-const fuel%vstd!seq.axiom_seq_ext_equal. FuelId)
(declare-const fuel%vstd!seq.axiom_seq_ext_equal_deep. FuelId)
(declare-const fuel%vstd!set.impl&%0.choose. FuelId)
(declare-const fuel%vstd!set.axiom_set_empty. FuelId)
(declare-const fuel%vstd!set.axiom_set_new. FuelId)
(declare-const fuel%vstd!set.axiom_set_insert_same. FuelId)
(declare-const fuel%vstd!set.axiom_set_insert_different. FuelId)
(declare-const fuel%vstd!set.axiom_set_remove_same. FuelId)
(declare-const fuel%vstd!set.axiom_set_remove_insert. FuelId)
(declare-const fuel%vstd!set.axiom_set_remove_different. FuelId)
(declare-const fuel%vstd!set.axiom_set_ext_equal. FuelId)
(declare-const fuel%vstd!set.axiom_set_ext_equal_deep. FuelId)
(declare-const fuel%vstd!set.axiom_set_empty_finite. FuelId)
(declare-const fuel%vstd!set.axiom_set_insert_finite. FuelId)
(declare-const fuel%vstd!set.axiom_set_remove_finite. FuelId)
(declare-const fuel%vstd!set.axiom_set_choose_finite. FuelId)
(declare-const fuel%vstd!set.axiom_set_empty_len. FuelId)
(declare-const fuel%vstd!set.axiom_set_insert_len. FuelId)
(declare-const fuel%vstd!set.axiom_set_remove_len. FuelId)
(declare-const fuel%vstd!set.axiom_set_contains_len. FuelId)
(declare-const fuel%vstd!set.axiom_set_choose_len. FuelId)
(declare-const fuel%vstd!view.impl&%0.view. FuelId)
(declare-const fuel%vstd!view.impl&%2.view. FuelId)
(declare-const fuel%vstd!view.impl&%4.view. FuelId)
(declare-const fuel%vstd!view.impl&%6.view. FuelId)
(declare-const fuel%vstd!view.impl&%10.view. FuelId)
(declare-const fuel%vstd!view.impl&%12.view. FuelId)
(declare-const fuel%vstd!view.impl&%14.view. FuelId)
(declare-const fuel%vstd!view.impl&%16.view. FuelId)
(declare-const fuel%vstd!view.impl&%18.view. FuelId)
(declare-const fuel%vstd!view.impl&%20.view. FuelId)
(declare-const fuel%vstd!view.impl&%24.view. FuelId)
(declare-const fuel%vstd!view.impl&%32.view. FuelId)
(declare-const fuel%vstd!view.impl&%42.view. FuelId)
(declare-const fuel%vstd!view.impl&%46.view. FuelId)
(declare-const fuel%lib!tokens.impl&%0.range_from. FuelId)
(declare-const fuel%lib!tokens.impl&%1.wf. FuelId)
(declare-const fuel%lib!tokens.impl&%1.page_id_for_slice. FuelId)
(declare-const fuel%lib!tokens.impl&%1.get_slice_idx. FuelId)
(declare-const fuel%lib!tokens.impl&%1.slice_idx_is_right. FuelId)
(declare-const fuel%lib!tokens.impl&%2.to_int. FuelId)
(declare-const fuel%lib!tokens.impl&%3.arrow_0. FuelId)
(declare-const fuel%lib!tokens.impl&%3.arrow_2. FuelId)
(declare-const fuel%lib!tokens.impl&%3.arrow_1. FuelId)
(declare-const fuel%lib!tokens.impl&%3.arrow_Heap_0. FuelId)
(declare-const fuel%lib!tokens.impl&%3.arrow_Heap_1. FuelId)
(declare-const fuel%lib!tokens.impl&%3.arrow_Heap_2. FuelId)
(declare-const fuel%lib!tokens.segment_u_max. FuelId)
(declare-const fuel%lib!tokens.segment_get_unused_uniq_field. FuelId)
(declare-const fuel%lib!tokens.heap_u_max. FuelId)
(declare-const fuel%lib!tokens.heap_get_unused_uniq_field. FuelId)
(declare-const fuel%lib!config.SLICE_SIZE. FuelId)
(declare-const fuel%vstd!array.group_array_axioms. FuelId)
(declare-const fuel%vstd!map.group_map_axioms. FuelId)
(declare-const fuel%vstd!multiset.group_multiset_axioms. FuelId)
(declare-const fuel%vstd!raw_ptr.group_raw_ptr_axioms. FuelId)
(declare-const fuel%vstd!seq.group_seq_axioms. FuelId)
(declare-const fuel%vstd!seq_lib.group_seq_lib_default. FuelId)
(declare-const fuel%vstd!set.group_set_axioms. FuelId)
(declare-const fuel%vstd!set_lib.group_set_lib_axioms. FuelId)
(declare-const fuel%vstd!slice.group_slice_axioms. FuelId)
(declare-const fuel%vstd!string.group_string_axioms. FuelId)
(declare-const fuel%vstd!std_specs.bits.group_bits_axioms. FuelId)
(declare-const fuel%vstd!std_specs.control_flow.group_control_flow_axioms. FuelId)
(declare-const fuel%vstd!std_specs.range.group_range_axioms. FuelId)
(declare-const fuel%vstd!std_specs.vec.group_vec_axioms. FuelId)
(declare-const fuel%vstd!group_vstd_default. FuelId)
(assert (distinct fuel%vstd!array.array_view. fuel%vstd!array.impl&%0.view. fuel%vstd!array.impl&%2.spec_index. fuel%vstd!array.lemma_array_index. fuel%vstd!array.array_len_matches_n. fuel%vstd!map.impl&%0.spec_index. fuel%vstd!map.axiom_map_index_decreases_finite. fuel%vstd!map.axiom_map_index_decreases_infinite. fuel%vstd!map.axiom_map_ext_equal. fuel%vstd!map.axiom_map_ext_equal_deep. fuel%vstd!math.max. fuel%vstd!raw_ptr.impl&%4.view. fuel%vstd!raw_ptr.ptrs_mut_eq. fuel%vstd!seq.impl&%0.spec_index. fuel%vstd!seq.axiom_seq_index_decreases. fuel%vstd!seq.axiom_seq_new_len. fuel%vstd!seq.axiom_seq_new_index. fuel%vstd!seq.axiom_seq_ext_equal. fuel%vstd!seq.axiom_seq_ext_equal_deep. fuel%vstd!set.impl&%0.choose. fuel%vstd!set.axiom_set_empty. fuel%vstd!set.axiom_set_new. fuel%vstd!set.axiom_set_insert_same. fuel%vstd!set.axiom_set_insert_different. fuel%vstd!set.axiom_set_remove_same. fuel%vstd!set.axiom_set_remove_insert. fuel%vstd!set.axiom_set_remove_different. fuel%vstd!set.axiom_set_ext_equal. fuel%vstd!set.axiom_set_ext_equal_deep. fuel%vstd!set.axiom_set_empty_finite. fuel%vstd!set.axiom_set_insert_finite. fuel%vstd!set.axiom_set_remove_finite. fuel%vstd!set.axiom_set_choose_finite. fuel%vstd!set.axiom_set_empty_len. fuel%vstd!set.axiom_set_insert_len. fuel%vstd!set.axiom_set_remove_len. fuel%vstd!set.axiom_set_contains_len. fuel%vstd!set.axiom_set_choose_len. fuel%vstd!view.impl&%0.view. fuel%vstd!view.impl&%2.view. fuel%vstd!view.impl&%4.view. fuel%vstd!view.impl&%6.view. fuel%vstd!view.impl&%10.view. fuel%vstd!view.impl&%12.view. fuel%vstd!view.impl&%14.view. fuel%vstd!view.impl&%16.view. fuel%vstd!view.impl&%18.view. fuel%vstd!view.impl&%20.view. fuel%vstd!view.impl&%24.view. fuel%vstd!view.impl&%32.view. fuel%vstd!view.impl&%42.view. fuel%vstd!view.impl&%46.view. fuel%lib!tokens.impl&%0.range_from. fuel%lib!tokens.impl&%1.wf. fuel%lib!tokens.impl&%1.page_id_for_slice. fuel%lib!tokens.impl&%1.get_slice_idx. fuel%lib!tokens.impl&%1.slice_idx_is_right. fuel%lib!tokens.impl&%2.to_int. fuel%lib!tokens.impl&%3.arrow_0. fuel%lib!tokens.impl&%3.arrow_2. fuel%lib!tokens.impl&%3.arrow_1. fuel%lib!tokens.impl&%3.arrow_Heap_0. fuel%lib!tokens.impl&%3.arrow_Heap_1. fuel%lib!tokens.impl&%3.arrow_Heap_2. fuel%lib!tokens.segment_u_max. fuel%lib!tokens.segment_get_unused_uniq_field. fuel%lib!tokens.heap_u_max. fuel%lib!tokens.heap_get_unused_uniq_field. fuel%lib!config.SLICE_SIZE. fuel%vstd!array.group_array_axioms. fuel%vstd!map.group_map_axioms. fuel%vstd!multiset.group_multiset_axioms. fuel%vstd!raw_ptr.group_raw_ptr_axioms. fuel%vstd!seq.group_seq_axioms. fuel%vstd!seq_lib.group_seq_lib_default. fuel%vstd!set.group_set_axioms. fuel%vstd!set_lib.group_set_lib_axioms. fuel%vstd!slice.group_slice_axioms. fuel%vstd!string.group_string_axioms. fuel%vstd!std_specs.bits.group_bits_axioms. fuel%vstd!std_specs.control_flow.group_control_flow_axioms. fuel%vstd!std_specs.range.group_range_axioms. fuel%vstd!std_specs.vec.group_vec_axioms. fuel%vstd!group_vstd_default.))
(assert (=> (fuel_bool_default fuel%vstd!array.group_array_axioms.) (and (fuel_bool_default fuel%vstd!array.array_len_matches_n.) (fuel_bool_default fuel%vstd!array.lemma_array_index.))))
(assert (=> (fuel_bool_default fuel%vstd!map.group_map_axioms.) (and (fuel_bool_default fuel%vstd!map.axiom_map_index_decreases_finite.) (fuel_bool_default fuel%vstd!map.axiom_map_index_decreases_infinite.) (fuel_bool_default fuel%vstd!map.axiom_map_ext_equal.) (fuel_bool_default fuel%vstd!map.axiom_map_ext_equal_deep.))))
(assert (=> (fuel_bool_default fuel%vstd!raw_ptr.group_raw_ptr_axioms.) (fuel_bool_default fuel%vstd!raw_ptr.ptrs_mut_eq.)))
(assert (=> (fuel_bool_default fuel%vstd!seq.group_seq_axioms.) (and (fuel_bool_default fuel%vstd!seq.axiom_seq_index_decreases.) (fuel_bool_default fuel%vstd!seq.axiom_seq_new_len.) (fuel_bool_default fuel%vstd!seq.axiom_seq_new_index.) (fuel_bool_default fuel%vstd!seq.axiom_seq_ext_equal.) (fuel_bool_default fuel%vstd!seq.axiom_seq_ext_equal_deep.))))
(assert (=> (fuel_bool_default fuel%vstd!set.group_set_axioms.) (and (fuel_bool_default fuel%vstd!set.axiom_set_empty.) (fuel_bool_default fuel%vstd!set.axiom_set_new.) (fuel_bool_default fuel%vstd!set.axiom_set_insert_same.) (fuel_bool_default fuel%vstd!set.axiom_set_insert_different.) (fuel_bool_default fuel%vstd!set.axiom_set_remove_same.) (fuel_bool_default fuel%vstd!set.axiom_set_remove_insert.) (fuel_bool_default fuel%vstd!set.axiom_set_remove_different.) (fuel_bool_default fuel%vstd!set.axiom_set_ext_equal.) (fuel_bool_default fuel%vstd!set.axiom_set_ext_equal_deep.) (fuel_bool_default fuel%vstd!set.axiom_set_empty_finite.) (fuel_bool_default fuel%vstd!set.axiom_set_insert_finite.) (fuel_bool_default fuel%vstd!set.axiom_set_remove_finite.) (fuel_bool_default fuel%vstd!set.axiom_set_choose_finite.) (fuel_bool_default fuel%vstd!set.axiom_set_empty_len.) (fuel_bool_default fuel%vstd!set.axiom_set_insert_len.) (fuel_bool_default fuel%vstd!set.axiom_set_remove_len.) (fuel_bool_default fuel%vstd!set.axiom_set_contains_len.) (fuel_bool_default fuel%vstd!set.axiom_set_choose_len.))))
(assert (fuel_bool_default fuel%vstd!group_vstd_default.))
(assert (=> (fuel_bool_default fuel%vstd!group_vstd_default.) (and (fuel_bool_default fuel%vstd!seq.group_seq_axioms.) (fuel_bool_default fuel%vstd!seq_lib.group_seq_lib_default.) (fuel_bool_default fuel%vstd!map.group_map_axioms.) (fuel_bool_default fuel%vstd!set.group_set_axioms.) (fuel_bool_default fuel%vstd!set_lib.group_set_lib_axioms.) (fuel_bool_default fuel%vstd!std_specs.bits.group_bits_axioms.) (fuel_bool_default fuel%vstd!std_specs.control_flow.group_control_flow_axioms.) (fuel_bool_default fuel%vstd!std_specs.vec.group_vec_axioms.) (fuel_bool_default fuel%vstd!slice.group_slice_axioms.) (fuel_bool_default fuel%vstd!array.group_array_axioms.) (fuel_bool_default fuel%vstd!multiset.group_multiset_axioms.) (fuel_bool_default fuel%vstd!string.group_string_axioms.) (fuel_bool_default fuel%vstd!std_specs.range.group_range_axioms.) (fuel_bool_default fuel%vstd!raw_ptr.group_raw_ptr_axioms.))))
(set-info :comment ";; Associated-Type-Decls")
(declare-fun proj%%vstd!view.View./V (Dcr Type) Dcr)
(declare-fun proj%vstd!view.View./V (Dcr Type) Type)
(set-info :comment ";; Datatypes")
(declare-sort lib!commit_mask.CommitMask. 0)
(declare-sort lib!linked_list.LL. 0)
(declare-sort lib!linked_list.StuffAgree.Instance. 0)
(declare-sort lib!linked_list.StuffAgree.x. 0)
(declare-sort lib!linked_list.StuffAgree.y. 0)
(declare-sort lib!tokens.Mim.Instance. 0)
(declare-sort lib!tokens.Mim.delay. 0)
(declare-sort lib!tokens.Mim.heap_of_page. 0)
(declare-sort lib!tokens.Mim.thread_of_segment. 0)
(declare-sort lib!types.BoolAgree.Instance. 0)
(declare-sort lib!types.BoolAgree.x. 0)
(declare-sort lib!types.BoolAgree.y. 0)
(declare-sort vstd!atomic.PAtomicU64. 0)
(declare-sort vstd!atomic.PermissionU64. 0)
(declare-sort vstd!cell.PCell<u32.>. 0)
(declare-sort vstd!cell.PCell<usize.>. 0)
(declare-sort vstd!cell.PCell<lib!types.PageInner.>. 0)
(declare-sort vstd!cell.PCell<lib!types.SegmentHeaderMain.>. 0)
(declare-sort vstd!cell.PCell<lib!types.SegmentHeaderMain2.>. 0)
(declare-sort vstd!cell.PCell<ptr_mut%<lib!types.Page.>.>. 0)
(declare-sort vstd!map.Map<lib!tokens.PageId./lib!tokens.PageState.>. 0)
(declare-sort vstd!map.Map<lib!tokens.SegmentId./lib!tokens.SegmentState.>. 0)
(declare-sort vstd!raw_ptr.DynMetadata. 0)
(declare-sort vstd!raw_ptr.IsExposed. 0)
(declare-sort vstd!raw_ptr.PointsTo<lib!types.Heap.>. 0)
(declare-sort vstd!raw_ptr.PointsTo<lib!types.Page.>. 0)
(declare-sort vstd!raw_ptr.PointsTo<lib!types.SegmentHeader.>. 0)
(declare-sort vstd!raw_ptr.Provenance. 0)
(declare-sort vstd!set.Set<lib!tokens.HeapId.>. 0)
(declare-sort vstd!set.Set<lib!tokens.PageId.>. 0)
(declare-sort vstd!set.Set<lib!tokens.SegmentId.>. 0)
(declare-sort ptr_mut%<lib!linked_list.Node.>. 0)
(declare-sort ptr_mut%<lib!types.Heap.>. 0)
(declare-sort ptr_mut%<lib!types.Page.>. 0)
(declare-sort ptr_mut%<lib!types.SegmentHeader.>. 0)
(declare-sort ptr_mut%<lib!types.Tld.>. 0)
(declare-sort allocator_global%. 0)
(declare-datatypes ((core!option.Option. 0) (vstd!atomic_ghost.AtomicU64. 0) (vstd!atomic_ghost.AtomicPtr. 0) (vstd!raw_ptr.Metadata. 0) (vstd!raw_ptr.PtrData. 0) (vstd!raw_ptr.MemContents. 0) (vstd!raw_ptr.PointsToData. 0) (lib!thread.ThreadId. 0) (lib!tokens.HeapId. 0) (lib!tokens.TldId. 0) (lib!tokens.SegmentId. 0) (lib!tokens.PageId. 0) (lib!tokens.BlockId. 0) (lib!tokens.DelayState. 0) (lib!tokens.PageState. 0) (lib!tokens.SegmentState. 0) (lib!tokens.BlockState. 0) (lib!tokens.HeapState. 0) (lib!tokens.ThreadState. 0) (lib!tokens.ThreadCheckedState. 0) (lib!tokens.Actor. 0) (lib!tokens.DelayFreeingActor. 0) (lib!types.PageInner. 0) (lib!types.AtomicHeapPtr. 0) (lib!types.InvariantPredicate_auto_AtomicHeapPtr_atomic. 0) (lib!types.Page. 0) (lib!types.PageSharedAccess. 0) (lib!types.SegmentKind. 0) (lib!types.SegmentHeaderMain. 0) (lib!types.SegmentHeaderMain2. 0) (lib!types.SegmentHeader. 0) (lib!types.InvariantPredicate_auto_SegmentHeader_thread_id. 0) (lib!types.SegmentSharedAccess. 0) (lib!types.PageQueue. 0) (lib!types.Heap. 0) (lib!types.HeapSharedAccess. 0) (lib!types.SegmentsTld. 0) (lib!types.SpanQueueHeader. 0) (lib!types.Tld. 0) (lib!types.TldPtr. 0) (lib!linked_list.Node. 0) (lib!linked_list.ThreadLLSimple. 0) (lib!linked_list.InvariantPredicate_auto_ThreadLLSimple_atomic. 0) (lib!linked_list.ThreadLLWithDelayBits. 0) (lib!linked_list.InvariantPredicate_auto_ThreadLLWithDelayBits_atomic. 0) (tuple%0. 0) (tuple%2. 0) (tuple%4. 0)) (((core!option.Option./None ) (core!option.Option./Some (core!option.Option./Some/?0 Poly))) ((vstd!atomic_ghost.AtomicU64./AtomicU64 (vstd!atomic_ghost.AtomicU64./AtomicU64/?patomic vstd!atomic.PAtomicU64.) (vstd!atomic_ghost.AtomicU64./AtomicU64/?atomic_inv Poly))) ((vstd!atomic_ghost.AtomicPtr./AtomicPtr (vstd!atomic_ghost.AtomicPtr./AtomicPtr/?patomic Poly) (vstd!atomic_ghost.AtomicPtr./AtomicPtr/?atomic_inv Poly))) ((vstd!raw_ptr.Metadata./Thin ) (vstd!raw_ptr.Metadata./Length (vstd!raw_ptr.Metadata./Length/?0 Int)) (vstd!raw_ptr.Metadata./Dyn (vstd!raw_ptr.Metadata./Dyn/?0 vstd!raw_ptr.DynMetadata.))) ((vstd!raw_ptr.PtrData./PtrData (vstd!raw_ptr.PtrData./PtrData/?addr Int) (vstd!raw_ptr.PtrData./PtrData/?provenance vstd!raw_ptr.Provenance.) (vstd!raw_ptr.PtrData./PtrData/?metadata vstd!raw_ptr.Metadata.))) ((vstd!raw_ptr.MemContents./Uninit ) (vstd!raw_ptr.MemContents./Init (vstd!raw_ptr.MemContents./Init/?0 Poly))) ((vstd!raw_ptr.PointsToData./PointsToData (vstd!raw_ptr.PointsToData./PointsToData/?ptr Poly) (vstd!raw_ptr.PointsToData./PointsToData/?opt_value vstd!raw_ptr.MemContents.))) ((lib!thread.ThreadId./ThreadId (lib!thread.ThreadId./ThreadId/?thread_id Int))) ((lib!tokens.HeapId./HeapId (lib!tokens.HeapId./HeapId/?id Int) (lib!tokens.HeapId./HeapId/?provenance vstd!raw_ptr.Provenance.) (lib!tokens.HeapId./HeapId/?uniq Int))) ((lib!tokens.TldId./TldId (lib!tokens.TldId./TldId/?id Int) (lib!tokens.TldId./TldId/?provenance vstd!raw_ptr.Provenance.))) ((lib!tokens.SegmentId./SegmentId (lib!tokens.SegmentId./SegmentId/?id Int) (lib!tokens.SegmentId./SegmentId/?provenance vstd!raw_ptr.Provenance.) (lib!tokens.SegmentId./SegmentId/?uniq Int))) ((lib!tokens.PageId./PageId (lib!tokens.PageId./PageId/?segment_id lib!tokens.SegmentId.) (lib!tokens.PageId./PageId/?idx Int))) ((lib!tokens.BlockId./BlockId (lib!tokens.BlockId./BlockId/?page_id lib!tokens.PageId.) (lib!tokens.BlockId./BlockId/?idx Int) (lib!tokens.BlockId./BlockId/?slice_idx Int) (lib!tokens.BlockId./BlockId/?block_size Int))) ((lib!tokens.DelayState./UseDelayedFree ) (lib!tokens.DelayState./Freeing ) (lib!tokens.DelayState./NoDelayedFree ) (lib!tokens.DelayState./NeverDelayedFree )) ((lib!tokens.PageState./PageState (lib!tokens.PageState./PageState/?offset Int) (lib!tokens.PageState./PageState/?block_size Int) (lib!tokens.PageState./PageState/?num_blocks Int) (lib!tokens.PageState./PageState/?shared_access lib!types.PageSharedAccess.) (lib!tokens.PageState./PageState/?is_enabled Bool))) ((lib!tokens.SegmentState./SegmentState (lib!tokens.SegmentState./SegmentState/?shared_access lib!types.SegmentSharedAccess.) (lib!tokens.SegmentState./SegmentState/?is_enabled Bool))) ((lib!tokens.BlockState./BlockState (lib!tokens.BlockState./BlockState/?segment_shared_access lib!types.SegmentSharedAccess.) (lib!tokens.BlockState./BlockState/?page_shared_access lib!types.PageSharedAccess.) (lib!tokens.BlockState./BlockState/?page_slice_shared_access lib!types.PageSharedAccess.) (lib!tokens.BlockState./BlockState/?heap_id core!option.Option.))) ((lib!tokens.HeapState./HeapState (lib!tokens.HeapState./HeapState/?shared_access lib!types.HeapSharedAccess.))) ((lib!tokens.ThreadState./ThreadState (lib!tokens.ThreadState./ThreadState/?heap_id lib!tokens.HeapId.) (lib!tokens.ThreadState./ThreadState/?heap lib!tokens.HeapState.) (lib!tokens.ThreadState./ThreadState/?segments vstd!map.Map<lib!tokens.SegmentId./lib!tokens.SegmentState.>.) (lib!tokens.ThreadState./ThreadState/?pages vstd!map.Map<lib!tokens.PageId./lib!tokens.PageState.>.))) ((lib!tokens.ThreadCheckedState./ThreadCheckedState (lib!tokens.ThreadCheckedState./ThreadCheckedState/?pages vstd!set.Set<lib!tokens.PageId.>.))) ((lib!tokens.Actor./Idle ) (lib!tokens.Actor./Abandoned )) ((lib!tokens.DelayFreeingActor./HeapUnknown ) (lib!tokens.DelayFreeingActor./Heap (lib!tokens.DelayFreeingActor./Heap/?0 lib!tokens.HeapId.) (lib!tokens.DelayFreeingActor./Heap/?1 lib!types.HeapSharedAccess.) (lib!tokens.DelayFreeingActor./Heap/?2 lib!types.PageSharedAccess.))) ((lib!types.PageInner./PageInner (lib!types.PageInner./PageInner/?flags0 Int) (lib!types.PageInner./PageInner/?capacity Int) (lib!types.PageInner./PageInner/?reserved Int) (lib!types.PageInner./PageInner/?flags1 Int) (lib!types.PageInner./PageInner/?flags2 Int) (lib!types.PageInner./PageInner/?free lib!linked_list.LL.) (lib!types.PageInner./PageInner/?used Int) (lib!types.PageInner./PageInner/?xblock_size Int) (lib!types.PageInner./PageInner/?local_free lib!linked_list.LL.))) ((lib!types.AtomicHeapPtr./AtomicHeapPtr (lib!types.AtomicHeapPtr./AtomicHeapPtr/?atomic vstd!atomic_ghost.AtomicPtr.) (lib!types.AtomicHeapPtr./AtomicHeapPtr/?instance lib!tokens.Mim.Instance.) (lib!types.AtomicHeapPtr./AtomicHeapPtr/?page_id lib!tokens.PageId.) (lib!types.AtomicHeapPtr./AtomicHeapPtr/?emp lib!types.BoolAgree.x.) (lib!types.AtomicHeapPtr./AtomicHeapPtr/?emp_inst lib!types.BoolAgree.Instance.))) ((lib!types.InvariantPredicate_auto_AtomicHeapPtr_atomic./InvariantPredicate_auto_AtomicHeapPtr_atomic )) ((lib!types.Page./Page (lib!types.Page./Page/?count vstd!cell.PCell<u32.>.) (lib!types.Page./Page/?offset Int) (lib!types.Page./Page/?inner vstd!cell.PCell<lib!types.PageInner.>.) (lib!types.Page./Page/?xthread_free lib!linked_list.ThreadLLWithDelayBits.) (lib!types.Page./Page/?xheap lib!types.AtomicHeapPtr.) (lib!types.Page./Page/?prev vstd!cell.PCell<ptr_mut%<lib!types.Page.>.>.) (lib!types.Page./Page/?next vstd!cell.PCell<ptr_mut%<lib!types.Page.>.>.) (lib!types.Page./Page/?padding Int))) ((lib!types.PageSharedAccess./PageSharedAccess (lib!types.PageSharedAccess./PageSharedAccess/?points_to vstd!raw_ptr.PointsTo<lib!types.Page.>.) (lib!types.PageSharedAccess./PageSharedAccess/?exposed vstd!raw_ptr.IsExposed.))) ((lib!types.SegmentKind./Normal ) (lib!types.SegmentKind./Huge )) ((lib!types.SegmentHeaderMain./SegmentHeaderMain (lib!types.SegmentHeaderMain./SegmentHeaderMain/?memid Int) (lib!types.SegmentHeaderMain./SegmentHeaderMain/?mem_is_pinned Bool) (lib!types.SegmentHeaderMain./SegmentHeaderMain/?mem_is_large Bool) (lib!types.SegmentHeaderMain./SegmentHeaderMain/?mem_is_committed Bool) (lib!types.SegmentHeaderMain./SegmentHeaderMain/?mem_alignment Int) (lib!types.SegmentHeaderMain./SegmentHeaderMain/?mem_align_offset Int) (lib!types.SegmentHeaderMain./SegmentHeaderMain/?allow_decommit Bool) (lib!types.SegmentHeaderMain./SegmentHeaderMain/?decommit_expire Int) (lib!types.SegmentHeaderMain./SegmentHeaderMain/?decommit_mask lib!commit_mask.CommitMask.) (lib!types.SegmentHeaderMain./SegmentHeaderMain/?commit_mask lib!commit_mask.CommitMask.))) ((lib!types.SegmentHeaderMain2./SegmentHeaderMain2 (lib!types.SegmentHeaderMain2./SegmentHeaderMain2/?next ptr_mut%<lib!types.SegmentHeader.>.) (lib!types.SegmentHeaderMain2./SegmentHeaderMain2/?abandoned Int) (lib!types.SegmentHeaderMain2./SegmentHeaderMain2/?abandoned_visits Int) (lib!types.SegmentHeaderMain2./SegmentHeaderMain2/?used Int) (lib!types.SegmentHeaderMain2./SegmentHeaderMain2/?cookie Int) (lib!types.SegmentHeaderMain2./SegmentHeaderMain2/?segment_slices Int) (lib!types.SegmentHeaderMain2./SegmentHeaderMain2/?segment_info_slices Int) (lib!types.SegmentHeaderMain2./SegmentHeaderMain2/?kind lib!types.SegmentKind.) (lib!types.SegmentHeaderMain2./SegmentHeaderMain2/?slice_entries Int))) ((lib!types.SegmentHeader./SegmentHeader (lib!types.SegmentHeader./SegmentHeader/?main vstd!cell.PCell<lib!types.SegmentHeaderMain.>.) (lib!types.SegmentHeader./SegmentHeader/?abandoned_next Int) (lib!types.SegmentHeader./SegmentHeader/?main2 vstd!cell.PCell<lib!types.SegmentHeaderMain2.>.) (lib!types.SegmentHeader./SegmentHeader/?thread_id vstd!atomic_ghost.AtomicU64.) (lib!types.SegmentHeader./SegmentHeader/?instance lib!tokens.Mim.Instance.) (lib!types.SegmentHeader./SegmentHeader/?segment_id lib!tokens.SegmentId.))) ((lib!types.InvariantPredicate_auto_SegmentHeader_thread_id./InvariantPredicate_auto_SegmentHeader_thread_id )) ((lib!types.SegmentSharedAccess./SegmentSharedAccess (lib!types.SegmentSharedAccess./SegmentSharedAccess/?points_to vstd!raw_ptr.PointsTo<lib!types.SegmentHeader.>.))) ((lib!types.PageQueue./PageQueue (lib!types.PageQueue./PageQueue/?first ptr_mut%<lib!types.Page.>.) (lib!types.PageQueue./PageQueue/?last ptr_mut%<lib!types.Page.>.) (lib!types.PageQueue./PageQueue/?block_size Int))) ((lib!types.Heap./Heap (lib!types.Heap./Heap/?tld_ptr lib!types.TldPtr.) (lib!types.Heap./Heap/?pages_free_direct Poly) (lib!types.Heap./Heap/?pages Poly) (lib!types.Heap./Heap/?thread_delayed_free lib!linked_list.ThreadLLSimple.) (lib!types.Heap./Heap/?thread_id lib!thread.ThreadId.) (lib!types.Heap./Heap/?arena_id Int) (lib!types.Heap./Heap/?page_count vstd!cell.PCell<usize.>.) (lib!types.Heap./Heap/?page_retired_min vstd!cell.PCell<usize.>.) (lib!types.Heap./Heap/?page_retired_max vstd!cell.PCell<usize.>.) (lib!types.Heap./Heap/?no_reclaim Bool) (lib!types.Heap./Heap/?page_empty_ptr ptr_mut%<lib!types.Page.>.))) ((lib!types.HeapSharedAccess./HeapSharedAccess (lib!types.HeapSharedAccess./HeapSharedAccess/?points_to vstd!raw_ptr.PointsTo<lib!types.Heap.>.))) ((lib!types.SegmentsTld./SegmentsTld (lib!types.SegmentsTld./SegmentsTld/?span_queue_headers %%Function%%) (lib!types.SegmentsTld./SegmentsTld/?count Int) (lib!types.SegmentsTld./SegmentsTld/?peak_count Int) (lib!types.SegmentsTld./SegmentsTld/?current_size Int) (lib!types.SegmentsTld./SegmentsTld/?peak_size Int))) ((lib!types.SpanQueueHeader./SpanQueueHeader (lib!types.SpanQueueHeader./SpanQueueHeader/?first ptr_mut%<lib!types.Page.>.) (lib!types.SpanQueueHeader./SpanQueueHeader/?last ptr_mut%<lib!types.Page.>.))) ((lib!types.Tld./Tld (lib!types.Tld./Tld/?heap_backing ptr_mut%<lib!types.Heap.>.) (lib!types.Tld./Tld/?segments lib!types.SegmentsTld.))) ((lib!types.TldPtr./TldPtr (lib!types.TldPtr./TldPtr/?tld_ptr ptr_mut%<lib!types.Tld.>.) (lib!types.TldPtr./TldPtr/?tld_id lib!tokens.TldId.))) ((lib!linked_list.Node./Node (lib!linked_list.Node./Node/?ptr ptr_mut%<lib!linked_list.Node.>.))) ((lib!linked_list.ThreadLLSimple./ThreadLLSimple (lib!linked_list.ThreadLLSimple./ThreadLLSimple/?instance lib!tokens.Mim.Instance.) (lib!linked_list.ThreadLLSimple./ThreadLLSimple/?heap_id lib!tokens.HeapId.) (lib!linked_list.ThreadLLSimple./ThreadLLSimple/?atomic vstd!atomic_ghost.AtomicPtr.))) ((lib!linked_list.InvariantPredicate_auto_ThreadLLSimple_atomic./InvariantPredicate_auto_ThreadLLSimple_atomic )) ((lib!linked_list.ThreadLLWithDelayBits./ThreadLLWithDelayBits (lib!linked_list.ThreadLLWithDelayBits./ThreadLLWithDelayBits/?instance lib!tokens.Mim.Instance.) (lib!linked_list.ThreadLLWithDelayBits./ThreadLLWithDelayBits/?atomic vstd!atomic_ghost.AtomicPtr.) (lib!linked_list.ThreadLLWithDelayBits./ThreadLLWithDelayBits/?emp lib!linked_list.StuffAgree.x.) (lib!linked_list.ThreadLLWithDelayBits./ThreadLLWithDelayBits/?emp_inst lib!linked_list.StuffAgree.Instance.))) ((lib!linked_list.InvariantPredicate_auto_ThreadLLWithDelayBits_atomic./InvariantPredicate_auto_ThreadLLWithDelayBits_atomic )) ((tuple%0./tuple%0 )) ((tuple%2./tuple%2 (tuple%2./tuple%2/?0 Poly) (tuple%2./tuple%2/?1 Poly))) ((tuple%4./tuple%4 (tuple%4./tuple%4/?0 Poly) (tuple%4./tuple%4/?1 Poly) (tuple%4./tuple%4/?2 Poly) (tuple%4./tuple%4/?3 Poly)))))
(declare-fun core!option.Option./Some/0 (core!option.Option.) Poly)
(declare-fun vstd!atomic_ghost.AtomicU64./AtomicU64/patomic (vstd!atomic_ghost.AtomicU64.) vstd!atomic.PAtomicU64.)
(declare-fun vstd!atomic_ghost.AtomicU64./AtomicU64/atomic_inv (vstd!atomic_ghost.AtomicU64.) Poly)
(declare-fun vstd!atomic_ghost.AtomicPtr./AtomicPtr/patomic (vstd!atomic_ghost.AtomicPtr.) Poly)
(declare-fun vstd!atomic_ghost.AtomicPtr./AtomicPtr/atomic_inv (vstd!atomic_ghost.AtomicPtr.) Poly)
(declare-fun vstd!raw_ptr.Metadata./Length/0 (vstd!raw_ptr.Metadata.) Int)
(declare-fun vstd!raw_ptr.Metadata./Dyn/0 (vstd!raw_ptr.Metadata.) vstd!raw_ptr.DynMetadata.)
(declare-fun vstd!raw_ptr.PtrData./PtrData/addr (vstd!raw_ptr.PtrData.) Int)
(declare-fun vstd!raw_ptr.PtrData./PtrData/provenance (vstd!raw_ptr.PtrData.) vstd!raw_ptr.Provenance.)
(declare-fun vstd!raw_ptr.PtrData./PtrData/metadata (vstd!raw_ptr.PtrData.) vstd!raw_ptr.Metadata.)
(declare-fun vstd!raw_ptr.MemContents./Init/0 (vstd!raw_ptr.MemContents.) Poly)
(declare-fun vstd!raw_ptr.PointsToData./PointsToData/ptr (vstd!raw_ptr.PointsToData.) Poly)
(declare-fun vstd!raw_ptr.PointsToData./PointsToData/opt_value (vstd!raw_ptr.PointsToData.) vstd!raw_ptr.MemContents.)
(declare-fun lib!thread.ThreadId./ThreadId/thread_id (lib!thread.ThreadId.) Int)
(declare-fun lib!tokens.HeapId./HeapId/id (lib!tokens.HeapId.) Int)
(declare-fun lib!tokens.HeapId./HeapId/provenance (lib!tokens.HeapId.) vstd!raw_ptr.Provenance.)
(declare-fun lib!tokens.HeapId./HeapId/uniq (lib!tokens.HeapId.) Int)
(declare-fun lib!tokens.TldId./TldId/id (lib!tokens.TldId.) Int)
(declare-fun lib!tokens.TldId./TldId/provenance (lib!tokens.TldId.) vstd!raw_ptr.Provenance.)
(declare-fun lib!tokens.SegmentId./SegmentId/id (lib!tokens.SegmentId.) Int)
(declare-fun lib!tokens.SegmentId./SegmentId/provenance (lib!tokens.SegmentId.) vstd!raw_ptr.Provenance.)
(declare-fun lib!tokens.SegmentId./SegmentId/uniq (lib!tokens.SegmentId.) Int)
(declare-fun lib!tokens.PageId./PageId/segment_id (lib!tokens.PageId.) lib!tokens.SegmentId.)
(declare-fun lib!tokens.PageId./PageId/idx (lib!tokens.PageId.) Int)
(declare-fun lib!tokens.BlockId./BlockId/page_id (lib!tokens.BlockId.) lib!tokens.PageId.)
(declare-fun lib!tokens.BlockId./BlockId/idx (lib!tokens.BlockId.) Int)
(declare-fun lib!tokens.BlockId./BlockId/slice_idx (lib!tokens.BlockId.) Int)
(declare-fun lib!tokens.BlockId./BlockId/block_size (lib!tokens.BlockId.) Int)
(declare-fun lib!tokens.PageState./PageState/offset (lib!tokens.PageState.) Int)
(declare-fun lib!tokens.PageState./PageState/block_size (lib!tokens.PageState.) Int)
(declare-fun lib!tokens.PageState./PageState/num_blocks (lib!tokens.PageState.) Int)
(declare-fun lib!tokens.PageState./PageState/shared_access (lib!tokens.PageState.) lib!types.PageSharedAccess.)
(declare-fun lib!tokens.PageState./PageState/is_enabled (lib!tokens.PageState.) Bool)
(declare-fun lib!tokens.SegmentState./SegmentState/shared_access (lib!tokens.SegmentState.) lib!types.SegmentSharedAccess.)
(declare-fun lib!tokens.SegmentState./SegmentState/is_enabled (lib!tokens.SegmentState.) Bool)
(declare-fun lib!tokens.BlockState./BlockState/segment_shared_access (lib!tokens.BlockState.) lib!types.SegmentSharedAccess.)
(declare-fun lib!tokens.BlockState./BlockState/page_shared_access (lib!tokens.BlockState.) lib!types.PageSharedAccess.)
(declare-fun lib!tokens.BlockState./BlockState/page_slice_shared_access (lib!tokens.BlockState.) lib!types.PageSharedAccess.)
(declare-fun lib!tokens.BlockState./BlockState/heap_id (lib!tokens.BlockState.) core!option.Option.)
(declare-fun lib!tokens.HeapState./HeapState/shared_access (lib!tokens.HeapState.) lib!types.HeapSharedAccess.)
(declare-fun lib!tokens.ThreadState./ThreadState/heap_id (lib!tokens.ThreadState.) lib!tokens.HeapId.)
(declare-fun lib!tokens.ThreadState./ThreadState/heap (lib!tokens.ThreadState.) lib!tokens.HeapState.)
(declare-fun lib!tokens.ThreadState./ThreadState/segments (lib!tokens.ThreadState.) vstd!map.Map<lib!tokens.SegmentId./lib!tokens.SegmentState.>.)
(declare-fun lib!tokens.ThreadState./ThreadState/pages (lib!tokens.ThreadState.) vstd!map.Map<lib!tokens.PageId./lib!tokens.PageState.>.)
(declare-fun lib!tokens.ThreadCheckedState./ThreadCheckedState/pages (lib!tokens.ThreadCheckedState.) vstd!set.Set<lib!tokens.PageId.>.)
(declare-fun lib!tokens.DelayFreeingActor./Heap/0 (lib!tokens.DelayFreeingActor.) lib!tokens.HeapId.)
(declare-fun lib!tokens.DelayFreeingActor./Heap/1 (lib!tokens.DelayFreeingActor.) lib!types.HeapSharedAccess.)
(declare-fun lib!tokens.DelayFreeingActor./Heap/2 (lib!tokens.DelayFreeingActor.) lib!types.PageSharedAccess.)
(declare-fun lib!types.PageInner./PageInner/flags0 (lib!types.PageInner.) Int)
(declare-fun lib!types.PageInner./PageInner/capacity (lib!types.PageInner.) Int)
(declare-fun lib!types.PageInner./PageInner/reserved (lib!types.PageInner.) Int)
(declare-fun lib!types.PageInner./PageInner/flags1 (lib!types.PageInner.) Int)
(declare-fun lib!types.PageInner./PageInner/flags2 (lib!types.PageInner.) Int)
(declare-fun lib!types.PageInner./PageInner/free (lib!types.PageInner.) lib!linked_list.LL.)
(declare-fun lib!types.PageInner./PageInner/used (lib!types.PageInner.) Int)
(declare-fun lib!types.PageInner./PageInner/xblock_size (lib!types.PageInner.) Int)
(declare-fun lib!types.PageInner./PageInner/local_free (lib!types.PageInner.) lib!linked_list.LL.)
(declare-fun lib!types.AtomicHeapPtr./AtomicHeapPtr/atomic (lib!types.AtomicHeapPtr.) vstd!atomic_ghost.AtomicPtr.)
(declare-fun lib!types.AtomicHeapPtr./AtomicHeapPtr/instance (lib!types.AtomicHeapPtr.) lib!tokens.Mim.Instance.)
(declare-fun lib!types.AtomicHeapPtr./AtomicHeapPtr/page_id (lib!types.AtomicHeapPtr.) lib!tokens.PageId.)
(declare-fun lib!types.AtomicHeapPtr./AtomicHeapPtr/emp (lib!types.AtomicHeapPtr.) lib!types.BoolAgree.x.)
(declare-fun lib!types.AtomicHeapPtr./AtomicHeapPtr/emp_inst (lib!types.AtomicHeapPtr.) lib!types.BoolAgree.Instance.)
(declare-fun lib!types.Page./Page/count (lib!types.Page.) vstd!cell.PCell<u32.>.)
(declare-fun lib!types.Page./Page/offset (lib!types.Page.) Int)
(declare-fun lib!types.Page./Page/inner (lib!types.Page.) vstd!cell.PCell<lib!types.PageInner.>.)
(declare-fun lib!types.Page./Page/xthread_free (lib!types.Page.) lib!linked_list.ThreadLLWithDelayBits.)
(declare-fun lib!types.Page./Page/xheap (lib!types.Page.) lib!types.AtomicHeapPtr.)
(declare-fun lib!types.Page./Page/prev (lib!types.Page.) vstd!cell.PCell<ptr_mut%<lib!types.Page.>.>.)
(declare-fun lib!types.Page./Page/next (lib!types.Page.) vstd!cell.PCell<ptr_mut%<lib!types.Page.>.>.)
(declare-fun lib!types.Page./Page/padding (lib!types.Page.) Int)
(declare-fun lib!types.PageSharedAccess./PageSharedAccess/points_to (lib!types.PageSharedAccess.) vstd!raw_ptr.PointsTo<lib!types.Page.>.)
(declare-fun lib!types.PageSharedAccess./PageSharedAccess/exposed (lib!types.PageSharedAccess.) vstd!raw_ptr.IsExposed.)
(declare-fun lib!types.SegmentHeaderMain./SegmentHeaderMain/memid (lib!types.SegmentHeaderMain.) Int)
(declare-fun lib!types.SegmentHeaderMain./SegmentHeaderMain/mem_is_pinned (lib!types.SegmentHeaderMain.) Bool)
(declare-fun lib!types.SegmentHeaderMain./SegmentHeaderMain/mem_is_large (lib!types.SegmentHeaderMain.) Bool)
(declare-fun lib!types.SegmentHeaderMain./SegmentHeaderMain/mem_is_committed (lib!types.SegmentHeaderMain.) Bool)
(declare-fun lib!types.SegmentHeaderMain./SegmentHeaderMain/mem_alignment (lib!types.SegmentHeaderMain.) Int)
(declare-fun lib!types.SegmentHeaderMain./SegmentHeaderMain/mem_align_offset (lib!types.SegmentHeaderMain.) Int)
(declare-fun lib!types.SegmentHeaderMain./SegmentHeaderMain/allow_decommit (lib!types.SegmentHeaderMain.) Bool)
(declare-fun lib!types.SegmentHeaderMain./SegmentHeaderMain/decommit_expire (lib!types.SegmentHeaderMain.) Int)
(declare-fun lib!types.SegmentHeaderMain./SegmentHeaderMain/decommit_mask (lib!types.SegmentHeaderMain.) lib!commit_mask.CommitMask.)
(declare-fun lib!types.SegmentHeaderMain./SegmentHeaderMain/commit_mask (lib!types.SegmentHeaderMain.) lib!commit_mask.CommitMask.)
(declare-fun lib!types.SegmentHeaderMain2./SegmentHeaderMain2/next (lib!types.SegmentHeaderMain2.) ptr_mut%<lib!types.SegmentHeader.>.)
(declare-fun lib!types.SegmentHeaderMain2./SegmentHeaderMain2/abandoned (lib!types.SegmentHeaderMain2.) Int)
(declare-fun lib!types.SegmentHeaderMain2./SegmentHeaderMain2/abandoned_visits (lib!types.SegmentHeaderMain2.) Int)
(declare-fun lib!types.SegmentHeaderMain2./SegmentHeaderMain2/used (lib!types.SegmentHeaderMain2.) Int)
(declare-fun lib!types.SegmentHeaderMain2./SegmentHeaderMain2/cookie (lib!types.SegmentHeaderMain2.) Int)
(declare-fun lib!types.SegmentHeaderMain2./SegmentHeaderMain2/segment_slices (lib!types.SegmentHeaderMain2.) Int)
(declare-fun lib!types.SegmentHeaderMain2./SegmentHeaderMain2/segment_info_slices (lib!types.SegmentHeaderMain2.) Int)
(declare-fun lib!types.SegmentHeaderMain2./SegmentHeaderMain2/kind (lib!types.SegmentHeaderMain2.) lib!types.SegmentKind.)
(declare-fun lib!types.SegmentHeaderMain2./SegmentHeaderMain2/slice_entries (lib!types.SegmentHeaderMain2.) Int)
(declare-fun lib!types.SegmentHeader./SegmentHeader/main (lib!types.SegmentHeader.) vstd!cell.PCell<lib!types.SegmentHeaderMain.>.)
(declare-fun lib!types.SegmentHeader./SegmentHeader/abandoned_next (lib!types.SegmentHeader.) Int)
(declare-fun lib!types.SegmentHeader./SegmentHeader/main2 (lib!types.SegmentHeader.) vstd!cell.PCell<lib!types.SegmentHeaderMain2.>.)
(declare-fun lib!types.SegmentHeader./SegmentHeader/thread_id (lib!types.SegmentHeader.) vstd!atomic_ghost.AtomicU64.)
(declare-fun lib!types.SegmentHeader./SegmentHeader/instance (lib!types.SegmentHeader.) lib!tokens.Mim.Instance.)
(declare-fun lib!types.SegmentHeader./SegmentHeader/segment_id (lib!types.SegmentHeader.) lib!tokens.SegmentId.)
(declare-fun lib!types.SegmentSharedAccess./SegmentSharedAccess/points_to (lib!types.SegmentSharedAccess.) vstd!raw_ptr.PointsTo<lib!types.SegmentHeader.>.)
(declare-fun lib!types.PageQueue./PageQueue/first (lib!types.PageQueue.) ptr_mut%<lib!types.Page.>.)
(declare-fun lib!types.PageQueue./PageQueue/last (lib!types.PageQueue.) ptr_mut%<lib!types.Page.>.)
(declare-fun lib!types.PageQueue./PageQueue/block_size (lib!types.PageQueue.) Int)
(declare-fun lib!types.Heap./Heap/tld_ptr (lib!types.Heap.) lib!types.TldPtr.)
(declare-fun lib!types.Heap./Heap/pages_free_direct (lib!types.Heap.) Poly)
(declare-fun lib!types.Heap./Heap/pages (lib!types.Heap.) Poly)
(declare-fun lib!types.Heap./Heap/thread_delayed_free (lib!types.Heap.) lib!linked_list.ThreadLLSimple.)
(declare-fun lib!types.Heap./Heap/thread_id (lib!types.Heap.) lib!thread.ThreadId.)
(declare-fun lib!types.Heap./Heap/arena_id (lib!types.Heap.) Int)
(declare-fun lib!types.Heap./Heap/page_count (lib!types.Heap.) vstd!cell.PCell<usize.>.)
(declare-fun lib!types.Heap./Heap/page_retired_min (lib!types.Heap.) vstd!cell.PCell<usize.>.)
(declare-fun lib!types.Heap./Heap/page_retired_max (lib!types.Heap.) vstd!cell.PCell<usize.>.)
(declare-fun lib!types.Heap./Heap/no_reclaim (lib!types.Heap.) Bool)
(declare-fun lib!types.Heap./Heap/page_empty_ptr (lib!types.Heap.) ptr_mut%<lib!types.Page.>.)
(declare-fun lib!types.HeapSharedAccess./HeapSharedAccess/points_to (lib!types.HeapSharedAccess.) vstd!raw_ptr.PointsTo<lib!types.Heap.>.)
(declare-fun lib!types.SegmentsTld./SegmentsTld/span_queue_headers (lib!types.SegmentsTld.) %%Function%%)
(declare-fun lib!types.SegmentsTld./SegmentsTld/count (lib!types.SegmentsTld.) Int)
(declare-fun lib!types.SegmentsTld./SegmentsTld/peak_count (lib!types.SegmentsTld.) Int)
(declare-fun lib!types.SegmentsTld./SegmentsTld/current_size (lib!types.SegmentsTld.) Int)
(declare-fun lib!types.SegmentsTld./SegmentsTld/peak_size (lib!types.SegmentsTld.) Int)
(declare-fun lib!types.SpanQueueHeader./SpanQueueHeader/first (lib!types.SpanQueueHeader.) ptr_mut%<lib!types.Page.>.)
(declare-fun lib!types.SpanQueueHeader./SpanQueueHeader/last (lib!types.SpanQueueHeader.) ptr_mut%<lib!types.Page.>.)
(declare-fun lib!types.Tld./Tld/heap_backing (lib!types.Tld.) ptr_mut%<lib!types.Heap.>.)
(declare-fun lib!types.Tld./Tld/segments (lib!types.Tld.) lib!types.SegmentsTld.)
(declare-fun lib!types.TldPtr./TldPtr/tld_ptr (lib!types.TldPtr.) ptr_mut%<lib!types.Tld.>.)
(declare-fun lib!types.TldPtr./TldPtr/tld_id (lib!types.TldPtr.) lib!tokens.TldId.)
(declare-fun lib!linked_list.Node./Node/ptr (lib!linked_list.Node.) ptr_mut%<lib!linked_list.Node.>.)
(declare-fun lib!linked_list.ThreadLLSimple./ThreadLLSimple/instance (lib!linked_list.ThreadLLSimple.) lib!tokens.Mim.Instance.)
(declare-fun lib!linked_list.ThreadLLSimple./ThreadLLSimple/heap_id (lib!linked_list.ThreadLLSimple.) lib!tokens.HeapId.)
(declare-fun lib!linked_list.ThreadLLSimple./ThreadLLSimple/atomic (lib!linked_list.ThreadLLSimple.) vstd!atomic_ghost.AtomicPtr.)
(declare-fun lib!linked_list.ThreadLLWithDelayBits./ThreadLLWithDelayBits/instance (lib!linked_list.ThreadLLWithDelayBits.) lib!tokens.Mim.Instance.)
(declare-fun lib!linked_list.ThreadLLWithDelayBits./ThreadLLWithDelayBits/atomic (lib!linked_list.ThreadLLWithDelayBits.) vstd!atomic_ghost.AtomicPtr.)
(declare-fun lib!linked_list.ThreadLLWithDelayBits./ThreadLLWithDelayBits/emp (lib!linked_list.ThreadLLWithDelayBits.) lib!linked_list.StuffAgree.x.)
(declare-fun lib!linked_list.ThreadLLWithDelayBits./ThreadLLWithDelayBits/emp_inst (lib!linked_list.ThreadLLWithDelayBits.) lib!linked_list.StuffAgree.Instance.)
(declare-fun tuple%2./tuple%2/0 (tuple%2.) Poly)
(declare-fun tuple%2./tuple%2/1 (tuple%2.) Poly)
(declare-fun tuple%4./tuple%4/0 (tuple%4.) Poly)
(declare-fun tuple%4./tuple%4/1 (tuple%4.) Poly)
(declare-fun tuple%4./tuple%4/2 (tuple%4.) Poly)
(declare-fun tuple%4./tuple%4/3 (tuple%4.) Poly)
(declare-fun TYPE%fun%1. (Dcr Type Dcr Type) Type)
(declare-fun TYPE%core!option.Option. (Dcr Type) Type)
(declare-const TYPE%vstd!atomic.PAtomicU64. Type)
(declare-const TYPE%vstd!atomic.PermissionU64. Type)
(declare-fun TYPE%vstd!atomic.PAtomicPtr. (Dcr Type) Type)
(declare-fun TYPE%vstd!atomic.PermissionPtr. (Dcr Type) Type)
(declare-fun TYPE%vstd!atomic_ghost.AtomicPredU64. (Dcr Type) Type)
(declare-fun TYPE%vstd!atomic_ghost.AtomicU64. (Dcr Type Dcr Type Dcr Type) Type)
(declare-fun TYPE%vstd!atomic_ghost.AtomicPredPtr. (Dcr Type Dcr Type) Type)
(declare-fun TYPE%vstd!atomic_ghost.AtomicPtr. (Dcr Type Dcr Type Dcr Type Dcr Type) Type)
(declare-fun TYPE%vstd!cell.PCell. (Dcr Type) Type)
(declare-fun TYPE%vstd!invariant.AtomicInvariant. (Dcr Type Dcr Type Dcr Type) Type)
(declare-fun TYPE%vstd!map.Map. (Dcr Type Dcr Type) Type)
(declare-const TYPE%vstd!raw_ptr.Provenance. Type)
(declare-const TYPE%vstd!raw_ptr.Metadata. Type)
(declare-const TYPE%vstd!raw_ptr.DynMetadata. Type)
(declare-const TYPE%vstd!raw_ptr.PtrData. Type)
(declare-fun TYPE%vstd!raw_ptr.PointsTo. (Dcr Type) Type)
(declare-fun TYPE%vstd!raw_ptr.MemContents. (Dcr Type) Type)
(declare-fun TYPE%vstd!raw_ptr.PointsToData. (Dcr Type) Type)
(declare-const TYPE%vstd!raw_ptr.IsExposed. Type)
(declare-fun TYPE%vstd!seq.Seq. (Dcr Type) Type)
(declare-fun TYPE%vstd!set.Set. (Dcr Type) Type)
(declare-const TYPE%lib!tokens.Mim.Instance. Type)
(declare-const TYPE%lib!tokens.Mim.thread_of_segment. Type)
(declare-const TYPE%lib!tokens.Mim.delay. Type)
(declare-const TYPE%lib!tokens.Mim.heap_of_page. Type)
(declare-const TYPE%lib!types.BoolAgree.Instance. Type)
(declare-const TYPE%lib!types.BoolAgree.x. Type)
(declare-const TYPE%lib!types.BoolAgree.y. Type)
(declare-const TYPE%lib!linked_list.StuffAgree.Instance. Type)
(declare-const TYPE%lib!linked_list.StuffAgree.x. Type)
(declare-const TYPE%lib!linked_list.StuffAgree.y. Type)
(declare-const TYPE%lib!thread.ThreadId. Type)
(declare-const TYPE%lib!tokens.HeapId. Type)
(declare-const TYPE%lib!tokens.TldId. Type)
(declare-const TYPE%lib!tokens.SegmentId. Type)
(declare-const TYPE%lib!tokens.PageId. Type)
(declare-const TYPE%lib!tokens.BlockId. Type)
(declare-const TYPE%lib!tokens.DelayState. Type)
(declare-const TYPE%lib!tokens.PageState. Type)
(declare-const TYPE%lib!tokens.SegmentState. Type)
(declare-const TYPE%lib!tokens.BlockState. Type)
(declare-const TYPE%lib!tokens.HeapState. Type)
(declare-const TYPE%lib!tokens.ThreadState. Type)
(declare-const TYPE%lib!tokens.ThreadCheckedState. Type)
(declare-const TYPE%lib!tokens.Actor. Type)
(declare-const TYPE%lib!tokens.DelayFreeingActor. Type)
(declare-const TYPE%lib!types.PageInner. Type)
(declare-const TYPE%lib!types.AtomicHeapPtr. Type)
(declare-const TYPE%lib!types.InvariantPredicate_auto_AtomicHeapPtr_atomic. Type)
(declare-const TYPE%lib!types.Page. Type)
(declare-const TYPE%lib!types.PageSharedAccess. Type)
(declare-const TYPE%lib!types.SegmentKind. Type)
(declare-const TYPE%lib!types.SegmentHeaderMain. Type)
(declare-const TYPE%lib!types.SegmentHeaderMain2. Type)
(declare-const TYPE%lib!types.SegmentHeader. Type)
(declare-const TYPE%lib!types.InvariantPredicate_auto_SegmentHeader_thread_id. Type)
(declare-const TYPE%lib!types.SegmentSharedAccess. Type)
(declare-const TYPE%lib!types.PageQueue. Type)
(declare-const TYPE%lib!types.Heap. Type)
(declare-const TYPE%lib!types.HeapSharedAccess. Type)
(declare-const TYPE%lib!types.SegmentsTld. Type)
(declare-const TYPE%lib!types.SpanQueueHeader. Type)
(declare-const TYPE%lib!types.Tld. Type)
(declare-const TYPE%lib!types.TldPtr. Type)
(declare-const TYPE%lib!linked_list.Node. Type)
(declare-const TYPE%lib!linked_list.LL. Type)
(declare-const TYPE%lib!linked_list.ThreadLLSimple. Type)
(declare-const TYPE%lib!linked_list.InvariantPredicate_auto_ThreadLLSimple_atomic. Type)
(declare-const TYPE%lib!linked_list.ThreadLLWithDelayBits. Type)
(declare-const TYPE%lib!linked_list.InvariantPredicate_auto_ThreadLLWithDelayBits_atomic. Type)
(declare-const TYPE%lib!commit_mask.CommitMask. Type)
(declare-const TYPE%tuple%0. Type)
(declare-fun TYPE%tuple%2. (Dcr Type Dcr Type) Type)
(declare-fun TYPE%tuple%4. (Dcr Type Dcr Type Dcr Type Dcr Type) Type)
(declare-fun Poly%fun%1. (%%Function%%) Poly)
(declare-fun %Poly%fun%1. (Poly) %%Function%%)
(declare-fun Poly%array%. (%%Function%%) Poly)
(declare-fun %Poly%array%. (Poly) %%Function%%)
(declare-fun Poly%lib!commit_mask.CommitMask. (lib!commit_mask.CommitMask.) Poly)
(declare-fun %Poly%lib!commit_mask.CommitMask. (Poly) lib!commit_mask.CommitMask.)
(declare-fun Poly%lib!linked_list.LL. (lib!linked_list.LL.) Poly)
(declare-fun %Poly%lib!linked_list.LL. (Poly) lib!linked_list.LL.)
(declare-fun Poly%lib!linked_list.StuffAgree.Instance. (lib!linked_list.StuffAgree.Instance.) Poly)
(declare-fun %Poly%lib!linked_list.StuffAgree.Instance. (Poly) lib!linked_list.StuffAgree.Instance.)
(declare-fun Poly%lib!linked_list.StuffAgree.x. (lib!linked_list.StuffAgree.x.) Poly)
(declare-fun %Poly%lib!linked_list.StuffAgree.x. (Poly) lib!linked_list.StuffAgree.x.)
(declare-fun Poly%lib!linked_list.StuffAgree.y. (lib!linked_list.StuffAgree.y.) Poly)
(declare-fun %Poly%lib!linked_list.StuffAgree.y. (Poly) lib!linked_list.StuffAgree.y.)
(declare-fun Poly%lib!tokens.Mim.Instance. (lib!tokens.Mim.Instance.) Poly)
(declare-fun %Poly%lib!tokens.Mim.Instance. (Poly) lib!tokens.Mim.Instance.)
(declare-fun Poly%lib!tokens.Mim.delay. (lib!tokens.Mim.delay.) Poly)
(declare-fun %Poly%lib!tokens.Mim.delay. (Poly) lib!tokens.Mim.delay.)
(declare-fun Poly%lib!tokens.Mim.heap_of_page. (lib!tokens.Mim.heap_of_page.) Poly)
(declare-fun %Poly%lib!tokens.Mim.heap_of_page. (Poly) lib!tokens.Mim.heap_of_page.)
(declare-fun Poly%lib!tokens.Mim.thread_of_segment. (lib!tokens.Mim.thread_of_segment.) Poly)
(declare-fun %Poly%lib!tokens.Mim.thread_of_segment. (Poly) lib!tokens.Mim.thread_of_segment.)
(declare-fun Poly%lib!types.BoolAgree.Instance. (lib!types.BoolAgree.Instance.) Poly)
(declare-fun %Poly%lib!types.BoolAgree.Instance. (Poly) lib!types.BoolAgree.Instance.)
(declare-fun Poly%lib!types.BoolAgree.x. (lib!types.BoolAgree.x.) Poly)
(declare-fun %Poly%lib!types.BoolAgree.x. (Poly) lib!types.BoolAgree.x.)
(declare-fun Poly%lib!types.BoolAgree.y. (lib!types.BoolAgree.y.) Poly)
(declare-fun %Poly%lib!types.BoolAgree.y. (Poly) lib!types.BoolAgree.y.)
(declare-fun Poly%vstd!atomic.PAtomicU64. (vstd!atomic.PAtomicU64.) Poly)
(declare-fun %Poly%vstd!atomic.PAtomicU64. (Poly) vstd!atomic.PAtomicU64.)
(declare-fun Poly%vstd!atomic.PermissionU64. (vstd!atomic.PermissionU64.) Poly)
(declare-fun %Poly%vstd!atomic.PermissionU64. (Poly) vstd!atomic.PermissionU64.)
(declare-fun Poly%vstd!cell.PCell<u32.>. (vstd!cell.PCell<u32.>.) Poly)
(declare-fun %Poly%vstd!cell.PCell<u32.>. (Poly) vstd!cell.PCell<u32.>.)
(declare-fun Poly%vstd!cell.PCell<usize.>. (vstd!cell.PCell<usize.>.) Poly)
(declare-fun %Poly%vstd!cell.PCell<usize.>. (Poly) vstd!cell.PCell<usize.>.)
(declare-fun Poly%vstd!cell.PCell<lib!types.PageInner.>. (vstd!cell.PCell<lib!types.PageInner.>.) Poly)
(declare-fun %Poly%vstd!cell.PCell<lib!types.PageInner.>. (Poly) vstd!cell.PCell<lib!types.PageInner.>.)
(declare-fun Poly%vstd!cell.PCell<lib!types.SegmentHeaderMain.>. (vstd!cell.PCell<lib!types.SegmentHeaderMain.>.) Poly)
(declare-fun %Poly%vstd!cell.PCell<lib!types.SegmentHeaderMain.>. (Poly) vstd!cell.PCell<lib!types.SegmentHeaderMain.>.)
(declare-fun Poly%vstd!cell.PCell<lib!types.SegmentHeaderMain2.>. (vstd!cell.PCell<lib!types.SegmentHeaderMain2.>.) Poly)
(declare-fun %Poly%vstd!cell.PCell<lib!types.SegmentHeaderMain2.>. (Poly) vstd!cell.PCell<lib!types.SegmentHeaderMain2.>.)
(declare-fun Poly%vstd!cell.PCell<ptr_mut%<lib!types.Page.>.>. (vstd!cell.PCell<ptr_mut%<lib!types.Page.>.>.) Poly)
(declare-fun %Poly%vstd!cell.PCell<ptr_mut%<lib!types.Page.>.>. (Poly) vstd!cell.PCell<ptr_mut%<lib!types.Page.>.>.)
(declare-fun Poly%vstd!map.Map<lib!tokens.PageId./lib!tokens.PageState.>. (vstd!map.Map<lib!tokens.PageId./lib!tokens.PageState.>.) Poly)
(declare-fun %Poly%vstd!map.Map<lib!tokens.PageId./lib!tokens.PageState.>. (Poly) vstd!map.Map<lib!tokens.PageId./lib!tokens.PageState.>.)
(declare-fun Poly%vstd!map.Map<lib!tokens.SegmentId./lib!tokens.SegmentState.>. (vstd!map.Map<lib!tokens.SegmentId./lib!tokens.SegmentState.>.) Poly)
(declare-fun %Poly%vstd!map.Map<lib!tokens.SegmentId./lib!tokens.SegmentState.>. (Poly) vstd!map.Map<lib!tokens.SegmentId./lib!tokens.SegmentState.>.)
(declare-fun Poly%vstd!raw_ptr.DynMetadata. (vstd!raw_ptr.DynMetadata.) Poly)
(declare-fun %Poly%vstd!raw_ptr.DynMetadata. (Poly) vstd!raw_ptr.DynMetadata.)
(declare-fun Poly%vstd!raw_ptr.IsExposed. (vstd!raw_ptr.IsExposed.) Poly)
(declare-fun %Poly%vstd!raw_ptr.IsExposed. (Poly) vstd!raw_ptr.IsExposed.)
(declare-fun Poly%vstd!raw_ptr.PointsTo<lib!types.Heap.>. (vstd!raw_ptr.PointsTo<lib!types.Heap.>.) Poly)
(declare-fun %Poly%vstd!raw_ptr.PointsTo<lib!types.Heap.>. (Poly) vstd!raw_ptr.PointsTo<lib!types.Heap.>.)
(declare-fun Poly%vstd!raw_ptr.PointsTo<lib!types.Page.>. (vstd!raw_ptr.PointsTo<lib!types.Page.>.) Poly)
(declare-fun %Poly%vstd!raw_ptr.PointsTo<lib!types.Page.>. (Poly) vstd!raw_ptr.PointsTo<lib!types.Page.>.)
(declare-fun Poly%vstd!raw_ptr.PointsTo<lib!types.SegmentHeader.>. (vstd!raw_ptr.PointsTo<lib!types.SegmentHeader.>.) Poly)
(declare-fun %Poly%vstd!raw_ptr.PointsTo<lib!types.SegmentHeader.>. (Poly) vstd!raw_ptr.PointsTo<lib!types.SegmentHeader.>.)
(declare-fun Poly%vstd!raw_ptr.Provenance. (vstd!raw_ptr.Provenance.) Poly)
(declare-fun %Poly%vstd!raw_ptr.Provenance. (Poly) vstd!raw_ptr.Provenance.)
(declare-fun Poly%vstd!set.Set<lib!tokens.HeapId.>. (vstd!set.Set<lib!tokens.HeapId.>.) Poly)
(declare-fun %Poly%vstd!set.Set<lib!tokens.HeapId.>. (Poly) vstd!set.Set<lib!tokens.HeapId.>.)
(declare-fun Poly%vstd!set.Set<lib!tokens.PageId.>. (vstd!set.Set<lib!tokens.PageId.>.) Poly)
(declare-fun %Poly%vstd!set.Set<lib!tokens.PageId.>. (Poly) vstd!set.Set<lib!tokens.PageId.>.)
(declare-fun Poly%vstd!set.Set<lib!tokens.SegmentId.>. (vstd!set.Set<lib!tokens.SegmentId.>.) Poly)
(declare-fun %Poly%vstd!set.Set<lib!tokens.SegmentId.>. (Poly) vstd!set.Set<lib!tokens.SegmentId.>.)
(declare-fun Poly%ptr_mut%<lib!linked_list.Node.>. (ptr_mut%<lib!linked_list.Node.>.) Poly)
(declare-fun %Poly%ptr_mut%<lib!linked_list.Node.>. (Poly) ptr_mut%<lib!linked_list.Node.>.)
(declare-fun Poly%ptr_mut%<lib!types.Heap.>. (ptr_mut%<lib!types.Heap.>.) Poly)
(declare-fun %Poly%ptr_mut%<lib!types.Heap.>. (Poly) ptr_mut%<lib!types.Heap.>.)
(declare-fun Poly%ptr_mut%<lib!types.Page.>. (ptr_mut%<lib!types.Page.>.) Poly)
(declare-fun %Poly%ptr_mut%<lib!types.Page.>. (Poly) ptr_mut%<lib!types.Page.>.)
(declare-fun Poly%ptr_mut%<lib!types.SegmentHeader.>. (ptr_mut%<lib!types.SegmentHeader.>.) Poly)
(declare-fun %Poly%ptr_mut%<lib!types.SegmentHeader.>. (Poly) ptr_mut%<lib!types.SegmentHeader.>.)
(declare-fun Poly%ptr_mut%<lib!types.Tld.>. (ptr_mut%<lib!types.Tld.>.) Poly)
(declare-fun %Poly%ptr_mut%<lib!types.Tld.>. (Poly) ptr_mut%<lib!types.Tld.>.)
(declare-fun Poly%allocator_global%. (allocator_global%.) Poly)
(declare-fun %Poly%allocator_global%. (Poly) allocator_global%.)
(declare-fun Poly%core!option.Option. (core!option.Option.) Poly)
(declare-fun %Poly%core!option.Option. (Poly) core!option.Option.)
(declare-fun Poly%vstd!atomic_ghost.AtomicU64. (vstd!atomic_ghost.AtomicU64.) Poly)
(declare-fun %Poly%vstd!atomic_ghost.AtomicU64. (Poly) vstd!atomic_ghost.AtomicU64.)
(declare-fun Poly%vstd!atomic_ghost.AtomicPtr. (vstd!atomic_ghost.AtomicPtr.) Poly)
(declare-fun %Poly%vstd!atomic_ghost.AtomicPtr. (Poly) vstd!atomic_ghost.AtomicPtr.)
(declare-fun Poly%vstd!raw_ptr.Metadata. (vstd!raw_ptr.Metadata.) Poly)
(declare-fun %Poly%vstd!raw_ptr.Metadata. (Poly) vstd!raw_ptr.Metadata.)
(declare-fun Poly%vstd!raw_ptr.PtrData. (vstd!raw_ptr.PtrData.) Poly)
(declare-fun %Poly%vstd!raw_ptr.PtrData. (Poly) vstd!raw_ptr.PtrData.)
(declare-fun Poly%vstd!raw_ptr.MemContents. (vstd!raw_ptr.MemContents.) Poly)
(declare-fun %Poly%vstd!raw_ptr.MemContents. (Poly) vstd!raw_ptr.MemContents.)
(declare-fun Poly%vstd!raw_ptr.PointsToData. (vstd!raw_ptr.PointsToData.) Poly)
(declare-fun %Poly%vstd!raw_ptr.PointsToData. (Poly) vstd!raw_ptr.PointsToData.)
(declare-fun Poly%lib!thread.ThreadId. (lib!thread.ThreadId.) Poly)
(declare-fun %Poly%lib!thread.ThreadId. (Poly) lib!thread.ThreadId.)
(declare-fun Poly%lib!tokens.HeapId. (lib!tokens.HeapId.) Poly)
(declare-fun %Poly%lib!tokens.HeapId. (Poly) lib!tokens.HeapId.)
(declare-fun Poly%lib!tokens.TldId. (lib!tokens.TldId.) Poly)
(declare-fun %Poly%lib!tokens.TldId. (Poly) lib!tokens.TldId.)
(declare-fun Poly%lib!tokens.SegmentId. (lib!tokens.SegmentId.) Poly)
(declare-fun %Poly%lib!tokens.SegmentId. (Poly) lib!tokens.SegmentId.)
(declare-fun Poly%lib!tokens.PageId. (lib!tokens.PageId.) Poly)
(declare-fun %Poly%lib!tokens.PageId. (Poly) lib!tokens.PageId.)
(declare-fun Poly%lib!tokens.BlockId. (lib!tokens.BlockId.) Poly)
(declare-fun %Poly%lib!tokens.BlockId. (Poly) lib!tokens.BlockId.)
(declare-fun Poly%lib!tokens.DelayState. (lib!tokens.DelayState.) Poly)
(declare-fun %Poly%lib!tokens.DelayState. (Poly) lib!tokens.DelayState.)
(declare-fun Poly%lib!tokens.PageState. (lib!tokens.PageState.) Poly)
(declare-fun %Poly%lib!tokens.PageState. (Poly) lib!tokens.PageState.)
(declare-fun Poly%lib!tokens.SegmentState. (lib!tokens.SegmentState.) Poly)
(declare-fun %Poly%lib!tokens.SegmentState. (Poly) lib!tokens.SegmentState.)
(declare-fun Poly%lib!tokens.BlockState. (lib!tokens.BlockState.) Poly)
(declare-fun %Poly%lib!tokens.BlockState. (Poly) lib!tokens.BlockState.)
(declare-fun Poly%lib!tokens.HeapState. (lib!tokens.HeapState.) Poly)
(declare-fun %Poly%lib!tokens.HeapState. (Poly) lib!tokens.HeapState.)
(declare-fun Poly%lib!tokens.ThreadState. (lib!tokens.ThreadState.) Poly)
(declare-fun %Poly%lib!tokens.ThreadState. (Poly) lib!tokens.ThreadState.)
(declare-fun Poly%lib!tokens.ThreadCheckedState. (lib!tokens.ThreadCheckedState.) Poly)
(declare-fun %Poly%lib!tokens.ThreadCheckedState. (Poly) lib!tokens.ThreadCheckedState.)
(declare-fun Poly%lib!tokens.Actor. (lib!tokens.Actor.) Poly)
(declare-fun %Poly%lib!tokens.Actor. (Poly) lib!tokens.Actor.)
(declare-fun Poly%lib!tokens.DelayFreeingActor. (lib!tokens.DelayFreeingActor.) Poly)
(declare-fun %Poly%lib!tokens.DelayFreeingActor. (Poly) lib!tokens.DelayFreeingActor.)
(declare-fun Poly%lib!types.PageInner. (lib!types.PageInner.) Poly)
(declare-fun %Poly%lib!types.PageInner. (Poly) lib!types.PageInner.)
(declare-fun Poly%lib!types.AtomicHeapPtr. (lib!types.AtomicHeapPtr.) Poly)
(declare-fun %Poly%lib!types.AtomicHeapPtr. (Poly) lib!types.AtomicHeapPtr.)
(declare-fun Poly%lib!types.InvariantPredicate_auto_AtomicHeapPtr_atomic. (lib!types.InvariantPredicate_auto_AtomicHeapPtr_atomic.) Poly)
(declare-fun %Poly%lib!types.InvariantPredicate_auto_AtomicHeapPtr_atomic. (Poly) lib!types.InvariantPredicate_auto_AtomicHeapPtr_atomic.)
(declare-fun Poly%lib!types.Page. (lib!types.Page.) Poly)
(declare-fun %Poly%lib!types.Page. (Poly) lib!types.Page.)
(declare-fun Poly%lib!types.PageSharedAccess. (lib!types.PageSharedAccess.) Poly)
(declare-fun %Poly%lib!types.PageSharedAccess. (Poly) lib!types.PageSharedAccess.)
(declare-fun Poly%lib!types.SegmentKind. (lib!types.SegmentKind.) Poly)
(declare-fun %Poly%lib!types.SegmentKind. (Poly) lib!types.SegmentKind.)
(declare-fun Poly%lib!types.SegmentHeaderMain. (lib!types.SegmentHeaderMain.) Poly)
(declare-fun %Poly%lib!types.SegmentHeaderMain. (Poly) lib!types.SegmentHeaderMain.)
(declare-fun Poly%lib!types.SegmentHeaderMain2. (lib!types.SegmentHeaderMain2.) Poly)
(declare-fun %Poly%lib!types.SegmentHeaderMain2. (Poly) lib!types.SegmentHeaderMain2.)
(declare-fun Poly%lib!types.SegmentHeader. (lib!types.SegmentHeader.) Poly)
(declare-fun %Poly%lib!types.SegmentHeader. (Poly) lib!types.SegmentHeader.)
(declare-fun Poly%lib!types.InvariantPredicate_auto_SegmentHeader_thread_id. (lib!types.InvariantPredicate_auto_SegmentHeader_thread_id.) Poly)
(declare-fun %Poly%lib!types.InvariantPredicate_auto_SegmentHeader_thread_id. (Poly) lib!types.InvariantPredicate_auto_SegmentHeader_thread_id.)
(declare-fun Poly%lib!types.SegmentSharedAccess. (lib!types.SegmentSharedAccess.) Poly)
(declare-fun %Poly%lib!types.SegmentSharedAccess. (Poly) lib!types.SegmentSharedAccess.)
(declare-fun Poly%lib!types.PageQueue. (lib!types.PageQueue.) Poly)
(declare-fun %Poly%lib!types.PageQueue. (Poly) lib!types.PageQueue.)
(declare-fun Poly%lib!types.Heap. (lib!types.Heap.) Poly)
(declare-fun %Poly%lib!types.Heap. (Poly) lib!types.Heap.)
(declare-fun Poly%lib!types.HeapSharedAccess. (lib!types.HeapSharedAccess.) Poly)
(declare-fun %Poly%lib!types.HeapSharedAccess. (Poly) lib!types.HeapSharedAccess.)
(declare-fun Poly%lib!types.SegmentsTld. (lib!types.SegmentsTld.) Poly)
(declare-fun %Poly%lib!types.SegmentsTld. (Poly) lib!types.SegmentsTld.)
(declare-fun Poly%lib!types.SpanQueueHeader. (lib!types.SpanQueueHeader.) Poly)
(declare-fun %Poly%lib!types.SpanQueueHeader. (Poly) lib!types.SpanQueueHeader.)
(declare-fun Poly%lib!types.Tld. (lib!types.Tld.) Poly)
(declare-fun %Poly%lib!types.Tld. (Poly) lib!types.Tld.)
(declare-fun Poly%lib!types.TldPtr. (lib!types.TldPtr.) Poly)
(declare-fun %Poly%lib!types.TldPtr. (Poly) lib!types.TldPtr.)
(declare-fun Poly%lib!linked_list.Node. (lib!linked_list.Node.) Poly)
(declare-fun %Poly%lib!linked_list.Node. (Poly) lib!linked_list.Node.)
(declare-fun Poly%lib!linked_list.ThreadLLSimple. (lib!linked_list.ThreadLLSimple.) Poly)
(declare-fun %Poly%lib!linked_list.ThreadLLSimple. (Poly) lib!linked_list.ThreadLLSimple.)
(declare-fun Poly%lib!linked_list.InvariantPredicate_auto_ThreadLLSimple_atomic. (lib!linked_list.InvariantPredicate_auto_ThreadLLSimple_atomic.) Poly)
(declare-fun %Poly%lib!linked_list.InvariantPredicate_auto_ThreadLLSimple_atomic. (Poly) lib!linked_list.InvariantPredicate_auto_ThreadLLSimple_atomic.)
(declare-fun Poly%lib!linked_list.ThreadLLWithDelayBits. (lib!linked_list.ThreadLLWithDelayBits.) Poly)
(declare-fun %Poly%lib!linked_list.ThreadLLWithDelayBits. (Poly) lib!linked_list.ThreadLLWithDelayBits.)
(declare-fun Poly%lib!linked_list.InvariantPredicate_auto_ThreadLLWithDelayBits_atomic. (lib!linked_list.InvariantPredicate_auto_ThreadLLWithDelayBits_atomic.) Poly)
(declare-fun %Poly%lib!linked_list.InvariantPredicate_auto_ThreadLLWithDelayBits_atomic. (Poly) lib!linked_list.InvariantPredicate_auto_ThreadLLWithDelayBits_atomic.)
(declare-fun Poly%tuple%0. (tuple%0.) Poly)
(declare-fun %Poly%tuple%0. (Poly) tuple%0.)
(declare-fun Poly%tuple%2. (tuple%2.) Poly)
(declare-fun %Poly%tuple%2. (Poly) tuple%2.)
(declare-fun Poly%tuple%4. (tuple%4.) Poly)
(declare-fun %Poly%tuple%4. (Poly) tuple%4.)
(assert (forall ((x %%Function%%)) (! (= x (%Poly%fun%1. (Poly%fun%1. x))) :pattern ((Poly%fun%1. x)))))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (x Poly)) (! (=> (has_type x (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)) (= x (Poly%fun%1. (%Poly%fun%1. x)))) :pattern ((has_type x (TYPE%fun%1. T%0&. T%0& T%1&. T%1&))))))
(declare-fun %%apply%%0 (%%Function%% Poly) Poly)
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (x %%Function%%)) (! (=> (forall ((T%0 Poly)) (! (=> (has_type T%0 T%0&) (has_type (%%apply%%0 x T%0) T%1&)) :pattern ((has_type (%%apply%%0 x T%0) T%1&)))) (has_type (Poly%fun%1. (mk_fun x)) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&))) :pattern ((has_type (Poly%fun%1. (mk_fun x)) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&))))))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (T%0 Poly) (x %%Function%%)) (! (=> (and (has_type (Poly%fun%1. x) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)) (has_type T%0 T%0&)) (has_type (%%apply%%0 x T%0) T%1&)) :pattern ((%%apply%%0 x T%0) (has_type (Poly%fun%1. x) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&))))))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (T%0 Poly) (x %%Function%%)) (! (=> (and (has_type (Poly%fun%1. x) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)) (has_type T%0 T%0&)) (height_lt (height (%%apply%%0 x T%0)) (height (fun_from_recursive_field (Poly%fun%1. (mk_fun x)))))) :pattern ((height (%%apply%%0 x T%0)) (has_type (Poly%fun%1. x) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&))))))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (deep Bool) (x Poly) (y Poly)) (! (=> (and (has_type x (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)) (has_type y (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)) (forall ((T%0 Poly)) (! (=> (has_type T%0 T%0&) (ext_eq deep T%1& (%%apply%%0 (%Poly%fun%1. x) T%0) (%%apply%%0 (%Poly%fun%1. y) T%0))) :pattern ((ext_eq deep T%1& (%%apply%%0 (%Poly%fun%1. x) T%0) (%%apply%%0 (%Poly%fun%1. y) T%0)))))) (ext_eq deep (TYPE%fun%1. T%0&. T%0& T%1&. T%1&) x y)) :pattern ((ext_eq deep (TYPE%fun%1. T%0&. T%0& T%1&. T%1&) x y)))))
(assert (forall ((x %%Function%%)) (! (= x (%Poly%array%. (Poly%array%. x))) :pattern ((Poly%array%. x)))))
(assert (forall ((T&. Dcr) (T& Type) (N&. Dcr) (N& Type) (x Poly)) (! (=> (has_type x (ARRAY T&. T& N&. N&)) (= x (Poly%array%. (%Poly%array%. x)))) :pattern ((has_type x (ARRAY T&. T& N&. N&))))))
(assert (forall ((x lib!commit_mask.CommitMask.)) (! (= x (%Poly%lib!commit_mask.CommitMask. (Poly%lib!commit_mask.CommitMask. x))) :pattern ((Poly%lib!commit_mask.CommitMask. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!commit_mask.CommitMask.) (= x (Poly%lib!commit_mask.CommitMask. (%Poly%lib!commit_mask.CommitMask. x)))) :pattern ((has_type x TYPE%lib!commit_mask.CommitMask.)))))
(assert (forall ((x lib!commit_mask.CommitMask.)) (! (has_type (Poly%lib!commit_mask.CommitMask. x) TYPE%lib!commit_mask.CommitMask.) :pattern ((has_type (Poly%lib!commit_mask.CommitMask. x) TYPE%lib!commit_mask.CommitMask.)))))
(assert (forall ((x lib!linked_list.LL.)) (! (= x (%Poly%lib!linked_list.LL. (Poly%lib!linked_list.LL. x))) :pattern ((Poly%lib!linked_list.LL. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!linked_list.LL.) (= x (Poly%lib!linked_list.LL. (%Poly%lib!linked_list.LL. x)))) :pattern ((has_type x TYPE%lib!linked_list.LL.)))))
(assert (forall ((x lib!linked_list.LL.)) (! (has_type (Poly%lib!linked_list.LL. x) TYPE%lib!linked_list.LL.) :pattern ((has_type (Poly%lib!linked_list.LL. x) TYPE%lib!linked_list.LL.)))))
(assert (forall ((x lib!linked_list.StuffAgree.Instance.)) (! (= x (%Poly%lib!linked_list.StuffAgree.Instance. (Poly%lib!linked_list.StuffAgree.Instance. x))) :pattern ((Poly%lib!linked_list.StuffAgree.Instance. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!linked_list.StuffAgree.Instance.) (= x (Poly%lib!linked_list.StuffAgree.Instance. (%Poly%lib!linked_list.StuffAgree.Instance. x)))) :pattern ((has_type x TYPE%lib!linked_list.StuffAgree.Instance.)))))
(assert (forall ((x lib!linked_list.StuffAgree.Instance.)) (! (has_type (Poly%lib!linked_list.StuffAgree.Instance. x) TYPE%lib!linked_list.StuffAgree.Instance.) :pattern ((has_type (Poly%lib!linked_list.StuffAgree.Instance. x) TYPE%lib!linked_list.StuffAgree.Instance.)))))
(assert (forall ((x lib!linked_list.StuffAgree.x.)) (! (= x (%Poly%lib!linked_list.StuffAgree.x. (Poly%lib!linked_list.StuffAgree.x. x))) :pattern ((Poly%lib!linked_list.StuffAgree.x. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!linked_list.StuffAgree.x.) (= x (Poly%lib!linked_list.StuffAgree.x. (%Poly%lib!linked_list.StuffAgree.x. x)))) :pattern ((has_type x TYPE%lib!linked_list.StuffAgree.x.)))))
(assert (forall ((x lib!linked_list.StuffAgree.x.)) (! (has_type (Poly%lib!linked_list.StuffAgree.x. x) TYPE%lib!linked_list.StuffAgree.x.) :pattern ((has_type (Poly%lib!linked_list.StuffAgree.x. x) TYPE%lib!linked_list.StuffAgree.x.)))))
(assert (forall ((x lib!linked_list.StuffAgree.y.)) (! (= x (%Poly%lib!linked_list.StuffAgree.y. (Poly%lib!linked_list.StuffAgree.y. x))) :pattern ((Poly%lib!linked_list.StuffAgree.y. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!linked_list.StuffAgree.y.) (= x (Poly%lib!linked_list.StuffAgree.y. (%Poly%lib!linked_list.StuffAgree.y. x)))) :pattern ((has_type x TYPE%lib!linked_list.StuffAgree.y.)))))
(assert (forall ((x lib!linked_list.StuffAgree.y.)) (! (has_type (Poly%lib!linked_list.StuffAgree.y. x) TYPE%lib!linked_list.StuffAgree.y.) :pattern ((has_type (Poly%lib!linked_list.StuffAgree.y. x) TYPE%lib!linked_list.StuffAgree.y.)))))
(assert (forall ((x lib!tokens.Mim.Instance.)) (! (= x (%Poly%lib!tokens.Mim.Instance. (Poly%lib!tokens.Mim.Instance. x))) :pattern ((Poly%lib!tokens.Mim.Instance. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!tokens.Mim.Instance.) (= x (Poly%lib!tokens.Mim.Instance. (%Poly%lib!tokens.Mim.Instance. x)))) :pattern ((has_type x TYPE%lib!tokens.Mim.Instance.)))))
(assert (forall ((x lib!tokens.Mim.Instance.)) (! (has_type (Poly%lib!tokens.Mim.Instance. x) TYPE%lib!tokens.Mim.Instance.) :pattern ((has_type (Poly%lib!tokens.Mim.Instance. x) TYPE%lib!tokens.Mim.Instance.)))))
(assert (forall ((x lib!tokens.Mim.delay.)) (! (= x (%Poly%lib!tokens.Mim.delay. (Poly%lib!tokens.Mim.delay. x))) :pattern ((Poly%lib!tokens.Mim.delay. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!tokens.Mim.delay.) (= x (Poly%lib!tokens.Mim.delay. (%Poly%lib!tokens.Mim.delay. x)))) :pattern ((has_type x TYPE%lib!tokens.Mim.delay.)))))
(assert (forall ((x lib!tokens.Mim.delay.)) (! (has_type (Poly%lib!tokens.Mim.delay. x) TYPE%lib!tokens.Mim.delay.) :pattern ((has_type (Poly%lib!tokens.Mim.delay. x) TYPE%lib!tokens.Mim.delay.)))))
(assert (forall ((x lib!tokens.Mim.heap_of_page.)) (! (= x (%Poly%lib!tokens.Mim.heap_of_page. (Poly%lib!tokens.Mim.heap_of_page. x))) :pattern ((Poly%lib!tokens.Mim.heap_of_page. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!tokens.Mim.heap_of_page.) (= x (Poly%lib!tokens.Mim.heap_of_page. (%Poly%lib!tokens.Mim.heap_of_page. x)))) :pattern ((has_type x TYPE%lib!tokens.Mim.heap_of_page.)))))
(assert (forall ((x lib!tokens.Mim.heap_of_page.)) (! (has_type (Poly%lib!tokens.Mim.heap_of_page. x) TYPE%lib!tokens.Mim.heap_of_page.) :pattern ((has_type (Poly%lib!tokens.Mim.heap_of_page. x) TYPE%lib!tokens.Mim.heap_of_page.)))))
(assert (forall ((x lib!tokens.Mim.thread_of_segment.)) (! (= x (%Poly%lib!tokens.Mim.thread_of_segment. (Poly%lib!tokens.Mim.thread_of_segment. x))) :pattern ((Poly%lib!tokens.Mim.thread_of_segment. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!tokens.Mim.thread_of_segment.) (= x (Poly%lib!tokens.Mim.thread_of_segment. (%Poly%lib!tokens.Mim.thread_of_segment. x)))) :pattern ((has_type x TYPE%lib!tokens.Mim.thread_of_segment.)))))
(assert (forall ((x lib!tokens.Mim.thread_of_segment.)) (! (has_type (Poly%lib!tokens.Mim.thread_of_segment. x) TYPE%lib!tokens.Mim.thread_of_segment.) :pattern ((has_type (Poly%lib!tokens.Mim.thread_of_segment. x) TYPE%lib!tokens.Mim.thread_of_segment.)))))
(assert (forall ((x lib!types.BoolAgree.Instance.)) (! (= x (%Poly%lib!types.BoolAgree.Instance. (Poly%lib!types.BoolAgree.Instance. x))) :pattern ((Poly%lib!types.BoolAgree.Instance. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.BoolAgree.Instance.) (= x (Poly%lib!types.BoolAgree.Instance. (%Poly%lib!types.BoolAgree.Instance. x)))) :pattern ((has_type x TYPE%lib!types.BoolAgree.Instance.)))))
(assert (forall ((x lib!types.BoolAgree.Instance.)) (! (has_type (Poly%lib!types.BoolAgree.Instance. x) TYPE%lib!types.BoolAgree.Instance.) :pattern ((has_type (Poly%lib!types.BoolAgree.Instance. x) TYPE%lib!types.BoolAgree.Instance.)))))
(assert (forall ((x lib!types.BoolAgree.x.)) (! (= x (%Poly%lib!types.BoolAgree.x. (Poly%lib!types.BoolAgree.x. x))) :pattern ((Poly%lib!types.BoolAgree.x. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.BoolAgree.x.) (= x (Poly%lib!types.BoolAgree.x. (%Poly%lib!types.BoolAgree.x. x)))) :pattern ((has_type x TYPE%lib!types.BoolAgree.x.)))))
(assert (forall ((x lib!types.BoolAgree.x.)) (! (has_type (Poly%lib!types.BoolAgree.x. x) TYPE%lib!types.BoolAgree.x.) :pattern ((has_type (Poly%lib!types.BoolAgree.x. x) TYPE%lib!types.BoolAgree.x.)))))
(assert (forall ((x lib!types.BoolAgree.y.)) (! (= x (%Poly%lib!types.BoolAgree.y. (Poly%lib!types.BoolAgree.y. x))) :pattern ((Poly%lib!types.BoolAgree.y. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.BoolAgree.y.) (= x (Poly%lib!types.BoolAgree.y. (%Poly%lib!types.BoolAgree.y. x)))) :pattern ((has_type x TYPE%lib!types.BoolAgree.y.)))))
(assert (forall ((x lib!types.BoolAgree.y.)) (! (has_type (Poly%lib!types.BoolAgree.y. x) TYPE%lib!types.BoolAgree.y.) :pattern ((has_type (Poly%lib!types.BoolAgree.y. x) TYPE%lib!types.BoolAgree.y.)))))
(assert (forall ((x vstd!atomic.PAtomicU64.)) (! (= x (%Poly%vstd!atomic.PAtomicU64. (Poly%vstd!atomic.PAtomicU64. x))) :pattern ((Poly%vstd!atomic.PAtomicU64. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%vstd!atomic.PAtomicU64.) (= x (Poly%vstd!atomic.PAtomicU64. (%Poly%vstd!atomic.PAtomicU64. x)))) :pattern ((has_type x TYPE%vstd!atomic.PAtomicU64.)))))
(assert (forall ((x vstd!atomic.PAtomicU64.)) (! (has_type (Poly%vstd!atomic.PAtomicU64. x) TYPE%vstd!atomic.PAtomicU64.) :pattern ((has_type (Poly%vstd!atomic.PAtomicU64. x) TYPE%vstd!atomic.PAtomicU64.)))))
(assert (forall ((x vstd!atomic.PermissionU64.)) (! (= x (%Poly%vstd!atomic.PermissionU64. (Poly%vstd!atomic.PermissionU64. x))) :pattern ((Poly%vstd!atomic.PermissionU64. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%vstd!atomic.PermissionU64.) (= x (Poly%vstd!atomic.PermissionU64. (%Poly%vstd!atomic.PermissionU64. x)))) :pattern ((has_type x TYPE%vstd!atomic.PermissionU64.)))))
(assert (forall ((x vstd!atomic.PermissionU64.)) (! (has_type (Poly%vstd!atomic.PermissionU64. x) TYPE%vstd!atomic.PermissionU64.) :pattern ((has_type (Poly%vstd!atomic.PermissionU64. x) TYPE%vstd!atomic.PermissionU64.)))))
(assert (forall ((x vstd!cell.PCell<u32.>.)) (! (= x (%Poly%vstd!cell.PCell<u32.>. (Poly%vstd!cell.PCell<u32.>. x))) :pattern ((Poly%vstd!cell.PCell<u32.>. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x (TYPE%vstd!cell.PCell. $ (UINT 32))) (= x (Poly%vstd!cell.PCell<u32.>. (%Poly%vstd!cell.PCell<u32.>. x)))) :pattern ((has_type x (TYPE%vstd!cell.PCell. $ (UINT 32)))))))
(assert (forall ((x vstd!cell.PCell<u32.>.)) (! (has_type (Poly%vstd!cell.PCell<u32.>. x) (TYPE%vstd!cell.PCell. $ (UINT 32))) :pattern ((has_type (Poly%vstd!cell.PCell<u32.>. x) (TYPE%vstd!cell.PCell. $ (UINT 32)))))))
(assert (forall ((x vstd!cell.PCell<usize.>.)) (! (= x (%Poly%vstd!cell.PCell<usize.>. (Poly%vstd!cell.PCell<usize.>. x))) :pattern ((Poly%vstd!cell.PCell<usize.>. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x (TYPE%vstd!cell.PCell. $ (UINT SZ))) (= x (Poly%vstd!cell.PCell<usize.>. (%Poly%vstd!cell.PCell<usize.>. x)))) :pattern ((has_type x (TYPE%vstd!cell.PCell. $ (UINT SZ)))))))
(assert (forall ((x vstd!cell.PCell<usize.>.)) (! (has_type (Poly%vstd!cell.PCell<usize.>. x) (TYPE%vstd!cell.PCell. $ (UINT SZ))) :pattern ((has_type (Poly%vstd!cell.PCell<usize.>. x) (TYPE%vstd!cell.PCell. $ (UINT SZ)))))))
(assert (forall ((x vstd!cell.PCell<lib!types.PageInner.>.)) (! (= x (%Poly%vstd!cell.PCell<lib!types.PageInner.>. (Poly%vstd!cell.PCell<lib!types.PageInner.>. x))) :pattern ((Poly%vstd!cell.PCell<lib!types.PageInner.>. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x (TYPE%vstd!cell.PCell. $ TYPE%lib!types.PageInner.)) (= x (Poly%vstd!cell.PCell<lib!types.PageInner.>. (%Poly%vstd!cell.PCell<lib!types.PageInner.>. x)))) :pattern ((has_type x (TYPE%vstd!cell.PCell. $ TYPE%lib!types.PageInner.))))))
(assert (forall ((x vstd!cell.PCell<lib!types.PageInner.>.)) (! (has_type (Poly%vstd!cell.PCell<lib!types.PageInner.>. x) (TYPE%vstd!cell.PCell. $ TYPE%lib!types.PageInner.)) :pattern ((has_type (Poly%vstd!cell.PCell<lib!types.PageInner.>. x) (TYPE%vstd!cell.PCell. $ TYPE%lib!types.PageInner.))))))
(assert (forall ((x vstd!cell.PCell<lib!types.SegmentHeaderMain.>.)) (! (= x (%Poly%vstd!cell.PCell<lib!types.SegmentHeaderMain.>. (Poly%vstd!cell.PCell<lib!types.SegmentHeaderMain.>. x))) :pattern ((Poly%vstd!cell.PCell<lib!types.SegmentHeaderMain.>. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x (TYPE%vstd!cell.PCell. $ TYPE%lib!types.SegmentHeaderMain.)) (= x (Poly%vstd!cell.PCell<lib!types.SegmentHeaderMain.>. (%Poly%vstd!cell.PCell<lib!types.SegmentHeaderMain.>. x)))) :pattern ((has_type x (TYPE%vstd!cell.PCell. $ TYPE%lib!types.SegmentHeaderMain.))))))
(assert (forall ((x vstd!cell.PCell<lib!types.SegmentHeaderMain.>.)) (! (has_type (Poly%vstd!cell.PCell<lib!types.SegmentHeaderMain.>. x) (TYPE%vstd!cell.PCell. $ TYPE%lib!types.SegmentHeaderMain.)) :pattern ((has_type (Poly%vstd!cell.PCell<lib!types.SegmentHeaderMain.>. x) (TYPE%vstd!cell.PCell. $ TYPE%lib!types.SegmentHeaderMain.))))))
(assert (forall ((x vstd!cell.PCell<lib!types.SegmentHeaderMain2.>.)) (! (= x (%Poly%vstd!cell.PCell<lib!types.SegmentHeaderMain2.>. (Poly%vstd!cell.PCell<lib!types.SegmentHeaderMain2.>. x))) :pattern ((Poly%vstd!cell.PCell<lib!types.SegmentHeaderMain2.>. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x (TYPE%vstd!cell.PCell. $ TYPE%lib!types.SegmentHeaderMain2.)) (= x (Poly%vstd!cell.PCell<lib!types.SegmentHeaderMain2.>. (%Poly%vstd!cell.PCell<lib!types.SegmentHeaderMain2.>. x)))) :pattern ((has_type x (TYPE%vstd!cell.PCell. $ TYPE%lib!types.SegmentHeaderMain2.))))))
(assert (forall ((x vstd!cell.PCell<lib!types.SegmentHeaderMain2.>.)) (! (has_type (Poly%vstd!cell.PCell<lib!types.SegmentHeaderMain2.>. x) (TYPE%vstd!cell.PCell. $ TYPE%lib!types.SegmentHeaderMain2.)) :pattern ((has_type (Poly%vstd!cell.PCell<lib!types.SegmentHeaderMain2.>. x) (TYPE%vstd!cell.PCell. $ TYPE%lib!types.SegmentHeaderMain2.))))))
(assert (forall ((x vstd!cell.PCell<ptr_mut%<lib!types.Page.>.>.)) (! (= x (%Poly%vstd!cell.PCell<ptr_mut%<lib!types.Page.>.>. (Poly%vstd!cell.PCell<ptr_mut%<lib!types.Page.>.>. x))) :pattern ((Poly%vstd!cell.PCell<ptr_mut%<lib!types.Page.>.>. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x (TYPE%vstd!cell.PCell. $ (PTR $ TYPE%lib!types.Page.))) (= x (Poly%vstd!cell.PCell<ptr_mut%<lib!types.Page.>.>. (%Poly%vstd!cell.PCell<ptr_mut%<lib!types.Page.>.>. x)))) :pattern ((has_type x (TYPE%vstd!cell.PCell. $ (PTR $ TYPE%lib!types.Page.)))))))
(assert (forall ((x vstd!cell.PCell<ptr_mut%<lib!types.Page.>.>.)) (! (has_type (Poly%vstd!cell.PCell<ptr_mut%<lib!types.Page.>.>. x) (TYPE%vstd!cell.PCell. $ (PTR $ TYPE%lib!types.Page.))) :pattern ((has_type (Poly%vstd!cell.PCell<ptr_mut%<lib!types.Page.>.>. x) (TYPE%vstd!cell.PCell. $ (PTR $ TYPE%lib!types.Page.)))))))
(assert (forall ((x vstd!map.Map<lib!tokens.PageId./lib!tokens.PageState.>.)) (! (= x (%Poly%vstd!map.Map<lib!tokens.PageId./lib!tokens.PageState.>. (Poly%vstd!map.Map<lib!tokens.PageId./lib!tokens.PageState.>. x))) :pattern ((Poly%vstd!map.Map<lib!tokens.PageId./lib!tokens.PageState.>. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x (TYPE%vstd!map.Map. $ TYPE%lib!tokens.PageId. $ TYPE%lib!tokens.PageState.)) (= x (Poly%vstd!map.Map<lib!tokens.PageId./lib!tokens.PageState.>. (%Poly%vstd!map.Map<lib!tokens.PageId./lib!tokens.PageState.>. x)))) :pattern ((has_type x (TYPE%vstd!map.Map. $ TYPE%lib!tokens.PageId. $ TYPE%lib!tokens.PageState.))))))
(assert (forall ((x vstd!map.Map<lib!tokens.PageId./lib!tokens.PageState.>.)) (! (has_type (Poly%vstd!map.Map<lib!tokens.PageId./lib!tokens.PageState.>. x) (TYPE%vstd!map.Map. $ TYPE%lib!tokens.PageId. $ TYPE%lib!tokens.PageState.)) :pattern ((has_type (Poly%vstd!map.Map<lib!tokens.PageId./lib!tokens.PageState.>. x) (TYPE%vstd!map.Map. $ TYPE%lib!tokens.PageId. $ TYPE%lib!tokens.PageState.))))))
(assert (forall ((x vstd!map.Map<lib!tokens.SegmentId./lib!tokens.SegmentState.>.)) (! (= x (%Poly%vstd!map.Map<lib!tokens.SegmentId./lib!tokens.SegmentState.>. (Poly%vstd!map.Map<lib!tokens.SegmentId./lib!tokens.SegmentState.>. x))) :pattern ((Poly%vstd!map.Map<lib!tokens.SegmentId./lib!tokens.SegmentState.>. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x (TYPE%vstd!map.Map. $ TYPE%lib!tokens.SegmentId. $ TYPE%lib!tokens.SegmentState.)) (= x (Poly%vstd!map.Map<lib!tokens.SegmentId./lib!tokens.SegmentState.>. (%Poly%vstd!map.Map<lib!tokens.SegmentId./lib!tokens.SegmentState.>. x)))) :pattern ((has_type x (TYPE%vstd!map.Map. $ TYPE%lib!tokens.SegmentId. $ TYPE%lib!tokens.SegmentState.))))))
(assert (forall ((x vstd!map.Map<lib!tokens.SegmentId./lib!tokens.SegmentState.>.)) (! (has_type (Poly%vstd!map.Map<lib!tokens.SegmentId./lib!tokens.SegmentState.>. x) (TYPE%vstd!map.Map. $ TYPE%lib!tokens.SegmentId. $ TYPE%lib!tokens.SegmentState.)) :pattern ((has_type (Poly%vstd!map.Map<lib!tokens.SegmentId./lib!tokens.SegmentState.>. x) (TYPE%vstd!map.Map. $ TYPE%lib!tokens.SegmentId. $ TYPE%lib!tokens.SegmentState.))))))
(assert (forall ((x vstd!raw_ptr.DynMetadata.)) (! (= x (%Poly%vstd!raw_ptr.DynMetadata. (Poly%vstd!raw_ptr.DynMetadata. x))) :pattern ((Poly%vstd!raw_ptr.DynMetadata. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%vstd!raw_ptr.DynMetadata.) (= x (Poly%vstd!raw_ptr.DynMetadata. (%Poly%vstd!raw_ptr.DynMetadata. x)))) :pattern ((has_type x TYPE%vstd!raw_ptr.DynMetadata.)))))
(assert (forall ((x vstd!raw_ptr.DynMetadata.)) (! (has_type (Poly%vstd!raw_ptr.DynMetadata. x) TYPE%vstd!raw_ptr.DynMetadata.) :pattern ((has_type (Poly%vstd!raw_ptr.DynMetadata. x) TYPE%vstd!raw_ptr.DynMetadata.)))))
(assert (forall ((x vstd!raw_ptr.IsExposed.)) (! (= x (%Poly%vstd!raw_ptr.IsExposed. (Poly%vstd!raw_ptr.IsExposed. x))) :pattern ((Poly%vstd!raw_ptr.IsExposed. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%vstd!raw_ptr.IsExposed.) (= x (Poly%vstd!raw_ptr.IsExposed. (%Poly%vstd!raw_ptr.IsExposed. x)))) :pattern ((has_type x TYPE%vstd!raw_ptr.IsExposed.)))))
(assert (forall ((x vstd!raw_ptr.IsExposed.)) (! (has_type (Poly%vstd!raw_ptr.IsExposed. x) TYPE%vstd!raw_ptr.IsExposed.) :pattern ((has_type (Poly%vstd!raw_ptr.IsExposed. x) TYPE%vstd!raw_ptr.IsExposed.)))))
(assert (forall ((x vstd!raw_ptr.PointsTo<lib!types.Heap.>.)) (! (= x (%Poly%vstd!raw_ptr.PointsTo<lib!types.Heap.>. (Poly%vstd!raw_ptr.PointsTo<lib!types.Heap.>. x))) :pattern ((Poly%vstd!raw_ptr.PointsTo<lib!types.Heap.>. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x (TYPE%vstd!raw_ptr.PointsTo. $ TYPE%lib!types.Heap.)) (= x (Poly%vstd!raw_ptr.PointsTo<lib!types.Heap.>. (%Poly%vstd!raw_ptr.PointsTo<lib!types.Heap.>. x)))) :pattern ((has_type x (TYPE%vstd!raw_ptr.PointsTo. $ TYPE%lib!types.Heap.))))))
(assert (forall ((x vstd!raw_ptr.PointsTo<lib!types.Heap.>.)) (! (has_type (Poly%vstd!raw_ptr.PointsTo<lib!types.Heap.>. x) (TYPE%vstd!raw_ptr.PointsTo. $ TYPE%lib!types.Heap.)) :pattern ((has_type (Poly%vstd!raw_ptr.PointsTo<lib!types.Heap.>. x) (TYPE%vstd!raw_ptr.PointsTo. $ TYPE%lib!types.Heap.))))))
(assert (forall ((x vstd!raw_ptr.PointsTo<lib!types.Page.>.)) (! (= x (%Poly%vstd!raw_ptr.PointsTo<lib!types.Page.>. (Poly%vstd!raw_ptr.PointsTo<lib!types.Page.>. x))) :pattern ((Poly%vstd!raw_ptr.PointsTo<lib!types.Page.>. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x (TYPE%vstd!raw_ptr.PointsTo. $ TYPE%lib!types.Page.)) (= x (Poly%vstd!raw_ptr.PointsTo<lib!types.Page.>. (%Poly%vstd!raw_ptr.PointsTo<lib!types.Page.>. x)))) :pattern ((has_type x (TYPE%vstd!raw_ptr.PointsTo. $ TYPE%lib!types.Page.))))))
(assert (forall ((x vstd!raw_ptr.PointsTo<lib!types.Page.>.)) (! (has_type (Poly%vstd!raw_ptr.PointsTo<lib!types.Page.>. x) (TYPE%vstd!raw_ptr.PointsTo. $ TYPE%lib!types.Page.)) :pattern ((has_type (Poly%vstd!raw_ptr.PointsTo<lib!types.Page.>. x) (TYPE%vstd!raw_ptr.PointsTo. $ TYPE%lib!types.Page.))))))
(assert (forall ((x vstd!raw_ptr.PointsTo<lib!types.SegmentHeader.>.)) (! (= x (%Poly%vstd!raw_ptr.PointsTo<lib!types.SegmentHeader.>. (Poly%vstd!raw_ptr.PointsTo<lib!types.SegmentHeader.>. x))) :pattern ((Poly%vstd!raw_ptr.PointsTo<lib!types.SegmentHeader.>. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x (TYPE%vstd!raw_ptr.PointsTo. $ TYPE%lib!types.SegmentHeader.)) (= x (Poly%vstd!raw_ptr.PointsTo<lib!types.SegmentHeader.>. (%Poly%vstd!raw_ptr.PointsTo<lib!types.SegmentHeader.>. x)))) :pattern ((has_type x (TYPE%vstd!raw_ptr.PointsTo. $ TYPE%lib!types.SegmentHeader.))))))
(assert (forall ((x vstd!raw_ptr.PointsTo<lib!types.SegmentHeader.>.)) (! (has_type (Poly%vstd!raw_ptr.PointsTo<lib!types.SegmentHeader.>. x) (TYPE%vstd!raw_ptr.PointsTo. $ TYPE%lib!types.SegmentHeader.)) :pattern ((has_type (Poly%vstd!raw_ptr.PointsTo<lib!types.SegmentHeader.>. x) (TYPE%vstd!raw_ptr.PointsTo. $ TYPE%lib!types.SegmentHeader.))))))
(assert (forall ((x vstd!raw_ptr.Provenance.)) (! (= x (%Poly%vstd!raw_ptr.Provenance. (Poly%vstd!raw_ptr.Provenance. x))) :pattern ((Poly%vstd!raw_ptr.Provenance. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%vstd!raw_ptr.Provenance.) (= x (Poly%vstd!raw_ptr.Provenance. (%Poly%vstd!raw_ptr.Provenance. x)))) :pattern ((has_type x TYPE%vstd!raw_ptr.Provenance.)))))
(assert (forall ((x vstd!raw_ptr.Provenance.)) (! (has_type (Poly%vstd!raw_ptr.Provenance. x) TYPE%vstd!raw_ptr.Provenance.) :pattern ((has_type (Poly%vstd!raw_ptr.Provenance. x) TYPE%vstd!raw_ptr.Provenance.)))))
(assert (forall ((x vstd!set.Set<lib!tokens.HeapId.>.)) (! (= x (%Poly%vstd!set.Set<lib!tokens.HeapId.>. (Poly%vstd!set.Set<lib!tokens.HeapId.>. x))) :pattern ((Poly%vstd!set.Set<lib!tokens.HeapId.>. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x (TYPE%vstd!set.Set. $ TYPE%lib!tokens.HeapId.)) (= x (Poly%vstd!set.Set<lib!tokens.HeapId.>. (%Poly%vstd!set.Set<lib!tokens.HeapId.>. x)))) :pattern ((has_type x (TYPE%vstd!set.Set. $ TYPE%lib!tokens.HeapId.))))))
(assert (forall ((x vstd!set.Set<lib!tokens.HeapId.>.)) (! (has_type (Poly%vstd!set.Set<lib!tokens.HeapId.>. x) (TYPE%vstd!set.Set. $ TYPE%lib!tokens.HeapId.)) :pattern ((has_type (Poly%vstd!set.Set<lib!tokens.HeapId.>. x) (TYPE%vstd!set.Set. $ TYPE%lib!tokens.HeapId.))))))
(assert (forall ((x vstd!set.Set<lib!tokens.PageId.>.)) (! (= x (%Poly%vstd!set.Set<lib!tokens.PageId.>. (Poly%vstd!set.Set<lib!tokens.PageId.>. x))) :pattern ((Poly%vstd!set.Set<lib!tokens.PageId.>. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x (TYPE%vstd!set.Set. $ TYPE%lib!tokens.PageId.)) (= x (Poly%vstd!set.Set<lib!tokens.PageId.>. (%Poly%vstd!set.Set<lib!tokens.PageId.>. x)))) :pattern ((has_type x (TYPE%vstd!set.Set. $ TYPE%lib!tokens.PageId.))))))
(assert (forall ((x vstd!set.Set<lib!tokens.PageId.>.)) (! (has_type (Poly%vstd!set.Set<lib!tokens.PageId.>. x) (TYPE%vstd!set.Set. $ TYPE%lib!tokens.PageId.)) :pattern ((has_type (Poly%vstd!set.Set<lib!tokens.PageId.>. x) (TYPE%vstd!set.Set. $ TYPE%lib!tokens.PageId.))))))
(assert (forall ((x vstd!set.Set<lib!tokens.SegmentId.>.)) (! (= x (%Poly%vstd!set.Set<lib!tokens.SegmentId.>. (Poly%vstd!set.Set<lib!tokens.SegmentId.>. x))) :pattern ((Poly%vstd!set.Set<lib!tokens.SegmentId.>. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x (TYPE%vstd!set.Set. $ TYPE%lib!tokens.SegmentId.)) (= x (Poly%vstd!set.Set<lib!tokens.SegmentId.>. (%Poly%vstd!set.Set<lib!tokens.SegmentId.>. x)))) :pattern ((has_type x (TYPE%vstd!set.Set. $ TYPE%lib!tokens.SegmentId.))))))
(assert (forall ((x vstd!set.Set<lib!tokens.SegmentId.>.)) (! (has_type (Poly%vstd!set.Set<lib!tokens.SegmentId.>. x) (TYPE%vstd!set.Set. $ TYPE%lib!tokens.SegmentId.)) :pattern ((has_type (Poly%vstd!set.Set<lib!tokens.SegmentId.>. x) (TYPE%vstd!set.Set. $ TYPE%lib!tokens.SegmentId.))))))
(assert (forall ((x ptr_mut%<lib!linked_list.Node.>.)) (! (= x (%Poly%ptr_mut%<lib!linked_list.Node.>. (Poly%ptr_mut%<lib!linked_list.Node.>. x))) :pattern ((Poly%ptr_mut%<lib!linked_list.Node.>. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x (PTR $ TYPE%lib!linked_list.Node.)) (= x (Poly%ptr_mut%<lib!linked_list.Node.>. (%Poly%ptr_mut%<lib!linked_list.Node.>. x)))) :pattern ((has_type x (PTR $ TYPE%lib!linked_list.Node.))))))
(assert (forall ((x ptr_mut%<lib!linked_list.Node.>.)) (! (has_type (Poly%ptr_mut%<lib!linked_list.Node.>. x) (PTR $ TYPE%lib!linked_list.Node.)) :pattern ((has_type (Poly%ptr_mut%<lib!linked_list.Node.>. x) (PTR $ TYPE%lib!linked_list.Node.))))))
(assert (forall ((x ptr_mut%<lib!types.Heap.>.)) (! (= x (%Poly%ptr_mut%<lib!types.Heap.>. (Poly%ptr_mut%<lib!types.Heap.>. x))) :pattern ((Poly%ptr_mut%<lib!types.Heap.>. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x (PTR $ TYPE%lib!types.Heap.)) (= x (Poly%ptr_mut%<lib!types.Heap.>. (%Poly%ptr_mut%<lib!types.Heap.>. x)))) :pattern ((has_type x (PTR $ TYPE%lib!types.Heap.))))))
(assert (forall ((x ptr_mut%<lib!types.Heap.>.)) (! (has_type (Poly%ptr_mut%<lib!types.Heap.>. x) (PTR $ TYPE%lib!types.Heap.)) :pattern ((has_type (Poly%ptr_mut%<lib!types.Heap.>. x) (PTR $ TYPE%lib!types.Heap.))))))
(assert (forall ((x ptr_mut%<lib!types.Page.>.)) (! (= x (%Poly%ptr_mut%<lib!types.Page.>. (Poly%ptr_mut%<lib!types.Page.>. x))) :pattern ((Poly%ptr_mut%<lib!types.Page.>. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x (PTR $ TYPE%lib!types.Page.)) (= x (Poly%ptr_mut%<lib!types.Page.>. (%Poly%ptr_mut%<lib!types.Page.>. x)))) :pattern ((has_type x (PTR $ TYPE%lib!types.Page.))))))
(assert (forall ((x ptr_mut%<lib!types.Page.>.)) (! (has_type (Poly%ptr_mut%<lib!types.Page.>. x) (PTR $ TYPE%lib!types.Page.)) :pattern ((has_type (Poly%ptr_mut%<lib!types.Page.>. x) (PTR $ TYPE%lib!types.Page.))))))
(assert (forall ((x ptr_mut%<lib!types.SegmentHeader.>.)) (! (= x (%Poly%ptr_mut%<lib!types.SegmentHeader.>. (Poly%ptr_mut%<lib!types.SegmentHeader.>. x))) :pattern ((Poly%ptr_mut%<lib!types.SegmentHeader.>. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x (PTR $ TYPE%lib!types.SegmentHeader.)) (= x (Poly%ptr_mut%<lib!types.SegmentHeader.>. (%Poly%ptr_mut%<lib!types.SegmentHeader.>. x)))) :pattern ((has_type x (PTR $ TYPE%lib!types.SegmentHeader.))))))
(assert (forall ((x ptr_mut%<lib!types.SegmentHeader.>.)) (! (has_type (Poly%ptr_mut%<lib!types.SegmentHeader.>. x) (PTR $ TYPE%lib!types.SegmentHeader.)) :pattern ((has_type (Poly%ptr_mut%<lib!types.SegmentHeader.>. x) (PTR $ TYPE%lib!types.SegmentHeader.))))))
(assert (forall ((x ptr_mut%<lib!types.Tld.>.)) (! (= x (%Poly%ptr_mut%<lib!types.Tld.>. (Poly%ptr_mut%<lib!types.Tld.>. x))) :pattern ((Poly%ptr_mut%<lib!types.Tld.>. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x (PTR $ TYPE%lib!types.Tld.)) (= x (Poly%ptr_mut%<lib!types.Tld.>. (%Poly%ptr_mut%<lib!types.Tld.>. x)))) :pattern ((has_type x (PTR $ TYPE%lib!types.Tld.))))))
(assert (forall ((x ptr_mut%<lib!types.Tld.>.)) (! (has_type (Poly%ptr_mut%<lib!types.Tld.>. x) (PTR $ TYPE%lib!types.Tld.)) :pattern ((has_type (Poly%ptr_mut%<lib!types.Tld.>. x) (PTR $ TYPE%lib!types.Tld.))))))
(assert (forall ((x allocator_global%.)) (! (= x (%Poly%allocator_global%. (Poly%allocator_global%. x))) :pattern ((Poly%allocator_global%. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x ALLOCATOR_GLOBAL) (= x (Poly%allocator_global%. (%Poly%allocator_global%. x)))) :pattern ((has_type x ALLOCATOR_GLOBAL)))))
(assert (forall ((x allocator_global%.)) (! (has_type (Poly%allocator_global%. x) ALLOCATOR_GLOBAL) :pattern ((has_type (Poly%allocator_global%. x) ALLOCATOR_GLOBAL)))))
(assert (forall ((x core!option.Option.)) (! (= x (%Poly%core!option.Option. (Poly%core!option.Option. x))) :pattern ((Poly%core!option.Option. x)))))
(assert (forall ((V&. Dcr) (V& Type) (x Poly)) (! (=> (has_type x (TYPE%core!option.Option. V&. V&)) (= x (Poly%core!option.Option. (%Poly%core!option.Option. x)))) :pattern ((has_type x (TYPE%core!option.Option. V&. V&))))))
(assert (forall ((V&. Dcr) (V& Type)) (! (has_type (Poly%core!option.Option. core!option.Option./None) (TYPE%core!option.Option. V&. V&)) :pattern ((has_type (Poly%core!option.Option. core!option.Option./None) (TYPE%core!option.Option. V&. V&))))))
(assert (forall ((V&. Dcr) (V& Type) (_0! Poly)) (! (=> (has_type _0! V&) (has_type (Poly%core!option.Option. (core!option.Option./Some _0!)) (TYPE%core!option.Option. V&. V&))) :pattern ((has_type (Poly%core!option.Option. (core!option.Option./Some _0!)) (TYPE%core!option.Option. V&. V&))))))
(assert (forall ((x core!option.Option.)) (! (= (core!option.Option./Some/0 x) (core!option.Option./Some/?0 x)) :pattern ((core!option.Option./Some/0 x)))))
(assert (forall ((V&. Dcr) (V& Type) (x Poly)) (! (=> (has_type x (TYPE%core!option.Option. V&. V&)) (has_type (core!option.Option./Some/0 (%Poly%core!option.Option. x)) V&)) :pattern ((core!option.Option./Some/0 (%Poly%core!option.Option. x)) (has_type x (TYPE%core!option.Option. V&. V&))))))
(define-fun is-core!option.Option./Some_ ((c core!option.Option.)) Bool ((_ is core!option.Option./Some) c))
(assert (forall ((x core!option.Option.)) (! (=> (is-core!option.Option./Some_ x) (height_lt (height (core!option.Option./Some/0 x)) (height (Poly%core!option.Option. x)))) :pattern ((height (core!option.Option./Some/0 x))))))
(define-fun is-core!option.Option./None_ ((c core!option.Option.)) Bool ((_ is core!option.Option./None) c))
(assert (forall ((V&. Dcr) (V& Type) (deep Bool) (x Poly) (y Poly)) (! (=> (and (has_type x (TYPE%core!option.Option. V&. V&)) (has_type y (TYPE%core!option.Option. V&. V&)) (is-core!option.Option./None_ (%Poly%core!option.Option. x)) (is-core!option.Option./None_ (%Poly%core!option.Option. y))) (ext_eq deep (TYPE%core!option.Option. V&. V&) x y)) :pattern ((ext_eq deep (TYPE%core!option.Option. V&. V&) x y)))))
(assert (forall ((V&. Dcr) (V& Type) (deep Bool) (x Poly) (y Poly)) (! (=> (and (has_type x (TYPE%core!option.Option. V&. V&)) (has_type y (TYPE%core!option.Option. V&. V&)) (is-core!option.Option./Some_ (%Poly%core!option.Option. x)) (is-core!option.Option./Some_ (%Poly%core!option.Option. y)) (ext_eq deep V& (core!option.Option./Some/0 (%Poly%core!option.Option. x)) (core!option.Option./Some/0 (%Poly%core!option.Option. y)))) (ext_eq deep (TYPE%core!option.Option. V&. V&) x y)) :pattern ((ext_eq deep (TYPE%core!option.Option. V&. V&) x y)))))
(assert (forall ((x vstd!atomic_ghost.AtomicU64.)) (! (= x (%Poly%vstd!atomic_ghost.AtomicU64. (Poly%vstd!atomic_ghost.AtomicU64. x))) :pattern ((Poly%vstd!atomic_ghost.AtomicU64. x)))))
(assert (forall ((K&. Dcr) (K& Type) (G&. Dcr) (G& Type) (Pred&. Dcr) (Pred& Type) (x Poly)) (! (=> (has_type x (TYPE%vstd!atomic_ghost.AtomicU64. K&. K& G&. G& Pred&. Pred&)) (= x (Poly%vstd!atomic_ghost.AtomicU64. (%Poly%vstd!atomic_ghost.AtomicU64. x)))) :pattern ((has_type x (TYPE%vstd!atomic_ghost.AtomicU64. K&. K& G&. G& Pred&. Pred&))))))
(assert (forall ((K&. Dcr) (K& Type) (G&. Dcr) (G& Type) (Pred&. Dcr) (Pred& Type) (_patomic! vstd!atomic.PAtomicU64.) (_atomic_inv! Poly)) (! (=> (has_type _atomic_inv! (TYPE%vstd!invariant.AtomicInvariant. $ (TYPE%tuple%2. K&. K& $ INT) $ (TYPE%tuple%2. $ TYPE%vstd!atomic.PermissionU64. G&. G&) $ (TYPE%vstd!atomic_ghost.AtomicPredU64. Pred&. Pred&))) (has_type (Poly%vstd!atomic_ghost.AtomicU64. (vstd!atomic_ghost.AtomicU64./AtomicU64 _patomic! _atomic_inv!)) (TYPE%vstd!atomic_ghost.AtomicU64. K&. K& G&. G& Pred&. Pred&))) :pattern ((has_type (Poly%vstd!atomic_ghost.AtomicU64. (vstd!atomic_ghost.AtomicU64./AtomicU64 _patomic! _atomic_inv!)) (TYPE%vstd!atomic_ghost.AtomicU64. K&. K& G&. G& Pred&. Pred&))))))
(assert (forall ((x vstd!atomic_ghost.AtomicU64.)) (! (= (vstd!atomic_ghost.AtomicU64./AtomicU64/patomic x) (vstd!atomic_ghost.AtomicU64./AtomicU64/?patomic x)) :pattern ((vstd!atomic_ghost.AtomicU64./AtomicU64/patomic x)))))
(assert (forall ((x vstd!atomic_ghost.AtomicU64.)) (! (= (vstd!atomic_ghost.AtomicU64./AtomicU64/atomic_inv x) (vstd!atomic_ghost.AtomicU64./AtomicU64/?atomic_inv x)) :pattern ((vstd!atomic_ghost.AtomicU64./AtomicU64/atomic_inv x)))))
(assert (forall ((K&. Dcr) (K& Type) (G&. Dcr) (G& Type) (Pred&. Dcr) (Pred& Type) (x Poly)) (! (=> (has_type x (TYPE%vstd!atomic_ghost.AtomicU64. K&. K& G&. G& Pred&. Pred&)) (has_type (vstd!atomic_ghost.AtomicU64./AtomicU64/atomic_inv (%Poly%vstd!atomic_ghost.AtomicU64. x)) (TYPE%vstd!invariant.AtomicInvariant. $ (TYPE%tuple%2. K&. K& $ INT) $ (TYPE%tuple%2. $ TYPE%vstd!atomic.PermissionU64. G&. G&) $ (TYPE%vstd!atomic_ghost.AtomicPredU64. Pred&. Pred&)))) :pattern ((vstd!atomic_ghost.AtomicU64./AtomicU64/atomic_inv (%Poly%vstd!atomic_ghost.AtomicU64. x)) (has_type x (TYPE%vstd!atomic_ghost.AtomicU64. K&. K& G&. G& Pred&. Pred&))))))
(define-fun is-vstd!atomic_ghost.AtomicU64./AtomicU64_ ((c vstd!atomic_ghost.AtomicU64.)) Bool ((_ is vstd!atomic_ghost.AtomicU64./AtomicU64) c))
(assert (forall ((x vstd!atomic_ghost.AtomicU64.)) (! (=> (is-vstd!atomic_ghost.AtomicU64./AtomicU64_ x) (height_lt (height (vstd!atomic_ghost.AtomicU64./AtomicU64/atomic_inv x)) (height (Poly%vstd!atomic_ghost.AtomicU64. x)))) :pattern ((height (vstd!atomic_ghost.AtomicU64./AtomicU64/atomic_inv x))))))
(assert (forall ((x vstd!atomic_ghost.AtomicPtr.)) (! (= x (%Poly%vstd!atomic_ghost.AtomicPtr. (Poly%vstd!atomic_ghost.AtomicPtr. x))) :pattern ((Poly%vstd!atomic_ghost.AtomicPtr. x)))))
(assert (forall ((T&. Dcr) (T& Type) (K&. Dcr) (K& Type) (G&. Dcr) (G& Type) (Pred&. Dcr) (Pred& Type) (x Poly)) (! (=> (has_type x (TYPE%vstd!atomic_ghost.AtomicPtr. T&. T& K&. K& G&. G& Pred&. Pred&)) (= x (Poly%vstd!atomic_ghost.AtomicPtr. (%Poly%vstd!atomic_ghost.AtomicPtr. x)))) :pattern ((has_type x (TYPE%vstd!atomic_ghost.AtomicPtr. T&. T& K&. K& G&. G& Pred&. Pred&))))))
(assert (forall ((T&. Dcr) (T& Type) (K&. Dcr) (K& Type) (G&. Dcr) (G& Type) (Pred&. Dcr) (Pred& Type) (_patomic! Poly) (_atomic_inv! Poly)) (! (=> (and (has_type _patomic! (TYPE%vstd!atomic.PAtomicPtr. T&. T&)) (has_type _atomic_inv! (TYPE%vstd!invariant.AtomicInvariant. $ (TYPE%tuple%2. K&. K& $ INT) $ (TYPE%tuple%2. $ (TYPE%vstd!atomic.PermissionPtr. T&. T&) G&. G&) $ (TYPE%vstd!atomic_ghost.AtomicPredPtr. T&. T& Pred&. Pred&)))) (has_type (Poly%vstd!atomic_ghost.AtomicPtr. (vstd!atomic_ghost.AtomicPtr./AtomicPtr _patomic! _atomic_inv!)) (TYPE%vstd!atomic_ghost.AtomicPtr. T&. T& K&. K& G&. G& Pred&. Pred&))) :pattern ((has_type (Poly%vstd!atomic_ghost.AtomicPtr. (vstd!atomic_ghost.AtomicPtr./AtomicPtr _patomic! _atomic_inv!)) (TYPE%vstd!atomic_ghost.AtomicPtr. T&. T& K&. K& G&. G& Pred&. Pred&))))))
(assert (forall ((x vstd!atomic_ghost.AtomicPtr.)) (! (= (vstd!atomic_ghost.AtomicPtr./AtomicPtr/patomic x) (vstd!atomic_ghost.AtomicPtr./AtomicPtr/?patomic x)) :pattern ((vstd!atomic_ghost.AtomicPtr./AtomicPtr/patomic x)))))
(assert (forall ((T&. Dcr) (T& Type) (K&. Dcr) (K& Type) (G&. Dcr) (G& Type) (Pred&. Dcr) (Pred& Type) (x Poly)) (! (=> (has_type x (TYPE%vstd!atomic_ghost.AtomicPtr. T&. T& K&. K& G&. G& Pred&. Pred&)) (has_type (vstd!atomic_ghost.AtomicPtr./AtomicPtr/patomic (%Poly%vstd!atomic_ghost.AtomicPtr. x)) (TYPE%vstd!atomic.PAtomicPtr. T&. T&))) :pattern ((vstd!atomic_ghost.AtomicPtr./AtomicPtr/patomic (%Poly%vstd!atomic_ghost.AtomicPtr. x)) (has_type x (TYPE%vstd!atomic_ghost.AtomicPtr. T&. T& K&. K& G&. G& Pred&. Pred&))))))
(assert (forall ((x vstd!atomic_ghost.AtomicPtr.)) (! (= (vstd!atomic_ghost.AtomicPtr./AtomicPtr/atomic_inv x) (vstd!atomic_ghost.AtomicPtr./AtomicPtr/?atomic_inv x)) :pattern ((vstd!atomic_ghost.AtomicPtr./AtomicPtr/atomic_inv x)))))
(assert (forall ((T&. Dcr) (T& Type) (K&. Dcr) (K& Type) (G&. Dcr) (G& Type) (Pred&. Dcr) (Pred& Type) (x Poly)) (! (=> (has_type x (TYPE%vstd!atomic_ghost.AtomicPtr. T&. T& K&. K& G&. G& Pred&. Pred&)) (has_type (vstd!atomic_ghost.AtomicPtr./AtomicPtr/atomic_inv (%Poly%vstd!atomic_ghost.AtomicPtr. x)) (TYPE%vstd!invariant.AtomicInvariant. $ (TYPE%tuple%2. K&. K& $ INT) $ (TYPE%tuple%2. $ (TYPE%vstd!atomic.PermissionPtr. T&. T&) G&. G&) $ (TYPE%vstd!atomic_ghost.AtomicPredPtr. T&. T& Pred&. Pred&)))) :pattern ((vstd!atomic_ghost.AtomicPtr./AtomicPtr/atomic_inv (%Poly%vstd!atomic_ghost.AtomicPtr. x)) (has_type x (TYPE%vstd!atomic_ghost.AtomicPtr. T&. T& K&. K& G&. G& Pred&. Pred&))))))
(define-fun is-vstd!atomic_ghost.AtomicPtr./AtomicPtr_ ((c vstd!atomic_ghost.AtomicPtr.)) Bool ((_ is vstd!atomic_ghost.AtomicPtr./AtomicPtr) c))
(assert (forall ((x vstd!atomic_ghost.AtomicPtr.)) (! (=> (is-vstd!atomic_ghost.AtomicPtr./AtomicPtr_ x) (height_lt (height (vstd!atomic_ghost.AtomicPtr./AtomicPtr/patomic x)) (height (Poly%vstd!atomic_ghost.AtomicPtr. x)))) :pattern ((height (vstd!atomic_ghost.AtomicPtr./AtomicPtr/patomic x))))))
(assert (forall ((x vstd!atomic_ghost.AtomicPtr.)) (! (=> (is-vstd!atomic_ghost.AtomicPtr./AtomicPtr_ x) (height_lt (height (vstd!atomic_ghost.AtomicPtr./AtomicPtr/atomic_inv x)) (height (Poly%vstd!atomic_ghost.AtomicPtr. x)))) :pattern ((height (vstd!atomic_ghost.AtomicPtr./AtomicPtr/atomic_inv x))))))
(assert (forall ((x vstd!raw_ptr.Metadata.)) (! (= x (%Poly%vstd!raw_ptr.Metadata. (Poly%vstd!raw_ptr.Metadata. x))) :pattern ((Poly%vstd!raw_ptr.Metadata. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%vstd!raw_ptr.Metadata.) (= x (Poly%vstd!raw_ptr.Metadata. (%Poly%vstd!raw_ptr.Metadata. x)))) :pattern ((has_type x TYPE%vstd!raw_ptr.Metadata.)))))
(assert (has_type (Poly%vstd!raw_ptr.Metadata. vstd!raw_ptr.Metadata./Thin) TYPE%vstd!raw_ptr.Metadata.))
(assert (forall ((_0! Int)) (! (=> (uInv SZ _0!) (has_type (Poly%vstd!raw_ptr.Metadata. (vstd!raw_ptr.Metadata./Length _0!)) TYPE%vstd!raw_ptr.Metadata.)) :pattern ((has_type (Poly%vstd!raw_ptr.Metadata. (vstd!raw_ptr.Metadata./Length _0!)) TYPE%vstd!raw_ptr.Metadata.)))))
(assert (forall ((x vstd!raw_ptr.Metadata.)) (! (= (vstd!raw_ptr.Metadata./Length/0 x) (vstd!raw_ptr.Metadata./Length/?0 x)) :pattern ((vstd!raw_ptr.Metadata./Length/0 x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%vstd!raw_ptr.Metadata.) (uInv SZ (vstd!raw_ptr.Metadata./Length/0 (%Poly%vstd!raw_ptr.Metadata. x)))) :pattern ((vstd!raw_ptr.Metadata./Length/0 (%Poly%vstd!raw_ptr.Metadata. x)) (has_type x TYPE%vstd!raw_ptr.Metadata.)))))
(assert (forall ((_0! vstd!raw_ptr.DynMetadata.)) (! (has_type (Poly%vstd!raw_ptr.Metadata. (vstd!raw_ptr.Metadata./Dyn _0!)) TYPE%vstd!raw_ptr.Metadata.) :pattern ((has_type (Poly%vstd!raw_ptr.Metadata. (vstd!raw_ptr.Metadata./Dyn _0!)) TYPE%vstd!raw_ptr.Metadata.)))))
(assert (forall ((x vstd!raw_ptr.Metadata.)) (! (= (vstd!raw_ptr.Metadata./Dyn/0 x) (vstd!raw_ptr.Metadata./Dyn/?0 x)) :pattern ((vstd!raw_ptr.Metadata./Dyn/0 x)))))
(assert (forall ((x vstd!raw_ptr.PtrData.)) (! (= x (%Poly%vstd!raw_ptr.PtrData. (Poly%vstd!raw_ptr.PtrData. x))) :pattern ((Poly%vstd!raw_ptr.PtrData. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%vstd!raw_ptr.PtrData.) (= x (Poly%vstd!raw_ptr.PtrData. (%Poly%vstd!raw_ptr.PtrData. x)))) :pattern ((has_type x TYPE%vstd!raw_ptr.PtrData.)))))
(assert (forall ((_addr! Int) (_provenance! vstd!raw_ptr.Provenance.) (_metadata! vstd!raw_ptr.Metadata.)) (! (=> (and (uInv SZ _addr!) (has_type (Poly%vstd!raw_ptr.Metadata. _metadata!) TYPE%vstd!raw_ptr.Metadata.)) (has_type (Poly%vstd!raw_ptr.PtrData. (vstd!raw_ptr.PtrData./PtrData _addr! _provenance! _metadata!)) TYPE%vstd!raw_ptr.PtrData.)) :pattern ((has_type (Poly%vstd!raw_ptr.PtrData. (vstd!raw_ptr.PtrData./PtrData _addr! _provenance! _metadata!)) TYPE%vstd!raw_ptr.PtrData.)))))
(assert (forall ((x vstd!raw_ptr.PtrData.)) (! (= (vstd!raw_ptr.PtrData./PtrData/addr x) (vstd!raw_ptr.PtrData./PtrData/?addr x)) :pattern ((vstd!raw_ptr.PtrData./PtrData/addr x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%vstd!raw_ptr.PtrData.) (uInv SZ (vstd!raw_ptr.PtrData./PtrData/addr (%Poly%vstd!raw_ptr.PtrData. x)))) :pattern ((vstd!raw_ptr.PtrData./PtrData/addr (%Poly%vstd!raw_ptr.PtrData. x)) (has_type x TYPE%vstd!raw_ptr.PtrData.)))))
(assert (forall ((x vstd!raw_ptr.PtrData.)) (! (= (vstd!raw_ptr.PtrData./PtrData/provenance x) (vstd!raw_ptr.PtrData./PtrData/?provenance x)) :pattern ((vstd!raw_ptr.PtrData./PtrData/provenance x)))))
(assert (forall ((x vstd!raw_ptr.PtrData.)) (! (= (vstd!raw_ptr.PtrData./PtrData/metadata x) (vstd!raw_ptr.PtrData./PtrData/?metadata x)) :pattern ((vstd!raw_ptr.PtrData./PtrData/metadata x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%vstd!raw_ptr.PtrData.) (has_type (Poly%vstd!raw_ptr.Metadata. (vstd!raw_ptr.PtrData./PtrData/metadata (%Poly%vstd!raw_ptr.PtrData. x))) TYPE%vstd!raw_ptr.Metadata.)) :pattern ((vstd!raw_ptr.PtrData./PtrData/metadata (%Poly%vstd!raw_ptr.PtrData. x)) (has_type x TYPE%vstd!raw_ptr.PtrData.)))))
(assert (forall ((x vstd!raw_ptr.MemContents.)) (! (= x (%Poly%vstd!raw_ptr.MemContents. (Poly%vstd!raw_ptr.MemContents. x))) :pattern ((Poly%vstd!raw_ptr.MemContents. x)))))
(assert (forall ((T&. Dcr) (T& Type) (x Poly)) (! (=> (has_type x (TYPE%vstd!raw_ptr.MemContents. T&. T&)) (= x (Poly%vstd!raw_ptr.MemContents. (%Poly%vstd!raw_ptr.MemContents. x)))) :pattern ((has_type x (TYPE%vstd!raw_ptr.MemContents. T&. T&))))))
(assert (forall ((T&. Dcr) (T& Type)) (! (has_type (Poly%vstd!raw_ptr.MemContents. vstd!raw_ptr.MemContents./Uninit) (TYPE%vstd!raw_ptr.MemContents. T&. T&)) :pattern ((has_type (Poly%vstd!raw_ptr.MemContents. vstd!raw_ptr.MemContents./Uninit) (TYPE%vstd!raw_ptr.MemContents. T&. T&))))))
(assert (forall ((T&. Dcr) (T& Type) (_0! Poly)) (! (=> (has_type _0! T&) (has_type (Poly%vstd!raw_ptr.MemContents. (vstd!raw_ptr.MemContents./Init _0!)) (TYPE%vstd!raw_ptr.MemContents. T&. T&))) :pattern ((has_type (Poly%vstd!raw_ptr.MemContents. (vstd!raw_ptr.MemContents./Init _0!)) (TYPE%vstd!raw_ptr.MemContents. T&. T&))))))
(assert (forall ((x vstd!raw_ptr.MemContents.)) (! (= (vstd!raw_ptr.MemContents./Init/0 x) (vstd!raw_ptr.MemContents./Init/?0 x)) :pattern ((vstd!raw_ptr.MemContents./Init/0 x)))))
(assert (forall ((T&. Dcr) (T& Type) (x Poly)) (! (=> (has_type x (TYPE%vstd!raw_ptr.MemContents. T&. T&)) (has_type (vstd!raw_ptr.MemContents./Init/0 (%Poly%vstd!raw_ptr.MemContents. x)) T&)) :pattern ((vstd!raw_ptr.MemContents./Init/0 (%Poly%vstd!raw_ptr.MemContents. x)) (has_type x (TYPE%vstd!raw_ptr.MemContents. T&. T&))))))
(define-fun is-vstd!raw_ptr.MemContents./Init_ ((c vstd!raw_ptr.MemContents.)) Bool ((_ is vstd!raw_ptr.MemContents./Init) c))
(assert (forall ((x vstd!raw_ptr.MemContents.)) (! (=> (is-vstd!raw_ptr.MemContents./Init_ x) (height_lt (height (vstd!raw_ptr.MemContents./Init/0 x)) (height (Poly%vstd!raw_ptr.MemContents. x)))) :pattern ((height (vstd!raw_ptr.MemContents./Init/0 x))))))
(assert (forall ((x vstd!raw_ptr.PointsToData.)) (! (= x (%Poly%vstd!raw_ptr.PointsToData. (Poly%vstd!raw_ptr.PointsToData. x))) :pattern ((Poly%vstd!raw_ptr.PointsToData. x)))))
(assert (forall ((T&. Dcr) (T& Type) (x Poly)) (! (=> (has_type x (TYPE%vstd!raw_ptr.PointsToData. T&. T&)) (= x (Poly%vstd!raw_ptr.PointsToData. (%Poly%vstd!raw_ptr.PointsToData. x)))) :pattern ((has_type x (TYPE%vstd!raw_ptr.PointsToData. T&. T&))))))
(assert (forall ((T&. Dcr) (T& Type) (_ptr! Poly) (_opt_value! vstd!raw_ptr.MemContents.)) (! (=> (and (has_type _ptr! (PTR T&. T&)) (has_type (Poly%vstd!raw_ptr.MemContents. _opt_value!) (TYPE%vstd!raw_ptr.MemContents. T&. T&))) (has_type (Poly%vstd!raw_ptr.PointsToData. (vstd!raw_ptr.PointsToData./PointsToData _ptr! _opt_value!)) (TYPE%vstd!raw_ptr.PointsToData. T&. T&))) :pattern ((has_type (Poly%vstd!raw_ptr.PointsToData. (vstd!raw_ptr.PointsToData./PointsToData _ptr! _opt_value!)) (TYPE%vstd!raw_ptr.PointsToData. T&. T&))))))
(assert (forall ((x vstd!raw_ptr.PointsToData.)) (! (= (vstd!raw_ptr.PointsToData./PointsToData/ptr x) (vstd!raw_ptr.PointsToData./PointsToData/?ptr x)) :pattern ((vstd!raw_ptr.PointsToData./PointsToData/ptr x)))))
(assert (forall ((T&. Dcr) (T& Type) (x Poly)) (! (=> (has_type x (TYPE%vstd!raw_ptr.PointsToData. T&. T&)) (has_type (vstd!raw_ptr.PointsToData./PointsToData/ptr (%Poly%vstd!raw_ptr.PointsToData. x)) (PTR T&. T&))) :pattern ((vstd!raw_ptr.PointsToData./PointsToData/ptr (%Poly%vstd!raw_ptr.PointsToData. x)) (has_type x (TYPE%vstd!raw_ptr.PointsToData. T&. T&))))))
(assert (forall ((x vstd!raw_ptr.PointsToData.)) (! (= (vstd!raw_ptr.PointsToData./PointsToData/opt_value x) (vstd!raw_ptr.PointsToData./PointsToData/?opt_value x)) :pattern ((vstd!raw_ptr.PointsToData./PointsToData/opt_value x)))))
(assert (forall ((T&. Dcr) (T& Type) (x Poly)) (! (=> (has_type x (TYPE%vstd!raw_ptr.PointsToData. T&. T&)) (has_type (Poly%vstd!raw_ptr.MemContents. (vstd!raw_ptr.PointsToData./PointsToData/opt_value (%Poly%vstd!raw_ptr.PointsToData. x))) (TYPE%vstd!raw_ptr.MemContents. T&. T&))) :pattern ((vstd!raw_ptr.PointsToData./PointsToData/opt_value (%Poly%vstd!raw_ptr.PointsToData. x)) (has_type x (TYPE%vstd!raw_ptr.PointsToData. T&. T&))))))
(define-fun is-vstd!raw_ptr.PointsToData./PointsToData_ ((c vstd!raw_ptr.PointsToData.)) Bool ((_ is vstd!raw_ptr.PointsToData./PointsToData) c))
(assert (forall ((x vstd!raw_ptr.PointsToData.)) (! (=> (is-vstd!raw_ptr.PointsToData./PointsToData_ x) (height_lt (height (vstd!raw_ptr.PointsToData./PointsToData/ptr x)) (height (Poly%vstd!raw_ptr.PointsToData. x)))) :pattern ((height (vstd!raw_ptr.PointsToData./PointsToData/ptr x))))))
(assert (forall ((x vstd!raw_ptr.PointsToData.)) (! (=> (is-vstd!raw_ptr.PointsToData./PointsToData_ x) (height_lt (height (Poly%vstd!raw_ptr.MemContents. (vstd!raw_ptr.PointsToData./PointsToData/opt_value x))) (height (Poly%vstd!raw_ptr.PointsToData. x)))) :pattern ((height (Poly%vstd!raw_ptr.MemContents. (vstd!raw_ptr.PointsToData./PointsToData/opt_value x)))))))
(assert (forall ((x lib!thread.ThreadId.)) (! (= x (%Poly%lib!thread.ThreadId. (Poly%lib!thread.ThreadId. x))) :pattern ((Poly%lib!thread.ThreadId. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!thread.ThreadId.) (= x (Poly%lib!thread.ThreadId. (%Poly%lib!thread.ThreadId. x)))) :pattern ((has_type x TYPE%lib!thread.ThreadId.)))))
(assert (forall ((_thread_id! Int)) (! (=> (uInv 64 _thread_id!) (has_type (Poly%lib!thread.ThreadId. (lib!thread.ThreadId./ThreadId _thread_id!)) TYPE%lib!thread.ThreadId.)) :pattern ((has_type (Poly%lib!thread.ThreadId. (lib!thread.ThreadId./ThreadId _thread_id!)) TYPE%lib!thread.ThreadId.)))))
(assert (forall ((x lib!thread.ThreadId.)) (! (= (lib!thread.ThreadId./ThreadId/thread_id x) (lib!thread.ThreadId./ThreadId/?thread_id x)) :pattern ((lib!thread.ThreadId./ThreadId/thread_id x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!thread.ThreadId.) (uInv 64 (lib!thread.ThreadId./ThreadId/thread_id (%Poly%lib!thread.ThreadId. x)))) :pattern ((lib!thread.ThreadId./ThreadId/thread_id (%Poly%lib!thread.ThreadId. x)) (has_type x TYPE%lib!thread.ThreadId.)))))
(assert (forall ((x lib!tokens.HeapId.)) (! (= x (%Poly%lib!tokens.HeapId. (Poly%lib!tokens.HeapId. x))) :pattern ((Poly%lib!tokens.HeapId. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!tokens.HeapId.) (= x (Poly%lib!tokens.HeapId. (%Poly%lib!tokens.HeapId. x)))) :pattern ((has_type x TYPE%lib!tokens.HeapId.)))))
(assert (forall ((_id! Int) (_provenance! vstd!raw_ptr.Provenance.) (_uniq! Int)) (! (=> (<= 0 _id!) (has_type (Poly%lib!tokens.HeapId. (lib!tokens.HeapId./HeapId _id! _provenance! _uniq!)) TYPE%lib!tokens.HeapId.)) :pattern ((has_type (Poly%lib!tokens.HeapId. (lib!tokens.HeapId./HeapId _id! _provenance! _uniq!)) TYPE%lib!tokens.HeapId.)))))
(assert (forall ((x lib!tokens.HeapId.)) (! (= (lib!tokens.HeapId./HeapId/id x) (lib!tokens.HeapId./HeapId/?id x)) :pattern ((lib!tokens.HeapId./HeapId/id x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!tokens.HeapId.) (<= 0 (lib!tokens.HeapId./HeapId/id (%Poly%lib!tokens.HeapId. x)))) :pattern ((lib!tokens.HeapId./HeapId/id (%Poly%lib!tokens.HeapId. x)) (has_type x TYPE%lib!tokens.HeapId.)))))
(assert (forall ((x lib!tokens.HeapId.)) (! (= (lib!tokens.HeapId./HeapId/provenance x) (lib!tokens.HeapId./HeapId/?provenance x)) :pattern ((lib!tokens.HeapId./HeapId/provenance x)))))
(assert (forall ((x lib!tokens.HeapId.)) (! (= (lib!tokens.HeapId./HeapId/uniq x) (lib!tokens.HeapId./HeapId/?uniq x)) :pattern ((lib!tokens.HeapId./HeapId/uniq x)))))
(assert (forall ((x lib!tokens.TldId.)) (! (= x (%Poly%lib!tokens.TldId. (Poly%lib!tokens.TldId. x))) :pattern ((Poly%lib!tokens.TldId. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!tokens.TldId.) (= x (Poly%lib!tokens.TldId. (%Poly%lib!tokens.TldId. x)))) :pattern ((has_type x TYPE%lib!tokens.TldId.)))))
(assert (forall ((_id! Int) (_provenance! vstd!raw_ptr.Provenance.)) (! (=> (<= 0 _id!) (has_type (Poly%lib!tokens.TldId. (lib!tokens.TldId./TldId _id! _provenance!)) TYPE%lib!tokens.TldId.)) :pattern ((has_type (Poly%lib!tokens.TldId. (lib!tokens.TldId./TldId _id! _provenance!)) TYPE%lib!tokens.TldId.)))))
(assert (forall ((x lib!tokens.TldId.)) (! (= (lib!tokens.TldId./TldId/id x) (lib!tokens.TldId./TldId/?id x)) :pattern ((lib!tokens.TldId./TldId/id x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!tokens.TldId.) (<= 0 (lib!tokens.TldId./TldId/id (%Poly%lib!tokens.TldId. x)))) :pattern ((lib!tokens.TldId./TldId/id (%Poly%lib!tokens.TldId. x)) (has_type x TYPE%lib!tokens.TldId.)))))
(assert (forall ((x lib!tokens.TldId.)) (! (= (lib!tokens.TldId./TldId/provenance x) (lib!tokens.TldId./TldId/?provenance x)) :pattern ((lib!tokens.TldId./TldId/provenance x)))))
(assert (forall ((x lib!tokens.SegmentId.)) (! (= x (%Poly%lib!tokens.SegmentId. (Poly%lib!tokens.SegmentId. x))) :pattern ((Poly%lib!tokens.SegmentId. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!tokens.SegmentId.) (= x (Poly%lib!tokens.SegmentId. (%Poly%lib!tokens.SegmentId. x)))) :pattern ((has_type x TYPE%lib!tokens.SegmentId.)))))
(assert (forall ((_id! Int) (_provenance! vstd!raw_ptr.Provenance.) (_uniq! Int)) (! (=> (<= 0 _id!) (has_type (Poly%lib!tokens.SegmentId. (lib!tokens.SegmentId./SegmentId _id! _provenance! _uniq!)) TYPE%lib!tokens.SegmentId.)) :pattern ((has_type (Poly%lib!tokens.SegmentId. (lib!tokens.SegmentId./SegmentId _id! _provenance! _uniq!)) TYPE%lib!tokens.SegmentId.)))))
(assert (forall ((x lib!tokens.SegmentId.)) (! (= (lib!tokens.SegmentId./SegmentId/id x) (lib!tokens.SegmentId./SegmentId/?id x)) :pattern ((lib!tokens.SegmentId./SegmentId/id x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!tokens.SegmentId.) (<= 0 (lib!tokens.SegmentId./SegmentId/id (%Poly%lib!tokens.SegmentId. x)))) :pattern ((lib!tokens.SegmentId./SegmentId/id (%Poly%lib!tokens.SegmentId. x)) (has_type x TYPE%lib!tokens.SegmentId.)))))
(assert (forall ((x lib!tokens.SegmentId.)) (! (= (lib!tokens.SegmentId./SegmentId/provenance x) (lib!tokens.SegmentId./SegmentId/?provenance x)) :pattern ((lib!tokens.SegmentId./SegmentId/provenance x)))))
(assert (forall ((x lib!tokens.SegmentId.)) (! (= (lib!tokens.SegmentId./SegmentId/uniq x) (lib!tokens.SegmentId./SegmentId/?uniq x)) :pattern ((lib!tokens.SegmentId./SegmentId/uniq x)))))
(assert (forall ((x lib!tokens.PageId.)) (! (= x (%Poly%lib!tokens.PageId. (Poly%lib!tokens.PageId. x))) :pattern ((Poly%lib!tokens.PageId. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!tokens.PageId.) (= x (Poly%lib!tokens.PageId. (%Poly%lib!tokens.PageId. x)))) :pattern ((has_type x TYPE%lib!tokens.PageId.)))))
(assert (forall ((_segment_id! lib!tokens.SegmentId.) (_idx! Int)) (! (=> (and (has_type (Poly%lib!tokens.SegmentId. _segment_id!) TYPE%lib!tokens.SegmentId.) (<= 0 _idx!)) (has_type (Poly%lib!tokens.PageId. (lib!tokens.PageId./PageId _segment_id! _idx!)) TYPE%lib!tokens.PageId.)) :pattern ((has_type (Poly%lib!tokens.PageId. (lib!tokens.PageId./PageId _segment_id! _idx!)) TYPE%lib!tokens.PageId.)))))
(assert (forall ((x lib!tokens.PageId.)) (! (= (lib!tokens.PageId./PageId/segment_id x) (lib!tokens.PageId./PageId/?segment_id x)) :pattern ((lib!tokens.PageId./PageId/segment_id x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!tokens.PageId.) (has_type (Poly%lib!tokens.SegmentId. (lib!tokens.PageId./PageId/segment_id (%Poly%lib!tokens.PageId. x))) TYPE%lib!tokens.SegmentId.)) :pattern ((lib!tokens.PageId./PageId/segment_id (%Poly%lib!tokens.PageId. x)) (has_type x TYPE%lib!tokens.PageId.)))))
(assert (forall ((x lib!tokens.PageId.)) (! (= (lib!tokens.PageId./PageId/idx x) (lib!tokens.PageId./PageId/?idx x)) :pattern ((lib!tokens.PageId./PageId/idx x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!tokens.PageId.) (<= 0 (lib!tokens.PageId./PageId/idx (%Poly%lib!tokens.PageId. x)))) :pattern ((lib!tokens.PageId./PageId/idx (%Poly%lib!tokens.PageId. x)) (has_type x TYPE%lib!tokens.PageId.)))))
(assert (forall ((x lib!tokens.BlockId.)) (! (= x (%Poly%lib!tokens.BlockId. (Poly%lib!tokens.BlockId. x))) :pattern ((Poly%lib!tokens.BlockId. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!tokens.BlockId.) (= x (Poly%lib!tokens.BlockId. (%Poly%lib!tokens.BlockId. x)))) :pattern ((has_type x TYPE%lib!tokens.BlockId.)))))
(assert (forall ((_page_id! lib!tokens.PageId.) (_idx! Int) (_slice_idx! Int) (_block_size! Int)) (! (=> (and (has_type (Poly%lib!tokens.PageId. _page_id!) TYPE%lib!tokens.PageId.) (<= 0 _idx!) (<= 0 _slice_idx!) (<= 0 _block_size!)) (has_type (Poly%lib!tokens.BlockId. (lib!tokens.BlockId./BlockId _page_id! _idx! _slice_idx! _block_size!)) TYPE%lib!tokens.BlockId.)) :pattern ((has_type (Poly%lib!tokens.BlockId. (lib!tokens.BlockId./BlockId _page_id! _idx! _slice_idx! _block_size!)) TYPE%lib!tokens.BlockId.)))))
(assert (forall ((x lib!tokens.BlockId.)) (! (= (lib!tokens.BlockId./BlockId/page_id x) (lib!tokens.BlockId./BlockId/?page_id x)) :pattern ((lib!tokens.BlockId./BlockId/page_id x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!tokens.BlockId.) (has_type (Poly%lib!tokens.PageId. (lib!tokens.BlockId./BlockId/page_id (%Poly%lib!tokens.BlockId. x))) TYPE%lib!tokens.PageId.)) :pattern ((lib!tokens.BlockId./BlockId/page_id (%Poly%lib!tokens.BlockId. x)) (has_type x TYPE%lib!tokens.BlockId.)))))
(assert (forall ((x lib!tokens.BlockId.)) (! (= (lib!tokens.BlockId./BlockId/idx x) (lib!tokens.BlockId./BlockId/?idx x)) :pattern ((lib!tokens.BlockId./BlockId/idx x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!tokens.BlockId.) (<= 0 (lib!tokens.BlockId./BlockId/idx (%Poly%lib!tokens.BlockId. x)))) :pattern ((lib!tokens.BlockId./BlockId/idx (%Poly%lib!tokens.BlockId. x)) (has_type x TYPE%lib!tokens.BlockId.)))))
(assert (forall ((x lib!tokens.BlockId.)) (! (= (lib!tokens.BlockId./BlockId/slice_idx x) (lib!tokens.BlockId./BlockId/?slice_idx x)) :pattern ((lib!tokens.BlockId./BlockId/slice_idx x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!tokens.BlockId.) (<= 0 (lib!tokens.BlockId./BlockId/slice_idx (%Poly%lib!tokens.BlockId. x)))) :pattern ((lib!tokens.BlockId./BlockId/slice_idx (%Poly%lib!tokens.BlockId. x)) (has_type x TYPE%lib!tokens.BlockId.)))))
(assert (forall ((x lib!tokens.BlockId.)) (! (= (lib!tokens.BlockId./BlockId/block_size x) (lib!tokens.BlockId./BlockId/?block_size x)) :pattern ((lib!tokens.BlockId./BlockId/block_size x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!tokens.BlockId.) (<= 0 (lib!tokens.BlockId./BlockId/block_size (%Poly%lib!tokens.BlockId. x)))) :pattern ((lib!tokens.BlockId./BlockId/block_size (%Poly%lib!tokens.BlockId. x)) (has_type x TYPE%lib!tokens.BlockId.)))))
(assert (forall ((x lib!tokens.DelayState.)) (! (= x (%Poly%lib!tokens.DelayState. (Poly%lib!tokens.DelayState. x))) :pattern ((Poly%lib!tokens.DelayState. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!tokens.DelayState.) (= x (Poly%lib!tokens.DelayState. (%Poly%lib!tokens.DelayState. x)))) :pattern ((has_type x TYPE%lib!tokens.DelayState.)))))
(assert (forall ((x lib!tokens.DelayState.)) (! (has_type (Poly%lib!tokens.DelayState. x) TYPE%lib!tokens.DelayState.) :pattern ((has_type (Poly%lib!tokens.DelayState. x) TYPE%lib!tokens.DelayState.)))))
(assert (forall ((x lib!tokens.PageState.)) (! (= x (%Poly%lib!tokens.PageState. (Poly%lib!tokens.PageState. x))) :pattern ((Poly%lib!tokens.PageState. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!tokens.PageState.) (= x (Poly%lib!tokens.PageState. (%Poly%lib!tokens.PageState. x)))) :pattern ((has_type x TYPE%lib!tokens.PageState.)))))
(assert (forall ((_offset! Int) (_block_size! Int) (_num_blocks! Int) (_shared_access! lib!types.PageSharedAccess.) (_is_enabled! Bool)) (! (=> (and (<= 0 _block_size!) (<= 0 _num_blocks!)) (has_type (Poly%lib!tokens.PageState. (lib!tokens.PageState./PageState _offset! _block_size! _num_blocks! _shared_access! _is_enabled!)) TYPE%lib!tokens.PageState.)) :pattern ((has_type (Poly%lib!tokens.PageState. (lib!tokens.PageState./PageState _offset! _block_size! _num_blocks! _shared_access! _is_enabled!)) TYPE%lib!tokens.PageState.)))))
(assert (forall ((x lib!tokens.PageState.)) (! (= (lib!tokens.PageState./PageState/offset x) (lib!tokens.PageState./PageState/?offset x)) :pattern ((lib!tokens.PageState./PageState/offset x)))))
(assert (forall ((x lib!tokens.PageState.)) (! (= (lib!tokens.PageState./PageState/block_size x) (lib!tokens.PageState./PageState/?block_size x)) :pattern ((lib!tokens.PageState./PageState/block_size x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!tokens.PageState.) (<= 0 (lib!tokens.PageState./PageState/block_size (%Poly%lib!tokens.PageState. x)))) :pattern ((lib!tokens.PageState./PageState/block_size (%Poly%lib!tokens.PageState. x)) (has_type x TYPE%lib!tokens.PageState.)))))
(assert (forall ((x lib!tokens.PageState.)) (! (= (lib!tokens.PageState./PageState/num_blocks x) (lib!tokens.PageState./PageState/?num_blocks x)) :pattern ((lib!tokens.PageState./PageState/num_blocks x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!tokens.PageState.) (<= 0 (lib!tokens.PageState./PageState/num_blocks (%Poly%lib!tokens.PageState. x)))) :pattern ((lib!tokens.PageState./PageState/num_blocks (%Poly%lib!tokens.PageState. x)) (has_type x TYPE%lib!tokens.PageState.)))))
(assert (forall ((x lib!tokens.PageState.)) (! (= (lib!tokens.PageState./PageState/shared_access x) (lib!tokens.PageState./PageState/?shared_access x)) :pattern ((lib!tokens.PageState./PageState/shared_access x)))))
(assert (forall ((x lib!tokens.PageState.)) (! (= (lib!tokens.PageState./PageState/is_enabled x) (lib!tokens.PageState./PageState/?is_enabled x)) :pattern ((lib!tokens.PageState./PageState/is_enabled x)))))
(define-fun is-lib!tokens.PageState./PageState_ ((c lib!tokens.PageState.)) Bool ((_ is lib!tokens.PageState./PageState) c))
(assert (forall ((x lib!tokens.PageState.)) (! (=> (is-lib!tokens.PageState./PageState_ x) (height_lt (height (Poly%lib!types.PageSharedAccess. (lib!tokens.PageState./PageState/shared_access x))) (height (Poly%lib!tokens.PageState. x)))) :pattern ((height (Poly%lib!types.PageSharedAccess. (lib!tokens.PageState./PageState/shared_access x)))))))
(assert (forall ((x lib!tokens.SegmentState.)) (! (= x (%Poly%lib!tokens.SegmentState. (Poly%lib!tokens.SegmentState. x))) :pattern ((Poly%lib!tokens.SegmentState. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!tokens.SegmentState.) (= x (Poly%lib!tokens.SegmentState. (%Poly%lib!tokens.SegmentState. x)))) :pattern ((has_type x TYPE%lib!tokens.SegmentState.)))))
(assert (forall ((x lib!tokens.SegmentState.)) (! (= (lib!tokens.SegmentState./SegmentState/shared_access x) (lib!tokens.SegmentState./SegmentState/?shared_access x)) :pattern ((lib!tokens.SegmentState./SegmentState/shared_access x)))))
(assert (forall ((x lib!tokens.SegmentState.)) (! (= (lib!tokens.SegmentState./SegmentState/is_enabled x) (lib!tokens.SegmentState./SegmentState/?is_enabled x)) :pattern ((lib!tokens.SegmentState./SegmentState/is_enabled x)))))
(assert (forall ((x lib!tokens.SegmentState.)) (! (has_type (Poly%lib!tokens.SegmentState. x) TYPE%lib!tokens.SegmentState.) :pattern ((has_type (Poly%lib!tokens.SegmentState. x) TYPE%lib!tokens.SegmentState.)))))
(define-fun is-lib!tokens.SegmentState./SegmentState_ ((c lib!tokens.SegmentState.)) Bool ((_ is lib!tokens.SegmentState./SegmentState) c))
(assert (forall ((x lib!tokens.SegmentState.)) (! (=> (is-lib!tokens.SegmentState./SegmentState_ x) (height_lt (height (Poly%lib!types.SegmentSharedAccess. (lib!tokens.SegmentState./SegmentState/shared_access x))) (height (Poly%lib!tokens.SegmentState. x)))) :pattern ((height (Poly%lib!types.SegmentSharedAccess. (lib!tokens.SegmentState./SegmentState/shared_access x)))))))
(assert (forall ((x lib!tokens.BlockState.)) (! (= x (%Poly%lib!tokens.BlockState. (Poly%lib!tokens.BlockState. x))) :pattern ((Poly%lib!tokens.BlockState. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!tokens.BlockState.) (= x (Poly%lib!tokens.BlockState. (%Poly%lib!tokens.BlockState. x)))) :pattern ((has_type x TYPE%lib!tokens.BlockState.)))))
(assert (forall ((_segment_shared_access! lib!types.SegmentSharedAccess.) (_page_shared_access! lib!types.PageSharedAccess.) (_page_slice_shared_access! lib!types.PageSharedAccess.) (_heap_id! core!option.Option.)) (! (=> (has_type (Poly%core!option.Option. _heap_id!) (TYPE%core!option.Option. $ TYPE%lib!tokens.HeapId.)) (has_type (Poly%lib!tokens.BlockState. (lib!tokens.BlockState./BlockState _segment_shared_access! _page_shared_access! _page_slice_shared_access! _heap_id!)) TYPE%lib!tokens.BlockState.)) :pattern ((has_type (Poly%lib!tokens.BlockState. (lib!tokens.BlockState./BlockState _segment_shared_access! _page_shared_access! _page_slice_shared_access! _heap_id!)) TYPE%lib!tokens.BlockState.)))))
(assert (forall ((x lib!tokens.BlockState.)) (! (= (lib!tokens.BlockState./BlockState/segment_shared_access x) (lib!tokens.BlockState./BlockState/?segment_shared_access x)) :pattern ((lib!tokens.BlockState./BlockState/segment_shared_access x)))))
(assert (forall ((x lib!tokens.BlockState.)) (! (= (lib!tokens.BlockState./BlockState/page_shared_access x) (lib!tokens.BlockState./BlockState/?page_shared_access x)) :pattern ((lib!tokens.BlockState./BlockState/page_shared_access x)))))
(assert (forall ((x lib!tokens.BlockState.)) (! (= (lib!tokens.BlockState./BlockState/page_slice_shared_access x) (lib!tokens.BlockState./BlockState/?page_slice_shared_access x)) :pattern ((lib!tokens.BlockState./BlockState/page_slice_shared_access x)))))
(assert (forall ((x lib!tokens.BlockState.)) (! (= (lib!tokens.BlockState./BlockState/heap_id x) (lib!tokens.BlockState./BlockState/?heap_id x)) :pattern ((lib!tokens.BlockState./BlockState/heap_id x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!tokens.BlockState.) (has_type (Poly%core!option.Option. (lib!tokens.BlockState./BlockState/heap_id (%Poly%lib!tokens.BlockState. x))) (TYPE%core!option.Option. $ TYPE%lib!tokens.HeapId.))) :pattern ((lib!tokens.BlockState./BlockState/heap_id (%Poly%lib!tokens.BlockState. x)) (has_type x TYPE%lib!tokens.BlockState.)))))
(define-fun is-lib!tokens.BlockState./BlockState_ ((c lib!tokens.BlockState.)) Bool ((_ is lib!tokens.BlockState./BlockState) c))
(assert (forall ((x lib!tokens.BlockState.)) (! (=> (is-lib!tokens.BlockState./BlockState_ x) (height_lt (height (Poly%lib!types.SegmentSharedAccess. (lib!tokens.BlockState./BlockState/segment_shared_access x))) (height (Poly%lib!tokens.BlockState. x)))) :pattern ((height (Poly%lib!types.SegmentSharedAccess. (lib!tokens.BlockState./BlockState/segment_shared_access x)))))))
(assert (forall ((x lib!tokens.BlockState.)) (! (=> (is-lib!tokens.BlockState./BlockState_ x) (height_lt (height (Poly%lib!types.PageSharedAccess. (lib!tokens.BlockState./BlockState/page_shared_access x))) (height (Poly%lib!tokens.BlockState. x)))) :pattern ((height (Poly%lib!types.PageSharedAccess. (lib!tokens.BlockState./BlockState/page_shared_access x)))))))
(assert (forall ((x lib!tokens.BlockState.)) (! (=> (is-lib!tokens.BlockState./BlockState_ x) (height_lt (height (Poly%lib!types.PageSharedAccess. (lib!tokens.BlockState./BlockState/page_slice_shared_access x))) (height (Poly%lib!tokens.BlockState. x)))) :pattern ((height (Poly%lib!types.PageSharedAccess. (lib!tokens.BlockState./BlockState/page_slice_shared_access x)))))))
(assert (forall ((x lib!tokens.HeapState.)) (! (= x (%Poly%lib!tokens.HeapState. (Poly%lib!tokens.HeapState. x))) :pattern ((Poly%lib!tokens.HeapState. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!tokens.HeapState.) (= x (Poly%lib!tokens.HeapState. (%Poly%lib!tokens.HeapState. x)))) :pattern ((has_type x TYPE%lib!tokens.HeapState.)))))
(assert (forall ((x lib!tokens.HeapState.)) (! (= (lib!tokens.HeapState./HeapState/shared_access x) (lib!tokens.HeapState./HeapState/?shared_access x)) :pattern ((lib!tokens.HeapState./HeapState/shared_access x)))))
(assert (forall ((x lib!tokens.HeapState.)) (! (has_type (Poly%lib!tokens.HeapState. x) TYPE%lib!tokens.HeapState.) :pattern ((has_type (Poly%lib!tokens.HeapState. x) TYPE%lib!tokens.HeapState.)))))
(define-fun is-lib!tokens.HeapState./HeapState_ ((c lib!tokens.HeapState.)) Bool ((_ is lib!tokens.HeapState./HeapState) c))
(assert (forall ((x lib!tokens.HeapState.)) (! (=> (is-lib!tokens.HeapState./HeapState_ x) (height_lt (height (Poly%lib!types.HeapSharedAccess. (lib!tokens.HeapState./HeapState/shared_access x))) (height (Poly%lib!tokens.HeapState. x)))) :pattern ((height (Poly%lib!types.HeapSharedAccess. (lib!tokens.HeapState./HeapState/shared_access x)))))))
(assert (forall ((x lib!tokens.ThreadState.)) (! (= x (%Poly%lib!tokens.ThreadState. (Poly%lib!tokens.ThreadState. x))) :pattern ((Poly%lib!tokens.ThreadState. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!tokens.ThreadState.) (= x (Poly%lib!tokens.ThreadState. (%Poly%lib!tokens.ThreadState. x)))) :pattern ((has_type x TYPE%lib!tokens.ThreadState.)))))
(assert (forall ((_heap_id! lib!tokens.HeapId.) (_heap! lib!tokens.HeapState.) (_segments! vstd!map.Map<lib!tokens.SegmentId./lib!tokens.SegmentState.>.) (_pages! vstd!map.Map<lib!tokens.PageId./lib!tokens.PageState.>.)) (! (=> (has_type (Poly%lib!tokens.HeapId. _heap_id!) TYPE%lib!tokens.HeapId.) (has_type (Poly%lib!tokens.ThreadState. (lib!tokens.ThreadState./ThreadState _heap_id! _heap! _segments! _pages!)) TYPE%lib!tokens.ThreadState.)) :pattern ((has_type (Poly%lib!tokens.ThreadState. (lib!tokens.ThreadState./ThreadState _heap_id! _heap! _segments! _pages!)) TYPE%lib!tokens.ThreadState.)))))
(assert (forall ((x lib!tokens.ThreadState.)) (! (= (lib!tokens.ThreadState./ThreadState/heap_id x) (lib!tokens.ThreadState./ThreadState/?heap_id x)) :pattern ((lib!tokens.ThreadState./ThreadState/heap_id x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!tokens.ThreadState.) (has_type (Poly%lib!tokens.HeapId. (lib!tokens.ThreadState./ThreadState/heap_id (%Poly%lib!tokens.ThreadState. x))) TYPE%lib!tokens.HeapId.)) :pattern ((lib!tokens.ThreadState./ThreadState/heap_id (%Poly%lib!tokens.ThreadState. x)) (has_type x TYPE%lib!tokens.ThreadState.)))))
(assert (forall ((x lib!tokens.ThreadState.)) (! (= (lib!tokens.ThreadState./ThreadState/heap x) (lib!tokens.ThreadState./ThreadState/?heap x)) :pattern ((lib!tokens.ThreadState./ThreadState/heap x)))))
(assert (forall ((x lib!tokens.ThreadState.)) (! (= (lib!tokens.ThreadState./ThreadState/segments x) (lib!tokens.ThreadState./ThreadState/?segments x)) :pattern ((lib!tokens.ThreadState./ThreadState/segments x)))))
(assert (forall ((x lib!tokens.ThreadState.)) (! (= (lib!tokens.ThreadState./ThreadState/pages x) (lib!tokens.ThreadState./ThreadState/?pages x)) :pattern ((lib!tokens.ThreadState./ThreadState/pages x)))))
(define-fun is-lib!tokens.ThreadState./ThreadState_ ((c lib!tokens.ThreadState.)) Bool ((_ is lib!tokens.ThreadState./ThreadState) c))
(assert (forall ((x lib!tokens.ThreadState.)) (! (=> (is-lib!tokens.ThreadState./ThreadState_ x) (height_lt (height (Poly%lib!tokens.HeapState. (lib!tokens.ThreadState./ThreadState/heap x))) (height (Poly%lib!tokens.ThreadState. x)))) :pattern ((height (Poly%lib!tokens.HeapState. (lib!tokens.ThreadState./ThreadState/heap x)))))))
(assert (forall ((x lib!tokens.ThreadState.)) (! (=> (is-lib!tokens.ThreadState./ThreadState_ x) (height_lt (height (Poly%vstd!map.Map<lib!tokens.SegmentId./lib!tokens.SegmentState.>. (lib!tokens.ThreadState./ThreadState/segments x))) (height (Poly%lib!tokens.ThreadState. x)))) :pattern ((height (Poly%vstd!map.Map<lib!tokens.SegmentId./lib!tokens.SegmentState.>. (lib!tokens.ThreadState./ThreadState/segments x)))))))
(assert (forall ((x lib!tokens.ThreadState.)) (! (=> (is-lib!tokens.ThreadState./ThreadState_ x) (height_lt (height (fun_from_recursive_field (Poly%vstd!map.Map<lib!tokens.SegmentId./lib!tokens.SegmentState.>. (lib!tokens.ThreadState./ThreadState/segments x)))) (height (Poly%lib!tokens.ThreadState. x)))) :pattern ((height (fun_from_recursive_field (Poly%vstd!map.Map<lib!tokens.SegmentId./lib!tokens.SegmentState.>. (lib!tokens.ThreadState./ThreadState/segments x))))))))
(assert (forall ((x lib!tokens.ThreadState.)) (! (=> (is-lib!tokens.ThreadState./ThreadState_ x) (height_lt (height (Poly%vstd!map.Map<lib!tokens.PageId./lib!tokens.PageState.>. (lib!tokens.ThreadState./ThreadState/pages x))) (height (Poly%lib!tokens.ThreadState. x)))) :pattern ((height (Poly%vstd!map.Map<lib!tokens.PageId./lib!tokens.PageState.>. (lib!tokens.ThreadState./ThreadState/pages x)))))))
(assert (forall ((x lib!tokens.ThreadState.)) (! (=> (is-lib!tokens.ThreadState./ThreadState_ x) (height_lt (height (fun_from_recursive_field (Poly%vstd!map.Map<lib!tokens.PageId./lib!tokens.PageState.>. (lib!tokens.ThreadState./ThreadState/pages x)))) (height (Poly%lib!tokens.ThreadState. x)))) :pattern ((height (fun_from_recursive_field (Poly%vstd!map.Map<lib!tokens.PageId./lib!tokens.PageState.>. (lib!tokens.ThreadState./ThreadState/pages x))))))))
(assert (forall ((x lib!tokens.ThreadCheckedState.)) (! (= x (%Poly%lib!tokens.ThreadCheckedState. (Poly%lib!tokens.ThreadCheckedState. x))) :pattern ((Poly%lib!tokens.ThreadCheckedState. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!tokens.ThreadCheckedState.) (= x (Poly%lib!tokens.ThreadCheckedState. (%Poly%lib!tokens.ThreadCheckedState. x)))) :pattern ((has_type x TYPE%lib!tokens.ThreadCheckedState.)))))
(assert (forall ((x lib!tokens.ThreadCheckedState.)) (! (= (lib!tokens.ThreadCheckedState./ThreadCheckedState/pages x) (lib!tokens.ThreadCheckedState./ThreadCheckedState/?pages x)) :pattern ((lib!tokens.ThreadCheckedState./ThreadCheckedState/pages x)))))
(assert (forall ((x lib!tokens.ThreadCheckedState.)) (! (has_type (Poly%lib!tokens.ThreadCheckedState. x) TYPE%lib!tokens.ThreadCheckedState.) :pattern ((has_type (Poly%lib!tokens.ThreadCheckedState. x) TYPE%lib!tokens.ThreadCheckedState.)))))
(assert (forall ((x lib!tokens.Actor.)) (! (= x (%Poly%lib!tokens.Actor. (Poly%lib!tokens.Actor. x))) :pattern ((Poly%lib!tokens.Actor. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!tokens.Actor.) (= x (Poly%lib!tokens.Actor. (%Poly%lib!tokens.Actor. x)))) :pattern ((has_type x TYPE%lib!tokens.Actor.)))))
(assert (forall ((x lib!tokens.Actor.)) (! (has_type (Poly%lib!tokens.Actor. x) TYPE%lib!tokens.Actor.) :pattern ((has_type (Poly%lib!tokens.Actor. x) TYPE%lib!tokens.Actor.)))))
(assert (forall ((x lib!tokens.DelayFreeingActor.)) (! (= x (%Poly%lib!tokens.DelayFreeingActor. (Poly%lib!tokens.DelayFreeingActor. x))) :pattern ((Poly%lib!tokens.DelayFreeingActor. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!tokens.DelayFreeingActor.) (= x (Poly%lib!tokens.DelayFreeingActor. (%Poly%lib!tokens.DelayFreeingActor. x)))) :pattern ((has_type x TYPE%lib!tokens.DelayFreeingActor.)))))
(assert (has_type (Poly%lib!tokens.DelayFreeingActor. lib!tokens.DelayFreeingActor./HeapUnknown) TYPE%lib!tokens.DelayFreeingActor.))
(assert (forall ((_0! lib!tokens.HeapId.) (_1! lib!types.HeapSharedAccess.) (_2! lib!types.PageSharedAccess.)) (! (=> (has_type (Poly%lib!tokens.HeapId. _0!) TYPE%lib!tokens.HeapId.) (has_type (Poly%lib!tokens.DelayFreeingActor. (lib!tokens.DelayFreeingActor./Heap _0! _1! _2!)) TYPE%lib!tokens.DelayFreeingActor.)) :pattern ((has_type (Poly%lib!tokens.DelayFreeingActor. (lib!tokens.DelayFreeingActor./Heap _0! _1! _2!)) TYPE%lib!tokens.DelayFreeingActor.)))))
(assert (forall ((x lib!tokens.DelayFreeingActor.)) (! (= (lib!tokens.DelayFreeingActor./Heap/0 x) (lib!tokens.DelayFreeingActor./Heap/?0 x)) :pattern ((lib!tokens.DelayFreeingActor./Heap/0 x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!tokens.DelayFreeingActor.) (has_type (Poly%lib!tokens.HeapId. (lib!tokens.DelayFreeingActor./Heap/0 (%Poly%lib!tokens.DelayFreeingActor. x))) TYPE%lib!tokens.HeapId.)) :pattern ((lib!tokens.DelayFreeingActor./Heap/0 (%Poly%lib!tokens.DelayFreeingActor. x)) (has_type x TYPE%lib!tokens.DelayFreeingActor.)))))
(assert (forall ((x lib!tokens.DelayFreeingActor.)) (! (= (lib!tokens.DelayFreeingActor./Heap/1 x) (lib!tokens.DelayFreeingActor./Heap/?1 x)) :pattern ((lib!tokens.DelayFreeingActor./Heap/1 x)))))
(assert (forall ((x lib!tokens.DelayFreeingActor.)) (! (= (lib!tokens.DelayFreeingActor./Heap/2 x) (lib!tokens.DelayFreeingActor./Heap/?2 x)) :pattern ((lib!tokens.DelayFreeingActor./Heap/2 x)))))
(define-fun is-lib!tokens.DelayFreeingActor./Heap_ ((c lib!tokens.DelayFreeingActor.)) Bool ((_ is lib!tokens.DelayFreeingActor./Heap) c))
(assert (forall ((x lib!tokens.DelayFreeingActor.)) (! (=> (is-lib!tokens.DelayFreeingActor./Heap_ x) (height_lt (height (Poly%lib!types.HeapSharedAccess. (lib!tokens.DelayFreeingActor./Heap/1 x))) (height (Poly%lib!tokens.DelayFreeingActor. x)))) :pattern ((height (Poly%lib!types.HeapSharedAccess. (lib!tokens.DelayFreeingActor./Heap/1 x)))))))
(assert (forall ((x lib!tokens.DelayFreeingActor.)) (! (=> (is-lib!tokens.DelayFreeingActor./Heap_ x) (height_lt (height (Poly%lib!types.PageSharedAccess. (lib!tokens.DelayFreeingActor./Heap/2 x))) (height (Poly%lib!tokens.DelayFreeingActor. x)))) :pattern ((height (Poly%lib!types.PageSharedAccess. (lib!tokens.DelayFreeingActor./Heap/2 x)))))))
(assert (forall ((x lib!types.PageInner.)) (! (= x (%Poly%lib!types.PageInner. (Poly%lib!types.PageInner. x))) :pattern ((Poly%lib!types.PageInner. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.PageInner.) (= x (Poly%lib!types.PageInner. (%Poly%lib!types.PageInner. x)))) :pattern ((has_type x TYPE%lib!types.PageInner.)))))
(assert (forall ((_flags0! Int) (_capacity! Int) (_reserved! Int) (_flags1! Int) (_flags2! Int) (_free! lib!linked_list.LL.) (_used! Int) (_xblock_size! Int) (_local_free! lib!linked_list.LL.)) (! (=> (and (uInv 8 _flags0!) (uInv 16 _capacity!) (uInv 16 _reserved!) (uInv 8 _flags1!) (uInv 8 _flags2!) (uInv 32 _used!) (uInv 32 _xblock_size!)) (has_type (Poly%lib!types.PageInner. (lib!types.PageInner./PageInner _flags0! _capacity! _reserved! _flags1! _flags2! _free! _used! _xblock_size! _local_free!)) TYPE%lib!types.PageInner.)) :pattern ((has_type (Poly%lib!types.PageInner. (lib!types.PageInner./PageInner _flags0! _capacity! _reserved! _flags1! _flags2! _free! _used! _xblock_size! _local_free!)) TYPE%lib!types.PageInner.)))))
(assert (forall ((x lib!types.PageInner.)) (! (= (lib!types.PageInner./PageInner/flags0 x) (lib!types.PageInner./PageInner/?flags0 x)) :pattern ((lib!types.PageInner./PageInner/flags0 x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.PageInner.) (uInv 8 (lib!types.PageInner./PageInner/flags0 (%Poly%lib!types.PageInner. x)))) :pattern ((lib!types.PageInner./PageInner/flags0 (%Poly%lib!types.PageInner. x)) (has_type x TYPE%lib!types.PageInner.)))))
(assert (forall ((x lib!types.PageInner.)) (! (= (lib!types.PageInner./PageInner/capacity x) (lib!types.PageInner./PageInner/?capacity x)) :pattern ((lib!types.PageInner./PageInner/capacity x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.PageInner.) (uInv 16 (lib!types.PageInner./PageInner/capacity (%Poly%lib!types.PageInner. x)))) :pattern ((lib!types.PageInner./PageInner/capacity (%Poly%lib!types.PageInner. x)) (has_type x TYPE%lib!types.PageInner.)))))
(assert (forall ((x lib!types.PageInner.)) (! (= (lib!types.PageInner./PageInner/reserved x) (lib!types.PageInner./PageInner/?reserved x)) :pattern ((lib!types.PageInner./PageInner/reserved x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.PageInner.) (uInv 16 (lib!types.PageInner./PageInner/reserved (%Poly%lib!types.PageInner. x)))) :pattern ((lib!types.PageInner./PageInner/reserved (%Poly%lib!types.PageInner. x)) (has_type x TYPE%lib!types.PageInner.)))))
(assert (forall ((x lib!types.PageInner.)) (! (= (lib!types.PageInner./PageInner/flags1 x) (lib!types.PageInner./PageInner/?flags1 x)) :pattern ((lib!types.PageInner./PageInner/flags1 x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.PageInner.) (uInv 8 (lib!types.PageInner./PageInner/flags1 (%Poly%lib!types.PageInner. x)))) :pattern ((lib!types.PageInner./PageInner/flags1 (%Poly%lib!types.PageInner. x)) (has_type x TYPE%lib!types.PageInner.)))))
(assert (forall ((x lib!types.PageInner.)) (! (= (lib!types.PageInner./PageInner/flags2 x) (lib!types.PageInner./PageInner/?flags2 x)) :pattern ((lib!types.PageInner./PageInner/flags2 x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.PageInner.) (uInv 8 (lib!types.PageInner./PageInner/flags2 (%Poly%lib!types.PageInner. x)))) :pattern ((lib!types.PageInner./PageInner/flags2 (%Poly%lib!types.PageInner. x)) (has_type x TYPE%lib!types.PageInner.)))))
(assert (forall ((x lib!types.PageInner.)) (! (= (lib!types.PageInner./PageInner/free x) (lib!types.PageInner./PageInner/?free x)) :pattern ((lib!types.PageInner./PageInner/free x)))))
(assert (forall ((x lib!types.PageInner.)) (! (= (lib!types.PageInner./PageInner/used x) (lib!types.PageInner./PageInner/?used x)) :pattern ((lib!types.PageInner./PageInner/used x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.PageInner.) (uInv 32 (lib!types.PageInner./PageInner/used (%Poly%lib!types.PageInner. x)))) :pattern ((lib!types.PageInner./PageInner/used (%Poly%lib!types.PageInner. x)) (has_type x TYPE%lib!types.PageInner.)))))
(assert (forall ((x lib!types.PageInner.)) (! (= (lib!types.PageInner./PageInner/xblock_size x) (lib!types.PageInner./PageInner/?xblock_size x)) :pattern ((lib!types.PageInner./PageInner/xblock_size x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.PageInner.) (uInv 32 (lib!types.PageInner./PageInner/xblock_size (%Poly%lib!types.PageInner. x)))) :pattern ((lib!types.PageInner./PageInner/xblock_size (%Poly%lib!types.PageInner. x)) (has_type x TYPE%lib!types.PageInner.)))))
(assert (forall ((x lib!types.PageInner.)) (! (= (lib!types.PageInner./PageInner/local_free x) (lib!types.PageInner./PageInner/?local_free x)) :pattern ((lib!types.PageInner./PageInner/local_free x)))))
(define-fun is-lib!types.PageInner./PageInner_ ((c lib!types.PageInner.)) Bool ((_ is lib!types.PageInner./PageInner) c))
(assert (forall ((x lib!types.PageInner.)) (! (=> (is-lib!types.PageInner./PageInner_ x) (height_lt (height (Poly%lib!linked_list.LL. (lib!types.PageInner./PageInner/free x))) (height (Poly%lib!types.PageInner. x)))) :pattern ((height (Poly%lib!linked_list.LL. (lib!types.PageInner./PageInner/free x)))))))
(assert (forall ((x lib!types.PageInner.)) (! (=> (is-lib!types.PageInner./PageInner_ x) (height_lt (height (Poly%lib!linked_list.LL. (lib!types.PageInner./PageInner/local_free x))) (height (Poly%lib!types.PageInner. x)))) :pattern ((height (Poly%lib!linked_list.LL. (lib!types.PageInner./PageInner/local_free x)))))))
(assert (forall ((x lib!types.AtomicHeapPtr.)) (! (= x (%Poly%lib!types.AtomicHeapPtr. (Poly%lib!types.AtomicHeapPtr. x))) :pattern ((Poly%lib!types.AtomicHeapPtr. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.AtomicHeapPtr.) (= x (Poly%lib!types.AtomicHeapPtr. (%Poly%lib!types.AtomicHeapPtr. x)))) :pattern ((has_type x TYPE%lib!types.AtomicHeapPtr.)))))
(assert (forall ((_atomic! vstd!atomic_ghost.AtomicPtr.) (_instance! lib!tokens.Mim.Instance.) (_page_id! lib!tokens.PageId.) (_emp! lib!types.BoolAgree.x.) (_emp_inst! lib!types.BoolAgree.Instance.)) (! (=> (and (has_type (Poly%vstd!atomic_ghost.AtomicPtr. _atomic!) (TYPE%vstd!atomic_ghost.AtomicPtr. $ TYPE%lib!types.Heap. $ (TYPE%tuple%4. (GHOST $) TYPE%lib!tokens.Mim.Instance. (GHOST $) TYPE%lib!tokens.PageId. (TRACKED $) TYPE%lib!types.BoolAgree.x. (TRACKED $) TYPE%lib!types.BoolAgree.Instance.) $ (TYPE%tuple%2. $ TYPE%lib!types.BoolAgree.y. $ (TYPE%core!option.Option. $ TYPE%lib!tokens.Mim.heap_of_page.)) $ TYPE%lib!types.InvariantPredicate_auto_AtomicHeapPtr_atomic.)) (has_type (Poly%lib!tokens.PageId. _page_id!) TYPE%lib!tokens.PageId.)) (has_type (Poly%lib!types.AtomicHeapPtr. (lib!types.AtomicHeapPtr./AtomicHeapPtr _atomic! _instance! _page_id! _emp! _emp_inst!)) TYPE%lib!types.AtomicHeapPtr.)) :pattern ((has_type (Poly%lib!types.AtomicHeapPtr. (lib!types.AtomicHeapPtr./AtomicHeapPtr _atomic! _instance! _page_id! _emp! _emp_inst!)) TYPE%lib!types.AtomicHeapPtr.)))))
(assert (forall ((x lib!types.AtomicHeapPtr.)) (! (= (lib!types.AtomicHeapPtr./AtomicHeapPtr/atomic x) (lib!types.AtomicHeapPtr./AtomicHeapPtr/?atomic x)) :pattern ((lib!types.AtomicHeapPtr./AtomicHeapPtr/atomic x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.AtomicHeapPtr.) (has_type (Poly%vstd!atomic_ghost.AtomicPtr. (lib!types.AtomicHeapPtr./AtomicHeapPtr/atomic (%Poly%lib!types.AtomicHeapPtr. x))) (TYPE%vstd!atomic_ghost.AtomicPtr. $ TYPE%lib!types.Heap. $ (TYPE%tuple%4. (GHOST $) TYPE%lib!tokens.Mim.Instance. (GHOST $) TYPE%lib!tokens.PageId. (TRACKED $) TYPE%lib!types.BoolAgree.x. (TRACKED $) TYPE%lib!types.BoolAgree.Instance.) $ (TYPE%tuple%2. $ TYPE%lib!types.BoolAgree.y. $ (TYPE%core!option.Option. $ TYPE%lib!tokens.Mim.heap_of_page.)) $ TYPE%lib!types.InvariantPredicate_auto_AtomicHeapPtr_atomic.))) :pattern ((lib!types.AtomicHeapPtr./AtomicHeapPtr/atomic (%Poly%lib!types.AtomicHeapPtr. x)) (has_type x TYPE%lib!types.AtomicHeapPtr.)))))
(assert (forall ((x lib!types.AtomicHeapPtr.)) (! (= (lib!types.AtomicHeapPtr./AtomicHeapPtr/instance x) (lib!types.AtomicHeapPtr./AtomicHeapPtr/?instance x)) :pattern ((lib!types.AtomicHeapPtr./AtomicHeapPtr/instance x)))))
(assert (forall ((x lib!types.AtomicHeapPtr.)) (! (= (lib!types.AtomicHeapPtr./AtomicHeapPtr/page_id x) (lib!types.AtomicHeapPtr./AtomicHeapPtr/?page_id x)) :pattern ((lib!types.AtomicHeapPtr./AtomicHeapPtr/page_id x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.AtomicHeapPtr.) (has_type (Poly%lib!tokens.PageId. (lib!types.AtomicHeapPtr./AtomicHeapPtr/page_id (%Poly%lib!types.AtomicHeapPtr. x))) TYPE%lib!tokens.PageId.)) :pattern ((lib!types.AtomicHeapPtr./AtomicHeapPtr/page_id (%Poly%lib!types.AtomicHeapPtr. x)) (has_type x TYPE%lib!types.AtomicHeapPtr.)))))
(assert (forall ((x lib!types.AtomicHeapPtr.)) (! (= (lib!types.AtomicHeapPtr./AtomicHeapPtr/emp x) (lib!types.AtomicHeapPtr./AtomicHeapPtr/?emp x)) :pattern ((lib!types.AtomicHeapPtr./AtomicHeapPtr/emp x)))))
(assert (forall ((x lib!types.AtomicHeapPtr.)) (! (= (lib!types.AtomicHeapPtr./AtomicHeapPtr/emp_inst x) (lib!types.AtomicHeapPtr./AtomicHeapPtr/?emp_inst x)) :pattern ((lib!types.AtomicHeapPtr./AtomicHeapPtr/emp_inst x)))))
(define-fun is-lib!types.AtomicHeapPtr./AtomicHeapPtr_ ((c lib!types.AtomicHeapPtr.)) Bool ((_ is lib!types.AtomicHeapPtr./AtomicHeapPtr) c))
(assert (forall ((x lib!types.AtomicHeapPtr.)) (! (=> (is-lib!types.AtomicHeapPtr./AtomicHeapPtr_ x) (height_lt (height (Poly%vstd!atomic_ghost.AtomicPtr. (lib!types.AtomicHeapPtr./AtomicHeapPtr/atomic x))) (height (Poly%lib!types.AtomicHeapPtr. x)))) :pattern ((height (Poly%vstd!atomic_ghost.AtomicPtr. (lib!types.AtomicHeapPtr./AtomicHeapPtr/atomic x)))))))
(assert (forall ((x lib!types.AtomicHeapPtr.)) (! (=> (is-lib!types.AtomicHeapPtr./AtomicHeapPtr_ x) (height_lt (height (Poly%lib!tokens.Mim.Instance. (lib!types.AtomicHeapPtr./AtomicHeapPtr/instance x))) (height (Poly%lib!types.AtomicHeapPtr. x)))) :pattern ((height (Poly%lib!tokens.Mim.Instance. (lib!types.AtomicHeapPtr./AtomicHeapPtr/instance x)))))))
(assert (forall ((x lib!types.InvariantPredicate_auto_AtomicHeapPtr_atomic.)) (! (= x (%Poly%lib!types.InvariantPredicate_auto_AtomicHeapPtr_atomic. (Poly%lib!types.InvariantPredicate_auto_AtomicHeapPtr_atomic. x))) :pattern ((Poly%lib!types.InvariantPredicate_auto_AtomicHeapPtr_atomic. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.InvariantPredicate_auto_AtomicHeapPtr_atomic.) (= x (Poly%lib!types.InvariantPredicate_auto_AtomicHeapPtr_atomic. (%Poly%lib!types.InvariantPredicate_auto_AtomicHeapPtr_atomic. x)))) :pattern ((has_type x TYPE%lib!types.InvariantPredicate_auto_AtomicHeapPtr_atomic.)))))
(assert (forall ((x lib!types.InvariantPredicate_auto_AtomicHeapPtr_atomic.)) (! (has_type (Poly%lib!types.InvariantPredicate_auto_AtomicHeapPtr_atomic. x) TYPE%lib!types.InvariantPredicate_auto_AtomicHeapPtr_atomic.) :pattern ((has_type (Poly%lib!types.InvariantPredicate_auto_AtomicHeapPtr_atomic. x) TYPE%lib!types.InvariantPredicate_auto_AtomicHeapPtr_atomic.)))))
(assert (forall ((x lib!types.Page.)) (! (= x (%Poly%lib!types.Page. (Poly%lib!types.Page. x))) :pattern ((Poly%lib!types.Page. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.Page.) (= x (Poly%lib!types.Page. (%Poly%lib!types.Page. x)))) :pattern ((has_type x TYPE%lib!types.Page.)))))
(assert (forall ((_count! vstd!cell.PCell<u32.>.) (_offset! Int) (_inner! vstd!cell.PCell<lib!types.PageInner.>.) (_xthread_free! lib!linked_list.ThreadLLWithDelayBits.) (_xheap! lib!types.AtomicHeapPtr.) (_prev! vstd!cell.PCell<ptr_mut%<lib!types.Page.>.>.) (_next! vstd!cell.PCell<ptr_mut%<lib!types.Page.>.>.) (_padding! Int)) (! (=> (and (uInv 32 _offset!) (has_type (Poly%lib!linked_list.ThreadLLWithDelayBits. _xthread_free!) TYPE%lib!linked_list.ThreadLLWithDelayBits.) (has_type (Poly%lib!types.AtomicHeapPtr. _xheap!) TYPE%lib!types.AtomicHeapPtr.) (uInv SZ _padding!)) (has_type (Poly%lib!types.Page. (lib!types.Page./Page _count! _offset! _inner! _xthread_free! _xheap! _prev! _next! _padding!)) TYPE%lib!types.Page.)) :pattern ((has_type (Poly%lib!types.Page. (lib!types.Page./Page _count! _offset! _inner! _xthread_free! _xheap! _prev! _next! _padding!)) TYPE%lib!types.Page.)))))
(assert (forall ((x lib!types.Page.)) (! (= (lib!types.Page./Page/count x) (lib!types.Page./Page/?count x)) :pattern ((lib!types.Page./Page/count x)))))
(assert (forall ((x lib!types.Page.)) (! (= (lib!types.Page./Page/offset x) (lib!types.Page./Page/?offset x)) :pattern ((lib!types.Page./Page/offset x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.Page.) (uInv 32 (lib!types.Page./Page/offset (%Poly%lib!types.Page. x)))) :pattern ((lib!types.Page./Page/offset (%Poly%lib!types.Page. x)) (has_type x TYPE%lib!types.Page.)))))
(assert (forall ((x lib!types.Page.)) (! (= (lib!types.Page./Page/inner x) (lib!types.Page./Page/?inner x)) :pattern ((lib!types.Page./Page/inner x)))))
(assert (forall ((x lib!types.Page.)) (! (= (lib!types.Page./Page/xthread_free x) (lib!types.Page./Page/?xthread_free x)) :pattern ((lib!types.Page./Page/xthread_free x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.Page.) (has_type (Poly%lib!linked_list.ThreadLLWithDelayBits. (lib!types.Page./Page/xthread_free (%Poly%lib!types.Page. x))) TYPE%lib!linked_list.ThreadLLWithDelayBits.)) :pattern ((lib!types.Page./Page/xthread_free (%Poly%lib!types.Page. x)) (has_type x TYPE%lib!types.Page.)))))
(assert (forall ((x lib!types.Page.)) (! (= (lib!types.Page./Page/xheap x) (lib!types.Page./Page/?xheap x)) :pattern ((lib!types.Page./Page/xheap x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.Page.) (has_type (Poly%lib!types.AtomicHeapPtr. (lib!types.Page./Page/xheap (%Poly%lib!types.Page. x))) TYPE%lib!types.AtomicHeapPtr.)) :pattern ((lib!types.Page./Page/xheap (%Poly%lib!types.Page. x)) (has_type x TYPE%lib!types.Page.)))))
(assert (forall ((x lib!types.Page.)) (! (= (lib!types.Page./Page/prev x) (lib!types.Page./Page/?prev x)) :pattern ((lib!types.Page./Page/prev x)))))
(assert (forall ((x lib!types.Page.)) (! (= (lib!types.Page./Page/next x) (lib!types.Page./Page/?next x)) :pattern ((lib!types.Page./Page/next x)))))
(assert (forall ((x lib!types.Page.)) (! (= (lib!types.Page./Page/padding x) (lib!types.Page./Page/?padding x)) :pattern ((lib!types.Page./Page/padding x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.Page.) (uInv SZ (lib!types.Page./Page/padding (%Poly%lib!types.Page. x)))) :pattern ((lib!types.Page./Page/padding (%Poly%lib!types.Page. x)) (has_type x TYPE%lib!types.Page.)))))
(define-fun is-lib!types.Page./Page_ ((c lib!types.Page.)) Bool ((_ is lib!types.Page./Page) c))
(assert (forall ((x lib!types.Page.)) (! (=> (is-lib!types.Page./Page_ x) (height_lt (height (Poly%vstd!cell.PCell<lib!types.PageInner.>. (lib!types.Page./Page/inner x))) (height (Poly%lib!types.Page. x)))) :pattern ((height (Poly%vstd!cell.PCell<lib!types.PageInner.>. (lib!types.Page./Page/inner x)))))))
(assert (forall ((x lib!types.Page.)) (! (=> (is-lib!types.Page./Page_ x) (height_lt (height (Poly%lib!linked_list.ThreadLLWithDelayBits. (lib!types.Page./Page/xthread_free x))) (height (Poly%lib!types.Page. x)))) :pattern ((height (Poly%lib!linked_list.ThreadLLWithDelayBits. (lib!types.Page./Page/xthread_free x)))))))
(assert (forall ((x lib!types.Page.)) (! (=> (is-lib!types.Page./Page_ x) (height_lt (height (Poly%lib!types.AtomicHeapPtr. (lib!types.Page./Page/xheap x))) (height (Poly%lib!types.Page. x)))) :pattern ((height (Poly%lib!types.AtomicHeapPtr. (lib!types.Page./Page/xheap x)))))))
(assert (forall ((x lib!types.Page.)) (! (=> (is-lib!types.Page./Page_ x) (height_lt (height (Poly%vstd!cell.PCell<ptr_mut%<lib!types.Page.>.>. (lib!types.Page./Page/prev x))) (height (Poly%lib!types.Page. x)))) :pattern ((height (Poly%vstd!cell.PCell<ptr_mut%<lib!types.Page.>.>. (lib!types.Page./Page/prev x)))))))
(assert (forall ((x lib!types.Page.)) (! (=> (is-lib!types.Page./Page_ x) (height_lt (height (Poly%vstd!cell.PCell<ptr_mut%<lib!types.Page.>.>. (lib!types.Page./Page/next x))) (height (Poly%lib!types.Page. x)))) :pattern ((height (Poly%vstd!cell.PCell<ptr_mut%<lib!types.Page.>.>. (lib!types.Page./Page/next x)))))))
(assert (forall ((x lib!types.PageSharedAccess.)) (! (= x (%Poly%lib!types.PageSharedAccess. (Poly%lib!types.PageSharedAccess. x))) :pattern ((Poly%lib!types.PageSharedAccess. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.PageSharedAccess.) (= x (Poly%lib!types.PageSharedAccess. (%Poly%lib!types.PageSharedAccess. x)))) :pattern ((has_type x TYPE%lib!types.PageSharedAccess.)))))
(assert (forall ((x lib!types.PageSharedAccess.)) (! (= (lib!types.PageSharedAccess./PageSharedAccess/points_to x) (lib!types.PageSharedAccess./PageSharedAccess/?points_to x)) :pattern ((lib!types.PageSharedAccess./PageSharedAccess/points_to x)))))
(assert (forall ((x lib!types.PageSharedAccess.)) (! (= (lib!types.PageSharedAccess./PageSharedAccess/exposed x) (lib!types.PageSharedAccess./PageSharedAccess/?exposed x)) :pattern ((lib!types.PageSharedAccess./PageSharedAccess/exposed x)))))
(assert (forall ((x lib!types.PageSharedAccess.)) (! (has_type (Poly%lib!types.PageSharedAccess. x) TYPE%lib!types.PageSharedAccess.) :pattern ((has_type (Poly%lib!types.PageSharedAccess. x) TYPE%lib!types.PageSharedAccess.)))))
(define-fun is-lib!types.PageSharedAccess./PageSharedAccess_ ((c lib!types.PageSharedAccess.)) Bool ((_ is lib!types.PageSharedAccess./PageSharedAccess) c))
(assert (forall ((x lib!types.PageSharedAccess.)) (! (=> (is-lib!types.PageSharedAccess./PageSharedAccess_ x) (height_lt (height (Poly%vstd!raw_ptr.PointsTo<lib!types.Page.>. (lib!types.PageSharedAccess./PageSharedAccess/points_to x))) (height (Poly%lib!types.PageSharedAccess. x)))) :pattern ((height (Poly%vstd!raw_ptr.PointsTo<lib!types.Page.>. (lib!types.PageSharedAccess./PageSharedAccess/points_to x)))))))
(assert (forall ((x lib!types.SegmentKind.)) (! (= x (%Poly%lib!types.SegmentKind. (Poly%lib!types.SegmentKind. x))) :pattern ((Poly%lib!types.SegmentKind. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.SegmentKind.) (= x (Poly%lib!types.SegmentKind. (%Poly%lib!types.SegmentKind. x)))) :pattern ((has_type x TYPE%lib!types.SegmentKind.)))))
(assert (forall ((x lib!types.SegmentKind.)) (! (has_type (Poly%lib!types.SegmentKind. x) TYPE%lib!types.SegmentKind.) :pattern ((has_type (Poly%lib!types.SegmentKind. x) TYPE%lib!types.SegmentKind.)))))
(assert (forall ((x lib!types.SegmentHeaderMain.)) (! (= x (%Poly%lib!types.SegmentHeaderMain. (Poly%lib!types.SegmentHeaderMain. x))) :pattern ((Poly%lib!types.SegmentHeaderMain. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.SegmentHeaderMain.) (= x (Poly%lib!types.SegmentHeaderMain. (%Poly%lib!types.SegmentHeaderMain. x)))) :pattern ((has_type x TYPE%lib!types.SegmentHeaderMain.)))))
(assert (forall ((_memid! Int) (_mem_is_pinned! Bool) (_mem_is_large! Bool) (_mem_is_committed! Bool) (_mem_alignment! Int) (_mem_align_offset! Int) (_allow_decommit! Bool) (_decommit_expire! Int) (_decommit_mask! lib!commit_mask.CommitMask.) (_commit_mask! lib!commit_mask.CommitMask.)) (! (=> (and (uInv SZ _memid!) (uInv SZ _mem_alignment!) (uInv SZ _mem_align_offset!) (iInv 64 _decommit_expire!)) (has_type (Poly%lib!types.SegmentHeaderMain. (lib!types.SegmentHeaderMain./SegmentHeaderMain _memid! _mem_is_pinned! _mem_is_large! _mem_is_committed! _mem_alignment! _mem_align_offset! _allow_decommit! _decommit_expire! _decommit_mask! _commit_mask!)) TYPE%lib!types.SegmentHeaderMain.)) :pattern ((has_type (Poly%lib!types.SegmentHeaderMain. (lib!types.SegmentHeaderMain./SegmentHeaderMain _memid! _mem_is_pinned! _mem_is_large! _mem_is_committed! _mem_alignment! _mem_align_offset! _allow_decommit! _decommit_expire! _decommit_mask! _commit_mask!)) TYPE%lib!types.SegmentHeaderMain.)))))
(assert (forall ((x lib!types.SegmentHeaderMain.)) (! (= (lib!types.SegmentHeaderMain./SegmentHeaderMain/memid x) (lib!types.SegmentHeaderMain./SegmentHeaderMain/?memid x)) :pattern ((lib!types.SegmentHeaderMain./SegmentHeaderMain/memid x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.SegmentHeaderMain.) (uInv SZ (lib!types.SegmentHeaderMain./SegmentHeaderMain/memid (%Poly%lib!types.SegmentHeaderMain. x)))) :pattern ((lib!types.SegmentHeaderMain./SegmentHeaderMain/memid (%Poly%lib!types.SegmentHeaderMain. x)) (has_type x TYPE%lib!types.SegmentHeaderMain.)))))
(assert (forall ((x lib!types.SegmentHeaderMain.)) (! (= (lib!types.SegmentHeaderMain./SegmentHeaderMain/mem_is_pinned x) (lib!types.SegmentHeaderMain./SegmentHeaderMain/?mem_is_pinned x)) :pattern ((lib!types.SegmentHeaderMain./SegmentHeaderMain/mem_is_pinned x)))))
(assert (forall ((x lib!types.SegmentHeaderMain.)) (! (= (lib!types.SegmentHeaderMain./SegmentHeaderMain/mem_is_large x) (lib!types.SegmentHeaderMain./SegmentHeaderMain/?mem_is_large x)) :pattern ((lib!types.SegmentHeaderMain./SegmentHeaderMain/mem_is_large x)))))
(assert (forall ((x lib!types.SegmentHeaderMain.)) (! (= (lib!types.SegmentHeaderMain./SegmentHeaderMain/mem_is_committed x) (lib!types.SegmentHeaderMain./SegmentHeaderMain/?mem_is_committed x)) :pattern ((lib!types.SegmentHeaderMain./SegmentHeaderMain/mem_is_committed x)))))
(assert (forall ((x lib!types.SegmentHeaderMain.)) (! (= (lib!types.SegmentHeaderMain./SegmentHeaderMain/mem_alignment x) (lib!types.SegmentHeaderMain./SegmentHeaderMain/?mem_alignment x)) :pattern ((lib!types.SegmentHeaderMain./SegmentHeaderMain/mem_alignment x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.SegmentHeaderMain.) (uInv SZ (lib!types.SegmentHeaderMain./SegmentHeaderMain/mem_alignment (%Poly%lib!types.SegmentHeaderMain. x)))) :pattern ((lib!types.SegmentHeaderMain./SegmentHeaderMain/mem_alignment (%Poly%lib!types.SegmentHeaderMain. x)) (has_type x TYPE%lib!types.SegmentHeaderMain.)))))
(assert (forall ((x lib!types.SegmentHeaderMain.)) (! (= (lib!types.SegmentHeaderMain./SegmentHeaderMain/mem_align_offset x) (lib!types.SegmentHeaderMain./SegmentHeaderMain/?mem_align_offset x)) :pattern ((lib!types.SegmentHeaderMain./SegmentHeaderMain/mem_align_offset x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.SegmentHeaderMain.) (uInv SZ (lib!types.SegmentHeaderMain./SegmentHeaderMain/mem_align_offset (%Poly%lib!types.SegmentHeaderMain. x)))) :pattern ((lib!types.SegmentHeaderMain./SegmentHeaderMain/mem_align_offset (%Poly%lib!types.SegmentHeaderMain. x)) (has_type x TYPE%lib!types.SegmentHeaderMain.)))))
(assert (forall ((x lib!types.SegmentHeaderMain.)) (! (= (lib!types.SegmentHeaderMain./SegmentHeaderMain/allow_decommit x) (lib!types.SegmentHeaderMain./SegmentHeaderMain/?allow_decommit x)) :pattern ((lib!types.SegmentHeaderMain./SegmentHeaderMain/allow_decommit x)))))
(assert (forall ((x lib!types.SegmentHeaderMain.)) (! (= (lib!types.SegmentHeaderMain./SegmentHeaderMain/decommit_expire x) (lib!types.SegmentHeaderMain./SegmentHeaderMain/?decommit_expire x)) :pattern ((lib!types.SegmentHeaderMain./SegmentHeaderMain/decommit_expire x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.SegmentHeaderMain.) (iInv 64 (lib!types.SegmentHeaderMain./SegmentHeaderMain/decommit_expire (%Poly%lib!types.SegmentHeaderMain. x)))) :pattern ((lib!types.SegmentHeaderMain./SegmentHeaderMain/decommit_expire (%Poly%lib!types.SegmentHeaderMain. x)) (has_type x TYPE%lib!types.SegmentHeaderMain.)))))
(assert (forall ((x lib!types.SegmentHeaderMain.)) (! (= (lib!types.SegmentHeaderMain./SegmentHeaderMain/decommit_mask x) (lib!types.SegmentHeaderMain./SegmentHeaderMain/?decommit_mask x)) :pattern ((lib!types.SegmentHeaderMain./SegmentHeaderMain/decommit_mask x)))))
(assert (forall ((x lib!types.SegmentHeaderMain.)) (! (= (lib!types.SegmentHeaderMain./SegmentHeaderMain/commit_mask x) (lib!types.SegmentHeaderMain./SegmentHeaderMain/?commit_mask x)) :pattern ((lib!types.SegmentHeaderMain./SegmentHeaderMain/commit_mask x)))))
(assert (forall ((x lib!types.SegmentHeaderMain2.)) (! (= x (%Poly%lib!types.SegmentHeaderMain2. (Poly%lib!types.SegmentHeaderMain2. x))) :pattern ((Poly%lib!types.SegmentHeaderMain2. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.SegmentHeaderMain2.) (= x (Poly%lib!types.SegmentHeaderMain2. (%Poly%lib!types.SegmentHeaderMain2. x)))) :pattern ((has_type x TYPE%lib!types.SegmentHeaderMain2.)))))
(assert (forall ((_next! ptr_mut%<lib!types.SegmentHeader.>.) (_abandoned! Int) (_abandoned_visits! Int) (_used! Int) (_cookie! Int) (_segment_slices! Int) (_segment_info_slices! Int) (_kind! lib!types.SegmentKind.) (_slice_entries! Int)) (! (=> (and (uInv SZ _abandoned!) (uInv SZ _abandoned_visits!) (uInv SZ _used!) (uInv SZ _cookie!) (uInv SZ _segment_slices!) (uInv SZ _segment_info_slices!) (uInv SZ _slice_entries!)) (has_type (Poly%lib!types.SegmentHeaderMain2. (lib!types.SegmentHeaderMain2./SegmentHeaderMain2 _next! _abandoned! _abandoned_visits! _used! _cookie! _segment_slices! _segment_info_slices! _kind! _slice_entries!)) TYPE%lib!types.SegmentHeaderMain2.)) :pattern ((has_type (Poly%lib!types.SegmentHeaderMain2. (lib!types.SegmentHeaderMain2./SegmentHeaderMain2 _next! _abandoned! _abandoned_visits! _used! _cookie! _segment_slices! _segment_info_slices! _kind! _slice_entries!)) TYPE%lib!types.SegmentHeaderMain2.)))))
(assert (forall ((x lib!types.SegmentHeaderMain2.)) (! (= (lib!types.SegmentHeaderMain2./SegmentHeaderMain2/next x) (lib!types.SegmentHeaderMain2./SegmentHeaderMain2/?next x)) :pattern ((lib!types.SegmentHeaderMain2./SegmentHeaderMain2/next x)))))
(assert (forall ((x lib!types.SegmentHeaderMain2.)) (! (= (lib!types.SegmentHeaderMain2./SegmentHeaderMain2/abandoned x) (lib!types.SegmentHeaderMain2./SegmentHeaderMain2/?abandoned x)) :pattern ((lib!types.SegmentHeaderMain2./SegmentHeaderMain2/abandoned x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.SegmentHeaderMain2.) (uInv SZ (lib!types.SegmentHeaderMain2./SegmentHeaderMain2/abandoned (%Poly%lib!types.SegmentHeaderMain2. x)))) :pattern ((lib!types.SegmentHeaderMain2./SegmentHeaderMain2/abandoned (%Poly%lib!types.SegmentHeaderMain2. x)) (has_type x TYPE%lib!types.SegmentHeaderMain2.)))))
(assert (forall ((x lib!types.SegmentHeaderMain2.)) (! (= (lib!types.SegmentHeaderMain2./SegmentHeaderMain2/abandoned_visits x) (lib!types.SegmentHeaderMain2./SegmentHeaderMain2/?abandoned_visits x)) :pattern ((lib!types.SegmentHeaderMain2./SegmentHeaderMain2/abandoned_visits x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.SegmentHeaderMain2.) (uInv SZ (lib!types.SegmentHeaderMain2./SegmentHeaderMain2/abandoned_visits (%Poly%lib!types.SegmentHeaderMain2. x)))) :pattern ((lib!types.SegmentHeaderMain2./SegmentHeaderMain2/abandoned_visits (%Poly%lib!types.SegmentHeaderMain2. x)) (has_type x TYPE%lib!types.SegmentHeaderMain2.)))))
(assert (forall ((x lib!types.SegmentHeaderMain2.)) (! (= (lib!types.SegmentHeaderMain2./SegmentHeaderMain2/used x) (lib!types.SegmentHeaderMain2./SegmentHeaderMain2/?used x)) :pattern ((lib!types.SegmentHeaderMain2./SegmentHeaderMain2/used x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.SegmentHeaderMain2.) (uInv SZ (lib!types.SegmentHeaderMain2./SegmentHeaderMain2/used (%Poly%lib!types.SegmentHeaderMain2. x)))) :pattern ((lib!types.SegmentHeaderMain2./SegmentHeaderMain2/used (%Poly%lib!types.SegmentHeaderMain2. x)) (has_type x TYPE%lib!types.SegmentHeaderMain2.)))))
(assert (forall ((x lib!types.SegmentHeaderMain2.)) (! (= (lib!types.SegmentHeaderMain2./SegmentHeaderMain2/cookie x) (lib!types.SegmentHeaderMain2./SegmentHeaderMain2/?cookie x)) :pattern ((lib!types.SegmentHeaderMain2./SegmentHeaderMain2/cookie x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.SegmentHeaderMain2.) (uInv SZ (lib!types.SegmentHeaderMain2./SegmentHeaderMain2/cookie (%Poly%lib!types.SegmentHeaderMain2. x)))) :pattern ((lib!types.SegmentHeaderMain2./SegmentHeaderMain2/cookie (%Poly%lib!types.SegmentHeaderMain2. x)) (has_type x TYPE%lib!types.SegmentHeaderMain2.)))))
(assert (forall ((x lib!types.SegmentHeaderMain2.)) (! (= (lib!types.SegmentHeaderMain2./SegmentHeaderMain2/segment_slices x) (lib!types.SegmentHeaderMain2./SegmentHeaderMain2/?segment_slices x)) :pattern ((lib!types.SegmentHeaderMain2./SegmentHeaderMain2/segment_slices x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.SegmentHeaderMain2.) (uInv SZ (lib!types.SegmentHeaderMain2./SegmentHeaderMain2/segment_slices (%Poly%lib!types.SegmentHeaderMain2. x)))) :pattern ((lib!types.SegmentHeaderMain2./SegmentHeaderMain2/segment_slices (%Poly%lib!types.SegmentHeaderMain2. x)) (has_type x TYPE%lib!types.SegmentHeaderMain2.)))))
(assert (forall ((x lib!types.SegmentHeaderMain2.)) (! (= (lib!types.SegmentHeaderMain2./SegmentHeaderMain2/segment_info_slices x) (lib!types.SegmentHeaderMain2./SegmentHeaderMain2/?segment_info_slices x)) :pattern ((lib!types.SegmentHeaderMain2./SegmentHeaderMain2/segment_info_slices x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.SegmentHeaderMain2.) (uInv SZ (lib!types.SegmentHeaderMain2./SegmentHeaderMain2/segment_info_slices (%Poly%lib!types.SegmentHeaderMain2. x)))) :pattern ((lib!types.SegmentHeaderMain2./SegmentHeaderMain2/segment_info_slices (%Poly%lib!types.SegmentHeaderMain2. x)) (has_type x TYPE%lib!types.SegmentHeaderMain2.)))))
(assert (forall ((x lib!types.SegmentHeaderMain2.)) (! (= (lib!types.SegmentHeaderMain2./SegmentHeaderMain2/kind x) (lib!types.SegmentHeaderMain2./SegmentHeaderMain2/?kind x)) :pattern ((lib!types.SegmentHeaderMain2./SegmentHeaderMain2/kind x)))))
(assert (forall ((x lib!types.SegmentHeaderMain2.)) (! (= (lib!types.SegmentHeaderMain2./SegmentHeaderMain2/slice_entries x) (lib!types.SegmentHeaderMain2./SegmentHeaderMain2/?slice_entries x)) :pattern ((lib!types.SegmentHeaderMain2./SegmentHeaderMain2/slice_entries x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.SegmentHeaderMain2.) (uInv SZ (lib!types.SegmentHeaderMain2./SegmentHeaderMain2/slice_entries (%Poly%lib!types.SegmentHeaderMain2. x)))) :pattern ((lib!types.SegmentHeaderMain2./SegmentHeaderMain2/slice_entries (%Poly%lib!types.SegmentHeaderMain2. x)) (has_type x TYPE%lib!types.SegmentHeaderMain2.)))))
(assert (forall ((x lib!types.SegmentHeader.)) (! (= x (%Poly%lib!types.SegmentHeader. (Poly%lib!types.SegmentHeader. x))) :pattern ((Poly%lib!types.SegmentHeader. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.SegmentHeader.) (= x (Poly%lib!types.SegmentHeader. (%Poly%lib!types.SegmentHeader. x)))) :pattern ((has_type x TYPE%lib!types.SegmentHeader.)))))
(assert (forall ((_main! vstd!cell.PCell<lib!types.SegmentHeaderMain.>.) (_abandoned_next! Int) (_main2! vstd!cell.PCell<lib!types.SegmentHeaderMain2.>.) (_thread_id! vstd!atomic_ghost.AtomicU64.) (_instance! lib!tokens.Mim.Instance.) (_segment_id! lib!tokens.SegmentId.)) (! (=> (and (uInv SZ _abandoned_next!) (has_type (Poly%vstd!atomic_ghost.AtomicU64. _thread_id!) (TYPE%vstd!atomic_ghost.AtomicU64. $ (TYPE%tuple%2. (GHOST $) TYPE%lib!tokens.Mim.Instance. (GHOST $) TYPE%lib!tokens.SegmentId.) $ TYPE%lib!tokens.Mim.thread_of_segment. $ TYPE%lib!types.InvariantPredicate_auto_SegmentHeader_thread_id.)) (has_type (Poly%lib!tokens.SegmentId. _segment_id!) TYPE%lib!tokens.SegmentId.)) (has_type (Poly%lib!types.SegmentHeader. (lib!types.SegmentHeader./SegmentHeader _main! _abandoned_next! _main2! _thread_id! _instance! _segment_id!)) TYPE%lib!types.SegmentHeader.)) :pattern ((has_type (Poly%lib!types.SegmentHeader. (lib!types.SegmentHeader./SegmentHeader _main! _abandoned_next! _main2! _thread_id! _instance! _segment_id!)) TYPE%lib!types.SegmentHeader.)))))
(assert (forall ((x lib!types.SegmentHeader.)) (! (= (lib!types.SegmentHeader./SegmentHeader/main x) (lib!types.SegmentHeader./SegmentHeader/?main x)) :pattern ((lib!types.SegmentHeader./SegmentHeader/main x)))))
(assert (forall ((x lib!types.SegmentHeader.)) (! (= (lib!types.SegmentHeader./SegmentHeader/abandoned_next x) (lib!types.SegmentHeader./SegmentHeader/?abandoned_next x)) :pattern ((lib!types.SegmentHeader./SegmentHeader/abandoned_next x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.SegmentHeader.) (uInv SZ (lib!types.SegmentHeader./SegmentHeader/abandoned_next (%Poly%lib!types.SegmentHeader. x)))) :pattern ((lib!types.SegmentHeader./SegmentHeader/abandoned_next (%Poly%lib!types.SegmentHeader. x)) (has_type x TYPE%lib!types.SegmentHeader.)))))
(assert (forall ((x lib!types.SegmentHeader.)) (! (= (lib!types.SegmentHeader./SegmentHeader/main2 x) (lib!types.SegmentHeader./SegmentHeader/?main2 x)) :pattern ((lib!types.SegmentHeader./SegmentHeader/main2 x)))))
(assert (forall ((x lib!types.SegmentHeader.)) (! (= (lib!types.SegmentHeader./SegmentHeader/thread_id x) (lib!types.SegmentHeader./SegmentHeader/?thread_id x)) :pattern ((lib!types.SegmentHeader./SegmentHeader/thread_id x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.SegmentHeader.) (has_type (Poly%vstd!atomic_ghost.AtomicU64. (lib!types.SegmentHeader./SegmentHeader/thread_id (%Poly%lib!types.SegmentHeader. x))) (TYPE%vstd!atomic_ghost.AtomicU64. $ (TYPE%tuple%2. (GHOST $) TYPE%lib!tokens.Mim.Instance. (GHOST $) TYPE%lib!tokens.SegmentId.) $ TYPE%lib!tokens.Mim.thread_of_segment. $ TYPE%lib!types.InvariantPredicate_auto_SegmentHeader_thread_id.))) :pattern ((lib!types.SegmentHeader./SegmentHeader/thread_id (%Poly%lib!types.SegmentHeader. x)) (has_type x TYPE%lib!types.SegmentHeader.)))))
(assert (forall ((x lib!types.SegmentHeader.)) (! (= (lib!types.SegmentHeader./SegmentHeader/instance x) (lib!types.SegmentHeader./SegmentHeader/?instance x)) :pattern ((lib!types.SegmentHeader./SegmentHeader/instance x)))))
(assert (forall ((x lib!types.SegmentHeader.)) (! (= (lib!types.SegmentHeader./SegmentHeader/segment_id x) (lib!types.SegmentHeader./SegmentHeader/?segment_id x)) :pattern ((lib!types.SegmentHeader./SegmentHeader/segment_id x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.SegmentHeader.) (has_type (Poly%lib!tokens.SegmentId. (lib!types.SegmentHeader./SegmentHeader/segment_id (%Poly%lib!types.SegmentHeader. x))) TYPE%lib!tokens.SegmentId.)) :pattern ((lib!types.SegmentHeader./SegmentHeader/segment_id (%Poly%lib!types.SegmentHeader. x)) (has_type x TYPE%lib!types.SegmentHeader.)))))
(define-fun is-lib!types.SegmentHeader./SegmentHeader_ ((c lib!types.SegmentHeader.)) Bool ((_ is lib!types.SegmentHeader./SegmentHeader) c))
(assert (forall ((x lib!types.SegmentHeader.)) (! (=> (is-lib!types.SegmentHeader./SegmentHeader_ x) (height_lt (height (Poly%vstd!cell.PCell<lib!types.SegmentHeaderMain2.>. (lib!types.SegmentHeader./SegmentHeader/main2 x))) (height (Poly%lib!types.SegmentHeader. x)))) :pattern ((height (Poly%vstd!cell.PCell<lib!types.SegmentHeaderMain2.>. (lib!types.SegmentHeader./SegmentHeader/main2 x)))))))
(assert (forall ((x lib!types.SegmentHeader.)) (! (=> (is-lib!types.SegmentHeader./SegmentHeader_ x) (height_lt (height (Poly%vstd!atomic_ghost.AtomicU64. (lib!types.SegmentHeader./SegmentHeader/thread_id x))) (height (Poly%lib!types.SegmentHeader. x)))) :pattern ((height (Poly%vstd!atomic_ghost.AtomicU64. (lib!types.SegmentHeader./SegmentHeader/thread_id x)))))))
(assert (forall ((x lib!types.SegmentHeader.)) (! (=> (is-lib!types.SegmentHeader./SegmentHeader_ x) (height_lt (height (Poly%lib!tokens.Mim.Instance. (lib!types.SegmentHeader./SegmentHeader/instance x))) (height (Poly%lib!types.SegmentHeader. x)))) :pattern ((height (Poly%lib!tokens.Mim.Instance. (lib!types.SegmentHeader./SegmentHeader/instance x)))))))
(assert (forall ((x lib!types.InvariantPredicate_auto_SegmentHeader_thread_id.)) (! (= x (%Poly%lib!types.InvariantPredicate_auto_SegmentHeader_thread_id. (Poly%lib!types.InvariantPredicate_auto_SegmentHeader_thread_id. x))) :pattern ((Poly%lib!types.InvariantPredicate_auto_SegmentHeader_thread_id. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.InvariantPredicate_auto_SegmentHeader_thread_id.) (= x (Poly%lib!types.InvariantPredicate_auto_SegmentHeader_thread_id. (%Poly%lib!types.InvariantPredicate_auto_SegmentHeader_thread_id. x)))) :pattern ((has_type x TYPE%lib!types.InvariantPredicate_auto_SegmentHeader_thread_id.)))))
(assert (forall ((x lib!types.InvariantPredicate_auto_SegmentHeader_thread_id.)) (! (has_type (Poly%lib!types.InvariantPredicate_auto_SegmentHeader_thread_id. x) TYPE%lib!types.InvariantPredicate_auto_SegmentHeader_thread_id.) :pattern ((has_type (Poly%lib!types.InvariantPredicate_auto_SegmentHeader_thread_id. x) TYPE%lib!types.InvariantPredicate_auto_SegmentHeader_thread_id.)))))
(assert (forall ((x lib!types.SegmentSharedAccess.)) (! (= x (%Poly%lib!types.SegmentSharedAccess. (Poly%lib!types.SegmentSharedAccess. x))) :pattern ((Poly%lib!types.SegmentSharedAccess. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.SegmentSharedAccess.) (= x (Poly%lib!types.SegmentSharedAccess. (%Poly%lib!types.SegmentSharedAccess. x)))) :pattern ((has_type x TYPE%lib!types.SegmentSharedAccess.)))))
(assert (forall ((x lib!types.SegmentSharedAccess.)) (! (= (lib!types.SegmentSharedAccess./SegmentSharedAccess/points_to x) (lib!types.SegmentSharedAccess./SegmentSharedAccess/?points_to x)) :pattern ((lib!types.SegmentSharedAccess./SegmentSharedAccess/points_to x)))))
(assert (forall ((x lib!types.SegmentSharedAccess.)) (! (has_type (Poly%lib!types.SegmentSharedAccess. x) TYPE%lib!types.SegmentSharedAccess.) :pattern ((has_type (Poly%lib!types.SegmentSharedAccess. x) TYPE%lib!types.SegmentSharedAccess.)))))
(define-fun is-lib!types.SegmentSharedAccess./SegmentSharedAccess_ ((c lib!types.SegmentSharedAccess.)) Bool ((_ is lib!types.SegmentSharedAccess./SegmentSharedAccess) c))
(assert (forall ((x lib!types.SegmentSharedAccess.)) (! (=> (is-lib!types.SegmentSharedAccess./SegmentSharedAccess_ x) (height_lt (height (Poly%vstd!raw_ptr.PointsTo<lib!types.SegmentHeader.>. (lib!types.SegmentSharedAccess./SegmentSharedAccess/points_to x))) (height (Poly%lib!types.SegmentSharedAccess. x)))) :pattern ((height (Poly%vstd!raw_ptr.PointsTo<lib!types.SegmentHeader.>. (lib!types.SegmentSharedAccess./SegmentSharedAccess/points_to x)))))))
(assert (forall ((x lib!types.PageQueue.)) (! (= x (%Poly%lib!types.PageQueue. (Poly%lib!types.PageQueue. x))) :pattern ((Poly%lib!types.PageQueue. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.PageQueue.) (= x (Poly%lib!types.PageQueue. (%Poly%lib!types.PageQueue. x)))) :pattern ((has_type x TYPE%lib!types.PageQueue.)))))
(assert (forall ((_first! ptr_mut%<lib!types.Page.>.) (_last! ptr_mut%<lib!types.Page.>.) (_block_size! Int)) (! (=> (uInv SZ _block_size!) (has_type (Poly%lib!types.PageQueue. (lib!types.PageQueue./PageQueue _first! _last! _block_size!)) TYPE%lib!types.PageQueue.)) :pattern ((has_type (Poly%lib!types.PageQueue. (lib!types.PageQueue./PageQueue _first! _last! _block_size!)) TYPE%lib!types.PageQueue.)))))
(assert (forall ((x lib!types.PageQueue.)) (! (= (lib!types.PageQueue./PageQueue/first x) (lib!types.PageQueue./PageQueue/?first x)) :pattern ((lib!types.PageQueue./PageQueue/first x)))))
(assert (forall ((x lib!types.PageQueue.)) (! (= (lib!types.PageQueue./PageQueue/last x) (lib!types.PageQueue./PageQueue/?last x)) :pattern ((lib!types.PageQueue./PageQueue/last x)))))
(assert (forall ((x lib!types.PageQueue.)) (! (= (lib!types.PageQueue./PageQueue/block_size x) (lib!types.PageQueue./PageQueue/?block_size x)) :pattern ((lib!types.PageQueue./PageQueue/block_size x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.PageQueue.) (uInv SZ (lib!types.PageQueue./PageQueue/block_size (%Poly%lib!types.PageQueue. x)))) :pattern ((lib!types.PageQueue./PageQueue/block_size (%Poly%lib!types.PageQueue. x)) (has_type x TYPE%lib!types.PageQueue.)))))
(assert (forall ((x lib!types.Heap.)) (! (= x (%Poly%lib!types.Heap. (Poly%lib!types.Heap. x))) :pattern ((Poly%lib!types.Heap. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.Heap.) (= x (Poly%lib!types.Heap. (%Poly%lib!types.Heap. x)))) :pattern ((has_type x TYPE%lib!types.Heap.)))))
(assert (forall ((_tld_ptr! lib!types.TldPtr.) (_pages_free_direct! Poly) (_pages! Poly) (_thread_delayed_free! lib!linked_list.ThreadLLSimple.) (_thread_id! lib!thread.ThreadId.) (_arena_id! Int) (_page_count! vstd!cell.PCell<usize.>.) (_page_retired_min! vstd!cell.PCell<usize.>.) (_page_retired_max! vstd!cell.PCell<usize.>.) (_no_reclaim! Bool) (_page_empty_ptr! ptr_mut%<lib!types.Page.>.)) (! (=> (and (has_type (Poly%lib!types.TldPtr. _tld_ptr!) TYPE%lib!types.TldPtr.) (has_type _pages_free_direct! (TYPE%vstd!cell.PCell. $ (ARRAY $ (PTR $ TYPE%lib!types.Page.) $ (CONST_INT 129)))) (has_type _pages! (TYPE%vstd!cell.PCell. $ (ARRAY $ TYPE%lib!types.PageQueue. $ (CONST_INT 75)))) (has_type (Poly%lib!linked_list.ThreadLLSimple. _thread_delayed_free!) TYPE%lib!linked_list.ThreadLLSimple.) (has_type (Poly%lib!thread.ThreadId. _thread_id!) TYPE%lib!thread.ThreadId.) (uInv SZ _arena_id!)) (has_type (Poly%lib!types.Heap. (lib!types.Heap./Heap _tld_ptr! _pages_free_direct! _pages! _thread_delayed_free! _thread_id! _arena_id! _page_count! _page_retired_min! _page_retired_max! _no_reclaim! _page_empty_ptr!)) TYPE%lib!types.Heap.)) :pattern ((has_type (Poly%lib!types.Heap. (lib!types.Heap./Heap _tld_ptr! _pages_free_direct! _pages! _thread_delayed_free! _thread_id! _arena_id! _page_count! _page_retired_min! _page_retired_max! _no_reclaim! _page_empty_ptr!)) TYPE%lib!types.Heap.)))))
(assert (forall ((x lib!types.Heap.)) (! (= (lib!types.Heap./Heap/tld_ptr x) (lib!types.Heap./Heap/?tld_ptr x)) :pattern ((lib!types.Heap./Heap/tld_ptr x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.Heap.) (has_type (Poly%lib!types.TldPtr. (lib!types.Heap./Heap/tld_ptr (%Poly%lib!types.Heap. x))) TYPE%lib!types.TldPtr.)) :pattern ((lib!types.Heap./Heap/tld_ptr (%Poly%lib!types.Heap. x)) (has_type x TYPE%lib!types.Heap.)))))
(assert (forall ((x lib!types.Heap.)) (! (= (lib!types.Heap./Heap/pages_free_direct x) (lib!types.Heap./Heap/?pages_free_direct x)) :pattern ((lib!types.Heap./Heap/pages_free_direct x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.Heap.) (has_type (lib!types.Heap./Heap/pages_free_direct (%Poly%lib!types.Heap. x)) (TYPE%vstd!cell.PCell. $ (ARRAY $ (PTR $ TYPE%lib!types.Page.) $ (CONST_INT 129))))) :pattern ((lib!types.Heap./Heap/pages_free_direct (%Poly%lib!types.Heap. x)) (has_type x TYPE%lib!types.Heap.)))))
(assert (forall ((x lib!types.Heap.)) (! (= (lib!types.Heap./Heap/pages x) (lib!types.Heap./Heap/?pages x)) :pattern ((lib!types.Heap./Heap/pages x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.Heap.) (has_type (lib!types.Heap./Heap/pages (%Poly%lib!types.Heap. x)) (TYPE%vstd!cell.PCell. $ (ARRAY $ TYPE%lib!types.PageQueue. $ (CONST_INT 75))))) :pattern ((lib!types.Heap./Heap/pages (%Poly%lib!types.Heap. x)) (has_type x TYPE%lib!types.Heap.)))))
(assert (forall ((x lib!types.Heap.)) (! (= (lib!types.Heap./Heap/thread_delayed_free x) (lib!types.Heap./Heap/?thread_delayed_free x)) :pattern ((lib!types.Heap./Heap/thread_delayed_free x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.Heap.) (has_type (Poly%lib!linked_list.ThreadLLSimple. (lib!types.Heap./Heap/thread_delayed_free (%Poly%lib!types.Heap. x))) TYPE%lib!linked_list.ThreadLLSimple.)) :pattern ((lib!types.Heap./Heap/thread_delayed_free (%Poly%lib!types.Heap. x)) (has_type x TYPE%lib!types.Heap.)))))
(assert (forall ((x lib!types.Heap.)) (! (= (lib!types.Heap./Heap/thread_id x) (lib!types.Heap./Heap/?thread_id x)) :pattern ((lib!types.Heap./Heap/thread_id x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.Heap.) (has_type (Poly%lib!thread.ThreadId. (lib!types.Heap./Heap/thread_id (%Poly%lib!types.Heap. x))) TYPE%lib!thread.ThreadId.)) :pattern ((lib!types.Heap./Heap/thread_id (%Poly%lib!types.Heap. x)) (has_type x TYPE%lib!types.Heap.)))))
(assert (forall ((x lib!types.Heap.)) (! (= (lib!types.Heap./Heap/arena_id x) (lib!types.Heap./Heap/?arena_id x)) :pattern ((lib!types.Heap./Heap/arena_id x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.Heap.) (uInv SZ (lib!types.Heap./Heap/arena_id (%Poly%lib!types.Heap. x)))) :pattern ((lib!types.Heap./Heap/arena_id (%Poly%lib!types.Heap. x)) (has_type x TYPE%lib!types.Heap.)))))
(assert (forall ((x lib!types.Heap.)) (! (= (lib!types.Heap./Heap/page_count x) (lib!types.Heap./Heap/?page_count x)) :pattern ((lib!types.Heap./Heap/page_count x)))))
(assert (forall ((x lib!types.Heap.)) (! (= (lib!types.Heap./Heap/page_retired_min x) (lib!types.Heap./Heap/?page_retired_min x)) :pattern ((lib!types.Heap./Heap/page_retired_min x)))))
(assert (forall ((x lib!types.Heap.)) (! (= (lib!types.Heap./Heap/page_retired_max x) (lib!types.Heap./Heap/?page_retired_max x)) :pattern ((lib!types.Heap./Heap/page_retired_max x)))))
(assert (forall ((x lib!types.Heap.)) (! (= (lib!types.Heap./Heap/no_reclaim x) (lib!types.Heap./Heap/?no_reclaim x)) :pattern ((lib!types.Heap./Heap/no_reclaim x)))))
(assert (forall ((x lib!types.Heap.)) (! (= (lib!types.Heap./Heap/page_empty_ptr x) (lib!types.Heap./Heap/?page_empty_ptr x)) :pattern ((lib!types.Heap./Heap/page_empty_ptr x)))))
(define-fun is-lib!types.Heap./Heap_ ((c lib!types.Heap.)) Bool ((_ is lib!types.Heap./Heap) c))
(assert (forall ((x lib!types.Heap.)) (! (=> (is-lib!types.Heap./Heap_ x) (height_lt (height (Poly%lib!types.TldPtr. (lib!types.Heap./Heap/tld_ptr x))) (height (Poly%lib!types.Heap. x)))) :pattern ((height (Poly%lib!types.TldPtr. (lib!types.Heap./Heap/tld_ptr x)))))))
(assert (forall ((x lib!types.Heap.)) (! (=> (is-lib!types.Heap./Heap_ x) (height_lt (height (lib!types.Heap./Heap/pages_free_direct x)) (height (Poly%lib!types.Heap. x)))) :pattern ((height (lib!types.Heap./Heap/pages_free_direct x))))))
(assert (forall ((x lib!types.Heap.)) (! (=> (is-lib!types.Heap./Heap_ x) (height_lt (height (lib!types.Heap./Heap/pages x)) (height (Poly%lib!types.Heap. x)))) :pattern ((height (lib!types.Heap./Heap/pages x))))))
(assert (forall ((x lib!types.Heap.)) (! (=> (is-lib!types.Heap./Heap_ x) (height_lt (height (Poly%lib!linked_list.ThreadLLSimple. (lib!types.Heap./Heap/thread_delayed_free x))) (height (Poly%lib!types.Heap. x)))) :pattern ((height (Poly%lib!linked_list.ThreadLLSimple. (lib!types.Heap./Heap/thread_delayed_free x)))))))
(assert (forall ((x lib!types.HeapSharedAccess.)) (! (= x (%Poly%lib!types.HeapSharedAccess. (Poly%lib!types.HeapSharedAccess. x))) :pattern ((Poly%lib!types.HeapSharedAccess. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.HeapSharedAccess.) (= x (Poly%lib!types.HeapSharedAccess. (%Poly%lib!types.HeapSharedAccess. x)))) :pattern ((has_type x TYPE%lib!types.HeapSharedAccess.)))))
(assert (forall ((x lib!types.HeapSharedAccess.)) (! (= (lib!types.HeapSharedAccess./HeapSharedAccess/points_to x) (lib!types.HeapSharedAccess./HeapSharedAccess/?points_to x)) :pattern ((lib!types.HeapSharedAccess./HeapSharedAccess/points_to x)))))
(assert (forall ((x lib!types.HeapSharedAccess.)) (! (has_type (Poly%lib!types.HeapSharedAccess. x) TYPE%lib!types.HeapSharedAccess.) :pattern ((has_type (Poly%lib!types.HeapSharedAccess. x) TYPE%lib!types.HeapSharedAccess.)))))
(define-fun is-lib!types.HeapSharedAccess./HeapSharedAccess_ ((c lib!types.HeapSharedAccess.)) Bool ((_ is lib!types.HeapSharedAccess./HeapSharedAccess) c))
(assert (forall ((x lib!types.HeapSharedAccess.)) (! (=> (is-lib!types.HeapSharedAccess./HeapSharedAccess_ x) (height_lt (height (Poly%vstd!raw_ptr.PointsTo<lib!types.Heap.>. (lib!types.HeapSharedAccess./HeapSharedAccess/points_to x))) (height (Poly%lib!types.HeapSharedAccess. x)))) :pattern ((height (Poly%vstd!raw_ptr.PointsTo<lib!types.Heap.>. (lib!types.HeapSharedAccess./HeapSharedAccess/points_to x)))))))
(assert (forall ((x lib!types.SegmentsTld.)) (! (= x (%Poly%lib!types.SegmentsTld. (Poly%lib!types.SegmentsTld. x))) :pattern ((Poly%lib!types.SegmentsTld. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.SegmentsTld.) (= x (Poly%lib!types.SegmentsTld. (%Poly%lib!types.SegmentsTld. x)))) :pattern ((has_type x TYPE%lib!types.SegmentsTld.)))))
(assert (forall ((_span_queue_headers! %%Function%%) (_count! Int) (_peak_count! Int) (_current_size! Int) (_peak_size! Int)) (! (=> (and (has_type (Poly%array%. _span_queue_headers!) (ARRAY $ TYPE%lib!types.SpanQueueHeader. $ (CONST_INT 32))) (uInv SZ _count!) (uInv SZ _peak_count!) (uInv SZ _current_size!) (uInv SZ _peak_size!)) (has_type (Poly%lib!types.SegmentsTld. (lib!types.SegmentsTld./SegmentsTld _span_queue_headers! _count! _peak_count! _current_size! _peak_size!)) TYPE%lib!types.SegmentsTld.)) :pattern ((has_type (Poly%lib!types.SegmentsTld. (lib!types.SegmentsTld./SegmentsTld _span_queue_headers! _count! _peak_count! _current_size! _peak_size!)) TYPE%lib!types.SegmentsTld.)))))
(assert (forall ((x lib!types.SegmentsTld.)) (! (= (lib!types.SegmentsTld./SegmentsTld/span_queue_headers x) (lib!types.SegmentsTld./SegmentsTld/?span_queue_headers x)) :pattern ((lib!types.SegmentsTld./SegmentsTld/span_queue_headers x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.SegmentsTld.) (has_type (Poly%array%. (lib!types.SegmentsTld./SegmentsTld/span_queue_headers (%Poly%lib!types.SegmentsTld. x))) (ARRAY $ TYPE%lib!types.SpanQueueHeader. $ (CONST_INT 32)))) :pattern ((lib!types.SegmentsTld./SegmentsTld/span_queue_headers (%Poly%lib!types.SegmentsTld. x)) (has_type x TYPE%lib!types.SegmentsTld.)))))
(assert (forall ((x lib!types.SegmentsTld.)) (! (= (lib!types.SegmentsTld./SegmentsTld/count x) (lib!types.SegmentsTld./SegmentsTld/?count x)) :pattern ((lib!types.SegmentsTld./SegmentsTld/count x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.SegmentsTld.) (uInv SZ (lib!types.SegmentsTld./SegmentsTld/count (%Poly%lib!types.SegmentsTld. x)))) :pattern ((lib!types.SegmentsTld./SegmentsTld/count (%Poly%lib!types.SegmentsTld. x)) (has_type x TYPE%lib!types.SegmentsTld.)))))
(assert (forall ((x lib!types.SegmentsTld.)) (! (= (lib!types.SegmentsTld./SegmentsTld/peak_count x) (lib!types.SegmentsTld./SegmentsTld/?peak_count x)) :pattern ((lib!types.SegmentsTld./SegmentsTld/peak_count x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.SegmentsTld.) (uInv SZ (lib!types.SegmentsTld./SegmentsTld/peak_count (%Poly%lib!types.SegmentsTld. x)))) :pattern ((lib!types.SegmentsTld./SegmentsTld/peak_count (%Poly%lib!types.SegmentsTld. x)) (has_type x TYPE%lib!types.SegmentsTld.)))))
(assert (forall ((x lib!types.SegmentsTld.)) (! (= (lib!types.SegmentsTld./SegmentsTld/current_size x) (lib!types.SegmentsTld./SegmentsTld/?current_size x)) :pattern ((lib!types.SegmentsTld./SegmentsTld/current_size x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.SegmentsTld.) (uInv SZ (lib!types.SegmentsTld./SegmentsTld/current_size (%Poly%lib!types.SegmentsTld. x)))) :pattern ((lib!types.SegmentsTld./SegmentsTld/current_size (%Poly%lib!types.SegmentsTld. x)) (has_type x TYPE%lib!types.SegmentsTld.)))))
(assert (forall ((x lib!types.SegmentsTld.)) (! (= (lib!types.SegmentsTld./SegmentsTld/peak_size x) (lib!types.SegmentsTld./SegmentsTld/?peak_size x)) :pattern ((lib!types.SegmentsTld./SegmentsTld/peak_size x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.SegmentsTld.) (uInv SZ (lib!types.SegmentsTld./SegmentsTld/peak_size (%Poly%lib!types.SegmentsTld. x)))) :pattern ((lib!types.SegmentsTld./SegmentsTld/peak_size (%Poly%lib!types.SegmentsTld. x)) (has_type x TYPE%lib!types.SegmentsTld.)))))
(assert (forall ((x lib!types.SpanQueueHeader.)) (! (= x (%Poly%lib!types.SpanQueueHeader. (Poly%lib!types.SpanQueueHeader. x))) :pattern ((Poly%lib!types.SpanQueueHeader. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.SpanQueueHeader.) (= x (Poly%lib!types.SpanQueueHeader. (%Poly%lib!types.SpanQueueHeader. x)))) :pattern ((has_type x TYPE%lib!types.SpanQueueHeader.)))))
(assert (forall ((x lib!types.SpanQueueHeader.)) (! (= (lib!types.SpanQueueHeader./SpanQueueHeader/first x) (lib!types.SpanQueueHeader./SpanQueueHeader/?first x)) :pattern ((lib!types.SpanQueueHeader./SpanQueueHeader/first x)))))
(assert (forall ((x lib!types.SpanQueueHeader.)) (! (= (lib!types.SpanQueueHeader./SpanQueueHeader/last x) (lib!types.SpanQueueHeader./SpanQueueHeader/?last x)) :pattern ((lib!types.SpanQueueHeader./SpanQueueHeader/last x)))))
(assert (forall ((x lib!types.SpanQueueHeader.)) (! (has_type (Poly%lib!types.SpanQueueHeader. x) TYPE%lib!types.SpanQueueHeader.) :pattern ((has_type (Poly%lib!types.SpanQueueHeader. x) TYPE%lib!types.SpanQueueHeader.)))))
(assert (forall ((x lib!types.Tld.)) (! (= x (%Poly%lib!types.Tld. (Poly%lib!types.Tld. x))) :pattern ((Poly%lib!types.Tld. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.Tld.) (= x (Poly%lib!types.Tld. (%Poly%lib!types.Tld. x)))) :pattern ((has_type x TYPE%lib!types.Tld.)))))
(assert (forall ((_heap_backing! ptr_mut%<lib!types.Heap.>.) (_segments! lib!types.SegmentsTld.)) (! (=> (has_type (Poly%lib!types.SegmentsTld. _segments!) TYPE%lib!types.SegmentsTld.) (has_type (Poly%lib!types.Tld. (lib!types.Tld./Tld _heap_backing! _segments!)) TYPE%lib!types.Tld.)) :pattern ((has_type (Poly%lib!types.Tld. (lib!types.Tld./Tld _heap_backing! _segments!)) TYPE%lib!types.Tld.)))))
(assert (forall ((x lib!types.Tld.)) (! (= (lib!types.Tld./Tld/heap_backing x) (lib!types.Tld./Tld/?heap_backing x)) :pattern ((lib!types.Tld./Tld/heap_backing x)))))
(assert (forall ((x lib!types.Tld.)) (! (= (lib!types.Tld./Tld/segments x) (lib!types.Tld./Tld/?segments x)) :pattern ((lib!types.Tld./Tld/segments x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.Tld.) (has_type (Poly%lib!types.SegmentsTld. (lib!types.Tld./Tld/segments (%Poly%lib!types.Tld. x))) TYPE%lib!types.SegmentsTld.)) :pattern ((lib!types.Tld./Tld/segments (%Poly%lib!types.Tld. x)) (has_type x TYPE%lib!types.Tld.)))))
(define-fun is-lib!types.Tld./Tld_ ((c lib!types.Tld.)) Bool ((_ is lib!types.Tld./Tld) c))
(assert (forall ((x lib!types.Tld.)) (! (=> (is-lib!types.Tld./Tld_ x) (height_lt (height (Poly%lib!types.SegmentsTld. (lib!types.Tld./Tld/segments x))) (height (Poly%lib!types.Tld. x)))) :pattern ((height (Poly%lib!types.SegmentsTld. (lib!types.Tld./Tld/segments x)))))))
(assert (forall ((x lib!types.TldPtr.)) (! (= x (%Poly%lib!types.TldPtr. (Poly%lib!types.TldPtr. x))) :pattern ((Poly%lib!types.TldPtr. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.TldPtr.) (= x (Poly%lib!types.TldPtr. (%Poly%lib!types.TldPtr. x)))) :pattern ((has_type x TYPE%lib!types.TldPtr.)))))
(assert (forall ((_tld_ptr! ptr_mut%<lib!types.Tld.>.) (_tld_id! lib!tokens.TldId.)) (! (=> (has_type (Poly%lib!tokens.TldId. _tld_id!) TYPE%lib!tokens.TldId.) (has_type (Poly%lib!types.TldPtr. (lib!types.TldPtr./TldPtr _tld_ptr! _tld_id!)) TYPE%lib!types.TldPtr.)) :pattern ((has_type (Poly%lib!types.TldPtr. (lib!types.TldPtr./TldPtr _tld_ptr! _tld_id!)) TYPE%lib!types.TldPtr.)))))
(assert (forall ((x lib!types.TldPtr.)) (! (= (lib!types.TldPtr./TldPtr/tld_ptr x) (lib!types.TldPtr./TldPtr/?tld_ptr x)) :pattern ((lib!types.TldPtr./TldPtr/tld_ptr x)))))
(assert (forall ((x lib!types.TldPtr.)) (! (= (lib!types.TldPtr./TldPtr/tld_id x) (lib!types.TldPtr./TldPtr/?tld_id x)) :pattern ((lib!types.TldPtr./TldPtr/tld_id x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!types.TldPtr.) (has_type (Poly%lib!tokens.TldId. (lib!types.TldPtr./TldPtr/tld_id (%Poly%lib!types.TldPtr. x))) TYPE%lib!tokens.TldId.)) :pattern ((lib!types.TldPtr./TldPtr/tld_id (%Poly%lib!types.TldPtr. x)) (has_type x TYPE%lib!types.TldPtr.)))))
(assert (forall ((x lib!linked_list.Node.)) (! (= x (%Poly%lib!linked_list.Node. (Poly%lib!linked_list.Node. x))) :pattern ((Poly%lib!linked_list.Node. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!linked_list.Node.) (= x (Poly%lib!linked_list.Node. (%Poly%lib!linked_list.Node. x)))) :pattern ((has_type x TYPE%lib!linked_list.Node.)))))
(assert (forall ((x lib!linked_list.Node.)) (! (= (lib!linked_list.Node./Node/ptr x) (lib!linked_list.Node./Node/?ptr x)) :pattern ((lib!linked_list.Node./Node/ptr x)))))
(assert (forall ((x lib!linked_list.Node.)) (! (has_type (Poly%lib!linked_list.Node. x) TYPE%lib!linked_list.Node.) :pattern ((has_type (Poly%lib!linked_list.Node. x) TYPE%lib!linked_list.Node.)))))
(assert (forall ((x lib!linked_list.ThreadLLSimple.)) (! (= x (%Poly%lib!linked_list.ThreadLLSimple. (Poly%lib!linked_list.ThreadLLSimple. x))) :pattern ((Poly%lib!linked_list.ThreadLLSimple. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!linked_list.ThreadLLSimple.) (= x (Poly%lib!linked_list.ThreadLLSimple. (%Poly%lib!linked_list.ThreadLLSimple. x)))) :pattern ((has_type x TYPE%lib!linked_list.ThreadLLSimple.)))))
(assert (forall ((_instance! lib!tokens.Mim.Instance.) (_heap_id! lib!tokens.HeapId.) (_atomic! vstd!atomic_ghost.AtomicPtr.)) (! (=> (and (has_type (Poly%lib!tokens.HeapId. _heap_id!) TYPE%lib!tokens.HeapId.) (has_type (Poly%vstd!atomic_ghost.AtomicPtr. _atomic!) (TYPE%vstd!atomic_ghost.AtomicPtr. $ TYPE%lib!linked_list.Node. $ (TYPE%tuple%2. (GHOST $) TYPE%lib!tokens.Mim.Instance. (GHOST $) TYPE%lib!tokens.HeapId.) $ TYPE%lib!linked_list.LL. $ TYPE%lib!linked_list.InvariantPredicate_auto_ThreadLLSimple_atomic.))) (has_type (Poly%lib!linked_list.ThreadLLSimple. (lib!linked_list.ThreadLLSimple./ThreadLLSimple _instance! _heap_id! _atomic!)) TYPE%lib!linked_list.ThreadLLSimple.)) :pattern ((has_type (Poly%lib!linked_list.ThreadLLSimple. (lib!linked_list.ThreadLLSimple./ThreadLLSimple _instance! _heap_id! _atomic!)) TYPE%lib!linked_list.ThreadLLSimple.)))))
(assert (forall ((x lib!linked_list.ThreadLLSimple.)) (! (= (lib!linked_list.ThreadLLSimple./ThreadLLSimple/instance x) (lib!linked_list.ThreadLLSimple./ThreadLLSimple/?instance x)) :pattern ((lib!linked_list.ThreadLLSimple./ThreadLLSimple/instance x)))))
(assert (forall ((x lib!linked_list.ThreadLLSimple.)) (! (= (lib!linked_list.ThreadLLSimple./ThreadLLSimple/heap_id x) (lib!linked_list.ThreadLLSimple./ThreadLLSimple/?heap_id x)) :pattern ((lib!linked_list.ThreadLLSimple./ThreadLLSimple/heap_id x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!linked_list.ThreadLLSimple.) (has_type (Poly%lib!tokens.HeapId. (lib!linked_list.ThreadLLSimple./ThreadLLSimple/heap_id (%Poly%lib!linked_list.ThreadLLSimple. x))) TYPE%lib!tokens.HeapId.)) :pattern ((lib!linked_list.ThreadLLSimple./ThreadLLSimple/heap_id (%Poly%lib!linked_list.ThreadLLSimple. x)) (has_type x TYPE%lib!linked_list.ThreadLLSimple.)))))
(assert (forall ((x lib!linked_list.ThreadLLSimple.)) (! (= (lib!linked_list.ThreadLLSimple./ThreadLLSimple/atomic x) (lib!linked_list.ThreadLLSimple./ThreadLLSimple/?atomic x)) :pattern ((lib!linked_list.ThreadLLSimple./ThreadLLSimple/atomic x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!linked_list.ThreadLLSimple.) (has_type (Poly%vstd!atomic_ghost.AtomicPtr. (lib!linked_list.ThreadLLSimple./ThreadLLSimple/atomic (%Poly%lib!linked_list.ThreadLLSimple. x))) (TYPE%vstd!atomic_ghost.AtomicPtr. $ TYPE%lib!linked_list.Node. $ (TYPE%tuple%2. (GHOST $) TYPE%lib!tokens.Mim.Instance. (GHOST $) TYPE%lib!tokens.HeapId.) $ TYPE%lib!linked_list.LL. $ TYPE%lib!linked_list.InvariantPredicate_auto_ThreadLLSimple_atomic.))) :pattern ((lib!linked_list.ThreadLLSimple./ThreadLLSimple/atomic (%Poly%lib!linked_list.ThreadLLSimple. x)) (has_type x TYPE%lib!linked_list.ThreadLLSimple.)))))
(define-fun is-lib!linked_list.ThreadLLSimple./ThreadLLSimple_ ((c lib!linked_list.ThreadLLSimple.)) Bool ((_ is lib!linked_list.ThreadLLSimple./ThreadLLSimple) c))
(assert (forall ((x lib!linked_list.ThreadLLSimple.)) (! (=> (is-lib!linked_list.ThreadLLSimple./ThreadLLSimple_ x) (height_lt (height (Poly%lib!tokens.Mim.Instance. (lib!linked_list.ThreadLLSimple./ThreadLLSimple/instance x))) (height (Poly%lib!linked_list.ThreadLLSimple. x)))) :pattern ((height (Poly%lib!tokens.Mim.Instance. (lib!linked_list.ThreadLLSimple./ThreadLLSimple/instance x)))))))
(assert (forall ((x lib!linked_list.ThreadLLSimple.)) (! (=> (is-lib!linked_list.ThreadLLSimple./ThreadLLSimple_ x) (height_lt (height (Poly%vstd!atomic_ghost.AtomicPtr. (lib!linked_list.ThreadLLSimple./ThreadLLSimple/atomic x))) (height (Poly%lib!linked_list.ThreadLLSimple. x)))) :pattern ((height (Poly%vstd!atomic_ghost.AtomicPtr. (lib!linked_list.ThreadLLSimple./ThreadLLSimple/atomic x)))))))
(assert (forall ((x lib!linked_list.InvariantPredicate_auto_ThreadLLSimple_atomic.)) (! (= x (%Poly%lib!linked_list.InvariantPredicate_auto_ThreadLLSimple_atomic. (Poly%lib!linked_list.InvariantPredicate_auto_ThreadLLSimple_atomic. x))) :pattern ((Poly%lib!linked_list.InvariantPredicate_auto_ThreadLLSimple_atomic. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!linked_list.InvariantPredicate_auto_ThreadLLSimple_atomic.) (= x (Poly%lib!linked_list.InvariantPredicate_auto_ThreadLLSimple_atomic. (%Poly%lib!linked_list.InvariantPredicate_auto_ThreadLLSimple_atomic. x)))) :pattern ((has_type x TYPE%lib!linked_list.InvariantPredicate_auto_ThreadLLSimple_atomic.)))))
(assert (forall ((x lib!linked_list.InvariantPredicate_auto_ThreadLLSimple_atomic.)) (! (has_type (Poly%lib!linked_list.InvariantPredicate_auto_ThreadLLSimple_atomic. x) TYPE%lib!linked_list.InvariantPredicate_auto_ThreadLLSimple_atomic.) :pattern ((has_type (Poly%lib!linked_list.InvariantPredicate_auto_ThreadLLSimple_atomic. x) TYPE%lib!linked_list.InvariantPredicate_auto_ThreadLLSimple_atomic.)))))
(assert (forall ((x lib!linked_list.ThreadLLWithDelayBits.)) (! (= x (%Poly%lib!linked_list.ThreadLLWithDelayBits. (Poly%lib!linked_list.ThreadLLWithDelayBits. x))) :pattern ((Poly%lib!linked_list.ThreadLLWithDelayBits. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!linked_list.ThreadLLWithDelayBits.) (= x (Poly%lib!linked_list.ThreadLLWithDelayBits. (%Poly%lib!linked_list.ThreadLLWithDelayBits. x)))) :pattern ((has_type x TYPE%lib!linked_list.ThreadLLWithDelayBits.)))))
(assert (forall ((_instance! lib!tokens.Mim.Instance.) (_atomic! vstd!atomic_ghost.AtomicPtr.) (_emp! lib!linked_list.StuffAgree.x.) (_emp_inst! lib!linked_list.StuffAgree.Instance.)) (! (=> (has_type (Poly%vstd!atomic_ghost.AtomicPtr. _atomic!) (TYPE%vstd!atomic_ghost.AtomicPtr. $ TYPE%lib!linked_list.Node. $ (TYPE%tuple%2. (TRACKED $) TYPE%lib!tokens.Mim.Instance. (TRACKED $) TYPE%lib!linked_list.StuffAgree.Instance.) $ (TYPE%tuple%2. $ TYPE%lib!linked_list.StuffAgree.y. $ (TYPE%core!option.Option. $ (TYPE%tuple%2. $ TYPE%lib!tokens.Mim.delay. $ TYPE%lib!linked_list.LL.))) $ TYPE%lib!linked_list.InvariantPredicate_auto_ThreadLLWithDelayBits_atomic.)) (has_type (Poly%lib!linked_list.ThreadLLWithDelayBits. (lib!linked_list.ThreadLLWithDelayBits./ThreadLLWithDelayBits _instance! _atomic! _emp! _emp_inst!)) TYPE%lib!linked_list.ThreadLLWithDelayBits.)) :pattern ((has_type (Poly%lib!linked_list.ThreadLLWithDelayBits. (lib!linked_list.ThreadLLWithDelayBits./ThreadLLWithDelayBits _instance! _atomic! _emp! _emp_inst!)) TYPE%lib!linked_list.ThreadLLWithDelayBits.)))))
(assert (forall ((x lib!linked_list.ThreadLLWithDelayBits.)) (! (= (lib!linked_list.ThreadLLWithDelayBits./ThreadLLWithDelayBits/instance x) (lib!linked_list.ThreadLLWithDelayBits./ThreadLLWithDelayBits/?instance x)) :pattern ((lib!linked_list.ThreadLLWithDelayBits./ThreadLLWithDelayBits/instance x)))))
(assert (forall ((x lib!linked_list.ThreadLLWithDelayBits.)) (! (= (lib!linked_list.ThreadLLWithDelayBits./ThreadLLWithDelayBits/atomic x) (lib!linked_list.ThreadLLWithDelayBits./ThreadLLWithDelayBits/?atomic x)) :pattern ((lib!linked_list.ThreadLLWithDelayBits./ThreadLLWithDelayBits/atomic x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!linked_list.ThreadLLWithDelayBits.) (has_type (Poly%vstd!atomic_ghost.AtomicPtr. (lib!linked_list.ThreadLLWithDelayBits./ThreadLLWithDelayBits/atomic (%Poly%lib!linked_list.ThreadLLWithDelayBits. x))) (TYPE%vstd!atomic_ghost.AtomicPtr. $ TYPE%lib!linked_list.Node. $ (TYPE%tuple%2. (TRACKED $) TYPE%lib!tokens.Mim.Instance. (TRACKED $) TYPE%lib!linked_list.StuffAgree.Instance.) $ (TYPE%tuple%2. $ TYPE%lib!linked_list.StuffAgree.y. $ (TYPE%core!option.Option. $ (TYPE%tuple%2. $ TYPE%lib!tokens.Mim.delay. $ TYPE%lib!linked_list.LL.))) $ TYPE%lib!linked_list.InvariantPredicate_auto_ThreadLLWithDelayBits_atomic.))) :pattern ((lib!linked_list.ThreadLLWithDelayBits./ThreadLLWithDelayBits/atomic (%Poly%lib!linked_list.ThreadLLWithDelayBits. x)) (has_type x TYPE%lib!linked_list.ThreadLLWithDelayBits.)))))
(assert (forall ((x lib!linked_list.ThreadLLWithDelayBits.)) (! (= (lib!linked_list.ThreadLLWithDelayBits./ThreadLLWithDelayBits/emp x) (lib!linked_list.ThreadLLWithDelayBits./ThreadLLWithDelayBits/?emp x)) :pattern ((lib!linked_list.ThreadLLWithDelayBits./ThreadLLWithDelayBits/emp x)))))
(assert (forall ((x lib!linked_list.ThreadLLWithDelayBits.)) (! (= (lib!linked_list.ThreadLLWithDelayBits./ThreadLLWithDelayBits/emp_inst x) (lib!linked_list.ThreadLLWithDelayBits./ThreadLLWithDelayBits/?emp_inst x)) :pattern ((lib!linked_list.ThreadLLWithDelayBits./ThreadLLWithDelayBits/emp_inst x)))))
(define-fun is-lib!linked_list.ThreadLLWithDelayBits./ThreadLLWithDelayBits_ ((c lib!linked_list.ThreadLLWithDelayBits.)) Bool ((_ is lib!linked_list.ThreadLLWithDelayBits./ThreadLLWithDelayBits) c))
(assert (forall ((x lib!linked_list.ThreadLLWithDelayBits.)) (! (=> (is-lib!linked_list.ThreadLLWithDelayBits./ThreadLLWithDelayBits_ x) (height_lt (height (Poly%lib!tokens.Mim.Instance. (lib!linked_list.ThreadLLWithDelayBits./ThreadLLWithDelayBits/instance x))) (height (Poly%lib!linked_list.ThreadLLWithDelayBits. x)))) :pattern ((height (Poly%lib!tokens.Mim.Instance. (lib!linked_list.ThreadLLWithDelayBits./ThreadLLWithDelayBits/instance x)))))))
(assert (forall ((x lib!linked_list.ThreadLLWithDelayBits.)) (! (=> (is-lib!linked_list.ThreadLLWithDelayBits./ThreadLLWithDelayBits_ x) (height_lt (height (Poly%vstd!atomic_ghost.AtomicPtr. (lib!linked_list.ThreadLLWithDelayBits./ThreadLLWithDelayBits/atomic x))) (height (Poly%lib!linked_list.ThreadLLWithDelayBits. x)))) :pattern ((height (Poly%vstd!atomic_ghost.AtomicPtr. (lib!linked_list.ThreadLLWithDelayBits./ThreadLLWithDelayBits/atomic x)))))))
(assert (forall ((x lib!linked_list.InvariantPredicate_auto_ThreadLLWithDelayBits_atomic.)) (! (= x (%Poly%lib!linked_list.InvariantPredicate_auto_ThreadLLWithDelayBits_atomic. (Poly%lib!linked_list.InvariantPredicate_auto_ThreadLLWithDelayBits_atomic. x))) :pattern ((Poly%lib!linked_list.InvariantPredicate_auto_ThreadLLWithDelayBits_atomic. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!linked_list.InvariantPredicate_auto_ThreadLLWithDelayBits_atomic.) (= x (Poly%lib!linked_list.InvariantPredicate_auto_ThreadLLWithDelayBits_atomic. (%Poly%lib!linked_list.InvariantPredicate_auto_ThreadLLWithDelayBits_atomic. x)))) :pattern ((has_type x TYPE%lib!linked_list.InvariantPredicate_auto_ThreadLLWithDelayBits_atomic.)))))
(assert (forall ((x lib!linked_list.InvariantPredicate_auto_ThreadLLWithDelayBits_atomic.)) (! (has_type (Poly%lib!linked_list.InvariantPredicate_auto_ThreadLLWithDelayBits_atomic. x) TYPE%lib!linked_list.InvariantPredicate_auto_ThreadLLWithDelayBits_atomic.) :pattern ((has_type (Poly%lib!linked_list.InvariantPredicate_auto_ThreadLLWithDelayBits_atomic. x) TYPE%lib!linked_list.InvariantPredicate_auto_ThreadLLWithDelayBits_atomic.)))))
(assert (forall ((x tuple%0.)) (! (= x (%Poly%tuple%0. (Poly%tuple%0. x))) :pattern ((Poly%tuple%0. x)))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%tuple%0.) (= x (Poly%tuple%0. (%Poly%tuple%0. x)))) :pattern ((has_type x TYPE%tuple%0.)))))
(assert (forall ((x tuple%0.)) (! (has_type (Poly%tuple%0. x) TYPE%tuple%0.) :pattern ((has_type (Poly%tuple%0. x) TYPE%tuple%0.)))))
(assert (forall ((x tuple%2.)) (! (= x (%Poly%tuple%2. (Poly%tuple%2. x))) :pattern ((Poly%tuple%2. x)))))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (x Poly)) (! (=> (has_type x (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&)) (= x (Poly%tuple%2. (%Poly%tuple%2. x)))) :pattern ((has_type x (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&))))))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (_0! Poly) (_1! Poly)) (! (=> (and (has_type _0! T%0&) (has_type _1! T%1&)) (has_type (Poly%tuple%2. (tuple%2./tuple%2 _0! _1!)) (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&))) :pattern ((has_type (Poly%tuple%2. (tuple%2./tuple%2 _0! _1!)) (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&))))))
(assert (forall ((x tuple%2.)) (! (= (tuple%2./tuple%2/0 x) (tuple%2./tuple%2/?0 x)) :pattern ((tuple%2./tuple%2/0 x)))))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (x Poly)) (! (=> (has_type x (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&)) (has_type (tuple%2./tuple%2/0 (%Poly%tuple%2. x)) T%0&)) :pattern ((tuple%2./tuple%2/0 (%Poly%tuple%2. x)) (has_type x (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&))))))
(assert (forall ((x tuple%2.)) (! (= (tuple%2./tuple%2/1 x) (tuple%2./tuple%2/?1 x)) :pattern ((tuple%2./tuple%2/1 x)))))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (x Poly)) (! (=> (has_type x (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&)) (has_type (tuple%2./tuple%2/1 (%Poly%tuple%2. x)) T%1&)) :pattern ((tuple%2./tuple%2/1 (%Poly%tuple%2. x)) (has_type x (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&))))))
(define-fun is-tuple%2./tuple%2_ ((c tuple%2.)) Bool ((_ is tuple%2./tuple%2) c))
(assert (forall ((x tuple%2.)) (! (=> (is-tuple%2./tuple%2_ x) (height_lt (height (tuple%2./tuple%2/0 x)) (height (Poly%tuple%2. x)))) :pattern ((height (tuple%2./tuple%2/0 x))))))
(assert (forall ((x tuple%2.)) (! (=> (is-tuple%2./tuple%2_ x) (height_lt (height (tuple%2./tuple%2/1 x)) (height (Poly%tuple%2. x)))) :pattern ((height (tuple%2./tuple%2/1 x))))))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (deep Bool) (x Poly) (y Poly)) (! (=> (and (has_type x (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&)) (has_type y (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&)) (ext_eq deep T%0& (tuple%2./tuple%2/0 (%Poly%tuple%2. x)) (tuple%2./tuple%2/0 (%Poly%tuple%2. y))) (ext_eq deep T%1& (tuple%2./tuple%2/1 (%Poly%tuple%2. x)) (tuple%2./tuple%2/1 (%Poly%tuple%2. y)))) (ext_eq deep (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&) x y)) :pattern ((ext_eq deep (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&) x y)))))
(assert (forall ((x tuple%4.)) (! (= x (%Poly%tuple%4. (Poly%tuple%4. x))) :pattern ((Poly%tuple%4. x)))))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (T%2&. Dcr) (T%2& Type) (T%3&. Dcr) (T%3& Type) (x Poly)) (! (=> (has_type x (TYPE%tuple%4. T%0&. T%0& T%1&. T%1& T%2&. T%2& T%3&. T%3&)) (= x (Poly%tuple%4. (%Poly%tuple%4. x)))) :pattern ((has_type x (TYPE%tuple%4. T%0&. T%0& T%1&. T%1& T%2&. T%2& T%3&. T%3&))))))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (T%2&. Dcr) (T%2& Type) (T%3&. Dcr) (T%3& Type) (_0! Poly) (_1! Poly) (_2! Poly) (_3! Poly)) (! (=> (and (has_type _0! T%0&) (has_type _1! T%1&) (has_type _2! T%2&) (has_type _3! T%3&)) (has_type (Poly%tuple%4. (tuple%4./tuple%4 _0! _1! _2! _3!)) (TYPE%tuple%4. T%0&. T%0& T%1&. T%1& T%2&. T%2& T%3&. T%3&))) :pattern ((has_type (Poly%tuple%4. (tuple%4./tuple%4 _0! _1! _2! _3!)) (TYPE%tuple%4. T%0&. T%0& T%1&. T%1& T%2&. T%2& T%3&. T%3&))))))
(assert (forall ((x tuple%4.)) (! (= (tuple%4./tuple%4/0 x) (tuple%4./tuple%4/?0 x)) :pattern ((tuple%4./tuple%4/0 x)))))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (T%2&. Dcr) (T%2& Type) (T%3&. Dcr) (T%3& Type) (x Poly)) (! (=> (has_type x (TYPE%tuple%4. T%0&. T%0& T%1&. T%1& T%2&. T%2& T%3&. T%3&)) (has_type (tuple%4./tuple%4/0 (%Poly%tuple%4. x)) T%0&)) :pattern ((tuple%4./tuple%4/0 (%Poly%tuple%4. x)) (has_type x (TYPE%tuple%4. T%0&. T%0& T%1&. T%1& T%2&. T%2& T%3&. T%3&))))))
(assert (forall ((x tuple%4.)) (! (= (tuple%4./tuple%4/1 x) (tuple%4./tuple%4/?1 x)) :pattern ((tuple%4./tuple%4/1 x)))))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (T%2&. Dcr) (T%2& Type) (T%3&. Dcr) (T%3& Type) (x Poly)) (! (=> (has_type x (TYPE%tuple%4. T%0&. T%0& T%1&. T%1& T%2&. T%2& T%3&. T%3&)) (has_type (tuple%4./tuple%4/1 (%Poly%tuple%4. x)) T%1&)) :pattern ((tuple%4./tuple%4/1 (%Poly%tuple%4. x)) (has_type x (TYPE%tuple%4. T%0&. T%0& T%1&. T%1& T%2&. T%2& T%3&. T%3&))))))
(assert (forall ((x tuple%4.)) (! (= (tuple%4./tuple%4/2 x) (tuple%4./tuple%4/?2 x)) :pattern ((tuple%4./tuple%4/2 x)))))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (T%2&. Dcr) (T%2& Type) (T%3&. Dcr) (T%3& Type) (x Poly)) (! (=> (has_type x (TYPE%tuple%4. T%0&. T%0& T%1&. T%1& T%2&. T%2& T%3&. T%3&)) (has_type (tuple%4./tuple%4/2 (%Poly%tuple%4. x)) T%2&)) :pattern ((tuple%4./tuple%4/2 (%Poly%tuple%4. x)) (has_type x (TYPE%tuple%4. T%0&. T%0& T%1&. T%1& T%2&. T%2& T%3&. T%3&))))))
(assert (forall ((x tuple%4.)) (! (= (tuple%4./tuple%4/3 x) (tuple%4./tuple%4/?3 x)) :pattern ((tuple%4./tuple%4/3 x)))))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (T%2&. Dcr) (T%2& Type) (T%3&. Dcr) (T%3& Type) (x Poly)) (! (=> (has_type x (TYPE%tuple%4. T%0&. T%0& T%1&. T%1& T%2&. T%2& T%3&. T%3&)) (has_type (tuple%4./tuple%4/3 (%Poly%tuple%4. x)) T%3&)) :pattern ((tuple%4./tuple%4/3 (%Poly%tuple%4. x)) (has_type x (TYPE%tuple%4. T%0&. T%0& T%1&. T%1& T%2&. T%2& T%3&. T%3&))))))
(define-fun is-tuple%4./tuple%4_ ((c tuple%4.)) Bool ((_ is tuple%4./tuple%4) c))
(assert (forall ((x tuple%4.)) (! (=> (is-tuple%4./tuple%4_ x) (height_lt (height (tuple%4./tuple%4/0 x)) (height (Poly%tuple%4. x)))) :pattern ((height (tuple%4./tuple%4/0 x))))))
(assert (forall ((x tuple%4.)) (! (=> (is-tuple%4./tuple%4_ x) (height_lt (height (tuple%4./tuple%4/1 x)) (height (Poly%tuple%4. x)))) :pattern ((height (tuple%4./tuple%4/1 x))))))
(assert (forall ((x tuple%4.)) (! (=> (is-tuple%4./tuple%4_ x) (height_lt (height (tuple%4./tuple%4/2 x)) (height (Poly%tuple%4. x)))) :pattern ((height (tuple%4./tuple%4/2 x))))))
(assert (forall ((x tuple%4.)) (! (=> (is-tuple%4./tuple%4_ x) (height_lt (height (tuple%4./tuple%4/3 x)) (height (Poly%tuple%4. x)))) :pattern ((height (tuple%4./tuple%4/3 x))))))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (T%2&. Dcr) (T%2& Type) (T%3&. Dcr) (T%3& Type) (deep Bool) (x Poly) (y Poly)) (! (=> (and (has_type x (TYPE%tuple%4. T%0&. T%0& T%1&. T%1& T%2&. T%2& T%3&. T%3&)) (has_type y (TYPE%tuple%4. T%0&. T%0& T%1&. T%1& T%2&. T%2& T%3&. T%3&)) (ext_eq deep T%0& (tuple%4./tuple%4/0 (%Poly%tuple%4. x)) (tuple%4./tuple%4/0 (%Poly%tuple%4. y))) (ext_eq deep T%1& (tuple%4./tuple%4/1 (%Poly%tuple%4. x)) (tuple%4./tuple%4/1 (%Poly%tuple%4. y))) (ext_eq deep T%2& (tuple%4./tuple%4/2 (%Poly%tuple%4. x)) (tuple%4./tuple%4/2 (%Poly%tuple%4. y))) (ext_eq deep T%3& (tuple%4./tuple%4/3 (%Poly%tuple%4. x)) (tuple%4./tuple%4/3 (%Poly%tuple%4. y)))) (ext_eq deep (TYPE%tuple%4. T%0&. T%0& T%1&. T%1& T%2&. T%2& T%3&. T%3&) x y)) :pattern ((ext_eq deep (TYPE%tuple%4. T%0&. T%0& T%1&. T%1& T%2&. T%2& T%3&. T%3&) x y)))))
(declare-fun array_new (Dcr Type Int %%Function%%) Poly)
(declare-fun array_index (Dcr Type Dcr Type %%Function%% Poly) Poly)
(assert (forall ((Tdcr Dcr) (T Type) (N Int) (Fn %%Function%%)) (! (= (array_new Tdcr T N Fn) (Poly%array%. Fn)) :pattern ((array_new Tdcr T N Fn)))))
(declare-fun %%apply%%1 (%%Function%% Int) Poly)
(assert (forall ((Tdcr Dcr) (T Type) (N Int) (Fn %%Function%%)) (! (=> (forall ((i Int)) (! (=> (and (<= 0 i) (< i N)) (has_type (%%apply%%1 Fn i) T)) :pattern ((has_type (%%apply%%1 Fn i) T)))) (has_type (array_new Tdcr T N Fn) (ARRAY Tdcr T $ (CONST_INT N)))) :pattern ((array_new Tdcr T N Fn)))))
(assert (forall ((Tdcr Dcr) (T Type) (Ndcr Dcr) (N Type) (Fn %%Function%%) (i Poly)) (! (=> (and (has_type (Poly%array%. Fn) (ARRAY Tdcr T Ndcr N)) (has_type i INT)) (has_type (array_index Tdcr T $ N Fn i) T)) :pattern ((array_index Tdcr T $ N Fn i) (has_type (Poly%array%. Fn) (ARRAY Tdcr T Ndcr N))))))
(assert (forall ((Tdcr Dcr) (T Type) (N Int) (Fn %%Function%%) (i Int)) (! (= (array_index Tdcr T $ (CONST_INT N) Fn (I i)) (%%apply%%1 Fn i)) :pattern ((array_new Tdcr T N Fn) (%%apply%%1 Fn i)))))
(set-info :comment ";; Traits")
(declare-fun tr_bound%vstd!array.ArrayAdditionalSpecFns. (Dcr Type Dcr Type) Bool)
(declare-fun tr_bound%vstd!view.View. (Dcr Type) Bool)
(assert (forall ((Self%&. Dcr) (Self%& Type) (T&. Dcr) (T& Type)) (! (=> (tr_bound%vstd!array.ArrayAdditionalSpecFns. Self%&. Self%& T&. T&) (and (tr_bound%vstd!view.View. Self%&. Self%&) (and (= $ (proj%%vstd!view.View./V Self%&. Self%&)) (= (TYPE%vstd!seq.Seq. T&. T&) (proj%vstd!view.View./V Self%&. Self%&))))) :pattern ((tr_bound%vstd!array.ArrayAdditionalSpecFns. Self%&. Self%& T&. T&)))))
(assert (forall ((Self%&. Dcr) (Self%& Type)) (! true :pattern ((tr_bound%vstd!view.View. Self%&. Self%&)))))
(set-info :comment ";; Associated-Type-Impls")
(assert (forall ((T&. Dcr) (T& Type) (N&. Dcr) (N& Type)) (! (= (proj%%vstd!view.View./V $ (ARRAY T&. T& N&. N&)) $) :pattern ((proj%%vstd!view.View./V $ (ARRAY T&. T& N&. N&))))))
(assert (forall ((T&. Dcr) (T& Type) (N&. Dcr) (N& Type)) (! (= (proj%vstd!view.View./V $ (ARRAY T&. T& N&. N&)) (TYPE%vstd!seq.Seq. T&. T&)) :pattern ((proj%vstd!view.View./V $ (ARRAY T&. T& N&. N&))))))
(assert (forall ((T&. Dcr) (T& Type)) (! (= (proj%%vstd!view.View./V $ (PTR T&. T&)) $) :pattern ((proj%%vstd!view.View./V $ (PTR T&. T&))))))
(assert (forall ((T&. Dcr) (T& Type)) (! (= (proj%vstd!view.View./V $ (PTR T&. T&)) TYPE%vstd!raw_ptr.PtrData.) :pattern ((proj%vstd!view.View./V $ (PTR T&. T&))))))
(assert (forall ((T&. Dcr) (T& Type)) (! (= (proj%%vstd!view.View./V (CONST_PTR $) (PTR T&. T&)) $) :pattern ((proj%%vstd!view.View./V (CONST_PTR $) (PTR T&. T&))))))
(assert (forall ((T&. Dcr) (T& Type)) (! (= (proj%vstd!view.View./V (CONST_PTR $) (PTR T&. T&)) TYPE%vstd!raw_ptr.PtrData.) :pattern ((proj%vstd!view.View./V (CONST_PTR $) (PTR T&. T&))))))
(assert (forall ((T&. Dcr) (T& Type)) (! (= (proj%%vstd!view.View./V $ (TYPE%vstd!raw_ptr.PointsTo. T&. T&)) $) :pattern ((proj%%vstd!view.View./V $ (TYPE%vstd!raw_ptr.PointsTo. T&. T&))))))
(assert (forall ((T&. Dcr) (T& Type)) (! (= (proj%vstd!view.View./V $ (TYPE%vstd!raw_ptr.PointsTo. T&. T&)) (TYPE%vstd!raw_ptr.PointsToData. T&. T&)) :pattern ((proj%vstd!view.View./V $ (TYPE%vstd!raw_ptr.PointsTo. T&. T&))))))
(assert (forall ((T&. Dcr) (T& Type)) (! (= (proj%%vstd!view.View./V $ (SLICE T&. T&)) $) :pattern ((proj%%vstd!view.View./V $ (SLICE T&. T&))))))
(assert (forall ((T&. Dcr) (T& Type)) (! (= (proj%vstd!view.View./V $ (SLICE T&. T&)) (TYPE%vstd!seq.Seq. T&. T&)) :pattern ((proj%vstd!view.View./V $ (SLICE T&. T&))))))
(assert (forall ((A&. Dcr) (A& Type)) (! (= (proj%%vstd!view.View./V (REF A&.) A&) (proj%%vstd!view.View./V A&. A&)) :pattern ((proj%%vstd!view.View./V (REF A&.) A&)))))
(assert (forall ((A&. Dcr) (A& Type)) (! (= (proj%vstd!view.View./V (REF A&.) A&) (proj%vstd!view.View./V A&. A&)) :pattern ((proj%vstd!view.View./V (REF A&.) A&)))))
(assert (forall ((A&. Dcr) (A& Type)) (! (= (proj%%vstd!view.View./V (BOX $ ALLOCATOR_GLOBAL A&.) A&) (proj%%vstd!view.View./V A&. A&)) :pattern ((proj%%vstd!view.View./V (BOX $ ALLOCATOR_GLOBAL A&.) A&)))))
(assert (forall ((A&. Dcr) (A& Type)) (! (= (proj%vstd!view.View./V (BOX $ ALLOCATOR_GLOBAL A&.) A&) (proj%vstd!view.View./V A&. A&)) :pattern ((proj%vstd!view.View./V (BOX $ ALLOCATOR_GLOBAL A&.) A&)))))
(assert (forall ((A&. Dcr) (A& Type)) (! (= (proj%%vstd!view.View./V (RC $ ALLOCATOR_GLOBAL A&.) A&) (proj%%vstd!view.View./V A&. A&)) :pattern ((proj%%vstd!view.View./V (RC $ ALLOCATOR_GLOBAL A&.) A&)))))
(assert (forall ((A&. Dcr) (A& Type)) (! (= (proj%vstd!view.View./V (RC $ ALLOCATOR_GLOBAL A&.) A&) (proj%vstd!view.View./V A&. A&)) :pattern ((proj%vstd!view.View./V (RC $ ALLOCATOR_GLOBAL A&.) A&)))))
(assert (forall ((A&. Dcr) (A& Type)) (! (= (proj%%vstd!view.View./V (ARC $ ALLOCATOR_GLOBAL A&.) A&) (proj%%vstd!view.View./V A&. A&)) :pattern ((proj%%vstd!view.View./V (ARC $ ALLOCATOR_GLOBAL A&.) A&)))))
(assert (forall ((A&. Dcr) (A& Type)) (! (= (proj%vstd!view.View./V (ARC $ ALLOCATOR_GLOBAL A&.) A&) (proj%vstd!view.View./V A&. A&)) :pattern ((proj%vstd!view.View./V (ARC $ ALLOCATOR_GLOBAL A&.) A&)))))
(assert (= (proj%%vstd!view.View./V $ TYPE%tuple%0.) $))
(assert (= (proj%vstd!view.View./V $ TYPE%tuple%0.) TYPE%tuple%0.))
(assert (= (proj%%vstd!view.View./V $ BOOL) $))
(assert (= (proj%vstd!view.View./V $ BOOL) BOOL))
(assert (= (proj%%vstd!view.View./V $ (UINT 8)) $))
(assert (= (proj%vstd!view.View./V $ (UINT 8)) (UINT 8)))
(assert (= (proj%%vstd!view.View./V $ (UINT 16)) $))
(assert (= (proj%vstd!view.View./V $ (UINT 16)) (UINT 16)))
(assert (= (proj%%vstd!view.View./V $ (UINT 32)) $))
(assert (= (proj%vstd!view.View./V $ (UINT 32)) (UINT 32)))
(assert (= (proj%%vstd!view.View./V $ (UINT 64)) $))
(assert (= (proj%vstd!view.View./V $ (UINT 64)) (UINT 64)))
(assert (= (proj%%vstd!view.View./V $ (UINT SZ)) $))
(assert (= (proj%vstd!view.View./V $ (UINT SZ)) (UINT SZ)))
(assert (= (proj%%vstd!view.View./V $ (SINT 64)) $))
(assert (= (proj%vstd!view.View./V $ (SINT 64)) (SINT 64)))
(assert (forall ((A0&. Dcr) (A0& Type) (A1&. Dcr) (A1& Type)) (! (= (proj%%vstd!view.View./V $ (TYPE%tuple%2. A0&. A0& A1&. A1&)) $) :pattern ((proj%%vstd!view.View./V $ (TYPE%tuple%2. A0&. A0& A1&. A1&))))))
(assert (forall ((A0&. Dcr) (A0& Type) (A1&. Dcr) (A1& Type)) (! (= (proj%vstd!view.View./V $ (TYPE%tuple%2. A0&. A0& A1&. A1&)) (TYPE%tuple%2. (proj%%vstd!view.View./V A0&. A0&) (proj%vstd!view.View./V A0&. A0&) (proj%%vstd!view.View./V A1&. A1&) (proj%vstd!view.View./V A1&. A1&))) :pattern ((proj%vstd!view.View./V $ (TYPE%tuple%2. A0&. A0& A1&. A1&))))))
(assert (forall ((A0&. Dcr) (A0& Type) (A1&. Dcr) (A1& Type) (A2&. Dcr) (A2& Type) (A3&. Dcr) (A3& Type)) (! (= (proj%%vstd!view.View./V $ (TYPE%tuple%4. A0&. A0& A1&. A1& A2&. A2& A3&. A3&)) $) :pattern ((proj%%vstd!view.View./V $ (TYPE%tuple%4. A0&. A0& A1&. A1& A2&. A2& A3&. A3&))))))
(assert (forall ((A0&. Dcr) (A0& Type) (A1&. Dcr) (A1& Type) (A2&. Dcr) (A2& Type) (A3&. Dcr) (A3& Type)) (! (= (proj%vstd!view.View./V $ (TYPE%tuple%4. A0&. A0& A1&. A1& A2&. A2& A3&. A3&)) (TYPE%tuple%4. (proj%%vstd!view.View./V A0&. A0&) (proj%vstd!view.View./V A0&. A0&) (proj%%vstd!view.View./V A1&. A1&) (proj%vstd!view.View./V A1&. A1&) (proj%%vstd!view.View./V A2&. A2&) (proj%vstd!view.View./V A2&. A2&) (proj%%vstd!view.View./V A3&. A3&) (proj%vstd!view.View./V A3&. A3&))) :pattern ((proj%vstd!view.View./V $ (TYPE%tuple%4. A0&. A0& A1&. A1& A2&. A2& A3&. A3&))))))
(set-info :comment ";; Function-Decl vstd::view::View::view")
(declare-fun vstd!view.View.view.? (Dcr Type Poly) Poly)
(declare-fun vstd!view.View.view%default%.? (Dcr Type Poly) Poly)
(set-info :comment ";; Function-Decl vstd::seq::Seq::len")
(declare-fun vstd!seq.Seq.len.? (Dcr Type Poly) Int)
(set-info :comment ";; Function-Decl vstd::array::ArrayAdditionalSpecFns::spec_index")
(declare-fun vstd!array.ArrayAdditionalSpecFns.spec_index.? (Dcr Type Dcr Type Poly Poly) Poly)
(declare-fun vstd!array.ArrayAdditionalSpecFns.spec_index%default%.? (Dcr Type Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::seq::Seq::new")
(declare-fun vstd!seq.Seq.new.? (Dcr Type Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::array::array_view")
(declare-fun vstd!array.array_view.? (Dcr Type Dcr Type Poly) Poly)
(set-info :comment ";; Function-Decl vstd::seq::Seq::index")
(declare-fun vstd!seq.Seq.index.? (Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::seq::impl&%0::spec_index")
(declare-fun vstd!seq.impl&%0.spec_index.? (Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::map::impl&%0::dom")
(declare-fun vstd!map.impl&%0.dom.? (Dcr Type Dcr Type Poly) Poly)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::contains")
(declare-fun vstd!set.impl&%0.contains.? (Dcr Type Poly Poly) Bool)
(set-info :comment ";; Function-Decl vstd::map::impl&%0::index")
(declare-fun vstd!map.impl&%0.index.? (Dcr Type Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::map::impl&%0::spec_index")
(declare-fun vstd!map.impl&%0.spec_index.? (Dcr Type Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::new")
(declare-fun vstd!set.impl&%0.new.? (Dcr Type Dcr Type Poly) Poly)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::finite")
(declare-fun vstd!set.impl&%0.finite.? (Dcr Type Poly) Bool)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::empty")
(declare-fun vstd!set.impl&%0.empty.? (Dcr Type) Poly)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::insert")
(declare-fun vstd!set.impl&%0.insert.? (Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::remove")
(declare-fun vstd!set.impl&%0.remove.? (Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::raw_ptr::view_reverse_for_eq")
(declare-fun vstd!raw_ptr.view_reverse_for_eq.? (Dcr Type Poly) Poly)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::len")
(declare-fun vstd!set.impl&%0.len.? (Dcr Type Poly) Int)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::choose")
(declare-fun vstd!set.impl&%0.choose.? (Dcr Type Poly) Poly)
(set-info :comment ";; Function-Decl lib::config::SLICE_SIZE")
(declare-fun lib!config.SLICE_SIZE.? () Int)
(set-info :comment ";; Function-Decl lib::layout::start_offset")
(declare-fun lib!layout.start_offset.? (Poly) Int)
(set-info :comment ";; Function-Decl vstd::math::max")
(declare-fun vstd!math.max.? (Poly Poly) Int)
(set-info :comment ";; Function-Decl lib::tokens::heap_u_max")
(declare-fun lib!tokens.heap_u_max.? (Poly) Int)
(declare-fun lib!tokens.rec%heap_u_max.? (Poly Fuel) Int)
(set-info :comment ";; Function-Decl lib::tokens::heap_get_unused_uniq_field")
(declare-fun lib!tokens.heap_get_unused_uniq_field.? (Poly) Int)
(set-info :comment ";; Function-Decl lib::tokens::segment_u_max")
(declare-fun lib!tokens.segment_u_max.? (Poly) Int)
(declare-fun lib!tokens.rec%segment_u_max.? (Poly Fuel) Int)
(set-info :comment ";; Function-Decl lib::tokens::segment_get_unused_uniq_field")
(declare-fun lib!tokens.segment_get_unused_uniq_field.? (Poly) Int)
(set-info :comment ";; Function-Decl lib::tokens::BlockId::get_slice_idx")
(declare-fun lib!tokens.impl&%1.get_slice_idx.? (Poly Poly Poly) Int)
(set-info :comment ";; Function-Decl lib::tokens::BlockId::slice_idx_is_right")
(declare-fun lib!tokens.impl&%1.slice_idx_is_right.? (Poly) Bool)
(set-info :comment ";; Function-Decl lib::tokens::BlockId::page_id_for_slice")
(declare-fun lib!tokens.impl&%1.page_id_for_slice.? (Poly) lib!tokens.PageId.)
(set-info :comment ";; Function-Decl lib::tokens::PageId::range_from")
(declare-fun lib!tokens.impl&%0.range_from.? (Poly Poly Poly) vstd!set.Set<lib!tokens.PageId.>.)
(set-info :comment ";; Function-Decl lib::tokens::BlockId::wf")
(declare-fun lib!tokens.impl&%1.wf.? (Poly) Bool)
(set-info :comment ";; Function-Decl lib::tokens::DelayState::to_int")
(declare-fun lib!tokens.impl&%2.to_int.? (Poly) Int)
(set-info :comment ";; Function-Decl lib::tokens::DelayFreeingActor::arrow_0")
(declare-fun lib!tokens.impl&%3.arrow_0.? (Poly) lib!tokens.HeapId.)
(set-info :comment ";; Function-Decl lib::tokens::DelayFreeingActor::arrow_2")
(declare-fun lib!tokens.impl&%3.arrow_2.? (Poly) lib!types.PageSharedAccess.)
(set-info :comment ";; Function-Decl lib::tokens::DelayFreeingActor::arrow_1")
(declare-fun lib!tokens.impl&%3.arrow_1.? (Poly) lib!types.HeapSharedAccess.)
(set-info :comment ";; Function-Decl lib::tokens::DelayFreeingActor::arrow_Heap_0")
(declare-fun lib!tokens.impl&%3.arrow_Heap_0.? (Poly) lib!tokens.HeapId.)
(set-info :comment ";; Function-Decl lib::tokens::DelayFreeingActor::arrow_Heap_1")
(declare-fun lib!tokens.impl&%3.arrow_Heap_1.? (Poly) lib!types.HeapSharedAccess.)
(set-info :comment ";; Function-Decl lib::tokens::DelayFreeingActor::arrow_Heap_2")
(declare-fun lib!tokens.impl&%3.arrow_Heap_2.? (Poly) lib!types.PageSharedAccess.)
(set-info :comment ";; Function-Axioms vstd::view::View::view")
(assert (forall ((Self%&. Dcr) (Self%& Type) (self! Poly)) (! (=> (has_type self! Self%&) (has_type (vstd!view.View.view.? Self%&. Self%& self!) (proj%vstd!view.View./V Self%&. Self%&))) :pattern ((vstd!view.View.view.? Self%&. Self%& self!)))))
(set-info :comment ";; Function-Axioms vstd::seq::Seq::len")
(assert (forall ((A&. Dcr) (A& Type) (self! Poly)) (! (=> (has_type self! (TYPE%vstd!seq.Seq. A&. A&)) (<= 0 (vstd!seq.Seq.len.? A&. A& self!))) :pattern ((vstd!seq.Seq.len.? A&. A& self!)))))
(set-info :comment ";; Function-Specs vstd::array::ArrayAdditionalSpecFns::spec_index")
(declare-fun req%vstd!array.ArrayAdditionalSpecFns.spec_index. (Dcr Type Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%0 Bool)
(assert (forall ((Self%&. Dcr) (Self%& Type) (T&. Dcr) (T& Type) (self! Poly) (i! Poly)) (! (= (req%vstd!array.ArrayAdditionalSpecFns.spec_index. Self%&. Self%& T&. T& self! i!) (=> %%global_location_label%%0 (and (<= 0 (%I i!)) (< (%I i!) (vstd!seq.Seq.len.? T&. T& (vstd!view.View.view.? Self%&. Self%& self!)))))) :pattern ((req%vstd!array.ArrayAdditionalSpecFns.spec_index. Self%&. Self%& T&. T& self! i!)))))
(set-info :comment ";; Function-Axioms vstd::array::ArrayAdditionalSpecFns::spec_index")
(assert (forall ((Self%&. Dcr) (Self%& Type) (T&. Dcr) (T& Type) (self! Poly) (i! Poly)) (! (=> (and (has_type self! Self%&) (has_type i! INT)) (has_type (vstd!array.ArrayAdditionalSpecFns.spec_index.? Self%&. Self%& T&. T& self! i!) T&)) :pattern ((vstd!array.ArrayAdditionalSpecFns.spec_index.? Self%&. Self%& T&. T& self! i!)))))
(set-info :comment ";; Function-Axioms vstd::seq::Seq::new")
(assert (forall ((A&. Dcr) (A& Type) (impl%1&. Dcr) (impl%1& Type) (len! Poly) (f! Poly)) (! (=> (and (has_type len! NAT) (has_type f! impl%1&)) (has_type (vstd!seq.Seq.new.? A&. A& impl%1&. impl%1& len! f!) (TYPE%vstd!seq.Seq. A&. A&))) :pattern ((vstd!seq.Seq.new.? A&. A& impl%1&. impl%1& len! f!)))))
(set-info :comment ";; Function-Axioms vstd::array::array_view")
(assert (fuel_bool_default fuel%vstd!array.array_view.))
(declare-fun %%lambda%%0 (Dcr Type Dcr Type %%Function%%) %%Function%%)
(assert (forall ((%%hole%%0 Dcr) (%%hole%%1 Type) (%%hole%%2 Dcr) (%%hole%%3 Type) (%%hole%%4 %%Function%%) (i$ Poly)) (! (= (%%apply%%0 (%%lambda%%0 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4) i$) (array_index %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 i$)) :pattern ((%%apply%%0 (%%lambda%%0 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4) i$)))))
(assert (=> (fuel_bool fuel%vstd!array.array_view.) (forall ((T&. Dcr) (T& Type) (N&. Dcr) (N& Type) (a! Poly)) (! (= (vstd!array.array_view.? T&. T& N&. N& a!) (vstd!seq.Seq.new.? T&. T& $ (TYPE%fun%1. $ INT T&. T&) (I (const_int N&)) (Poly%fun%1. (mk_fun (%%lambda%%0 T&. T& N&. N& (%Poly%array%. a!)))))) :pattern ((vstd!array.array_view.? T&. T& N&. N& a!))))))
(assert (forall ((T&. Dcr) (T& Type) (N&. Dcr) (N& Type) (a! Poly)) (! (=> (has_type a! (ARRAY T&. T& N&. N&)) (has_type (vstd!array.array_view.? T&. T& N&. N& a!) (TYPE%vstd!seq.Seq. T&. T&))) :pattern ((vstd!array.array_view.? T&. T& N&. N& a!)))))
(set-info :comment ";; Function-Axioms vstd::array::impl&%0::view")
(assert (fuel_bool_default fuel%vstd!array.impl&%0.view.))
(assert (=> (fuel_bool fuel%vstd!array.impl&%0.view.) (forall ((T&. Dcr) (T& Type) (N&. Dcr) (N& Type) (self! Poly)) (! (=> (uInv SZ (const_int N&)) (= (vstd!view.View.view.? $ (ARRAY T&. T& N&. N&) self!) (vstd!array.array_view.? T&. T& N&. N& self!))) :pattern ((vstd!view.View.view.? $ (ARRAY T&. T& N&. N&) self!))))))
(set-info :comment ";; Function-Specs vstd::seq::Seq::index")
(declare-fun req%vstd!seq.Seq.index. (Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%1 Bool)
(assert (forall ((A&. Dcr) (A& Type) (self! Poly) (i! Poly)) (! (= (req%vstd!seq.Seq.index. A&. A& self! i!) (=> %%global_location_label%%1 (and (<= 0 (%I i!)) (< (%I i!) (vstd!seq.Seq.len.? A&. A& self!))))) :pattern ((req%vstd!seq.Seq.index. A&. A& self! i!)))))
(set-info :comment ";; Function-Axioms vstd::seq::Seq::index")
(assert (forall ((A&. Dcr) (A& Type) (self! Poly) (i! Poly)) (! (=> (and (has_type self! (TYPE%vstd!seq.Seq. A&. A&)) (has_type i! INT)) (has_type (vstd!seq.Seq.index.? A&. A& self! i!) A&)) :pattern ((vstd!seq.Seq.index.? A&. A& self! i!)))))
(set-info :comment ";; Function-Axioms vstd::array::impl&%2::spec_index")
(assert (fuel_bool_default fuel%vstd!array.impl&%2.spec_index.))
(assert (=> (fuel_bool fuel%vstd!array.impl&%2.spec_index.) (forall ((T&. Dcr) (T& Type) (N&. Dcr) (N& Type) (self! Poly) (i! Poly)) (! (=> (uInv SZ (const_int N&)) (= (vstd!array.ArrayAdditionalSpecFns.spec_index.? $ (ARRAY T&. T& N&. N&) T&. T& self! i!) (vstd!seq.Seq.index.? T&. T& (vstd!view.View.view.? $ (ARRAY T&. T& N&. N&) self!) i!))) :pattern ((vstd!array.ArrayAdditionalSpecFns.spec_index.? $ (ARRAY T&. T& N&. N&) T&. T& self! i!))))))
(set-info :comment ";; Function-Specs vstd::seq::impl&%0::spec_index")
(declare-fun req%vstd!seq.impl&%0.spec_index. (Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%2 Bool)
(assert (forall ((A&. Dcr) (A& Type) (self! Poly) (i! Poly)) (! (= (req%vstd!seq.impl&%0.spec_index. A&. A& self! i!) (=> %%global_location_label%%2 (and (<= 0 (%I i!)) (< (%I i!) (vstd!seq.Seq.len.? A&. A& self!))))) :pattern ((req%vstd!seq.impl&%0.spec_index. A&. A& self! i!)))))
(set-info :comment ";; Function-Axioms vstd::seq::impl&%0::spec_index")
(assert (fuel_bool_default fuel%vstd!seq.impl&%0.spec_index.))
(assert (=> (fuel_bool fuel%vstd!seq.impl&%0.spec_index.) (forall ((A&. Dcr) (A& Type) (self! Poly) (i! Poly)) (! (= (vstd!seq.impl&%0.spec_index.? A&. A& self! i!) (vstd!seq.Seq.index.? A&. A& self! i!)) :pattern ((vstd!seq.impl&%0.spec_index.? A&. A& self! i!))))))
(assert (forall ((A&. Dcr) (A& Type) (self! Poly) (i! Poly)) (! (=> (and (has_type self! (TYPE%vstd!seq.Seq. A&. A&)) (has_type i! INT)) (has_type (vstd!seq.impl&%0.spec_index.? A&. A& self! i!) A&)) :pattern ((vstd!seq.impl&%0.spec_index.? A&. A& self! i!)))))
(set-info :comment ";; Broadcast vstd::array::lemma_array_index")
(assert (=> (fuel_bool fuel%vstd!array.lemma_array_index.) (forall ((T&. Dcr) (T& Type) (N&. Dcr) (N& Type) (a! Poly) (i! Poly)) (! (=> (and (has_type a! (ARRAY T&. T& N&. N&)) (has_type i! INT)) (=> (and (uInv SZ (const_int N&)) (and (<= 0 (%I i!)) (< (%I i!) (const_int N&)))) (= (vstd!seq.Seq.index.? T&. T& (vstd!view.View.view.? $ (ARRAY T&. T& N&. N&) a!) i!) (vstd!seq.Seq.index.? T&. T& (vstd!array.array_view.? T&. T& N&. N& a!) i!)))) :pattern ((array_index T&. T& N&. N& (%Poly%array%. a!) i!))))))
(set-info :comment ";; Broadcast vstd::array::array_len_matches_n")
(assert (=> (fuel_bool fuel%vstd!array.array_len_matches_n.) (forall ((T&. Dcr) (T& Type) (N&. Dcr) (N& Type) (ar! Poly)) (! (=> (has_type ar! (ARRAY T&. T& N&. N&)) (=> (uInv SZ (const_int N&)) (= (vstd!seq.Seq.len.? T&. T& (vstd!view.View.view.? $ (ARRAY T&. T& N&. N&) ar!)) (const_int N&)))) :pattern ((vstd!seq.Seq.len.? T&. T& (vstd!view.View.view.? $ (ARRAY T&. T& N&. N&) ar!)))))))
(set-info :comment ";; Function-Axioms vstd::map::impl&%0::dom")
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self! Poly)) (! (=> (has_type self! (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type (vstd!map.impl&%0.dom.? K&. K& V&. V& self!) (TYPE%vstd!set.Set. K&. K&))) :pattern ((vstd!map.impl&%0.dom.? K&. K& V&. V& self!)))))
(set-info :comment ";; Function-Specs vstd::map::impl&%0::index")
(declare-fun req%vstd!map.impl&%0.index. (Dcr Type Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%3 Bool)
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self! Poly) (key! Poly)) (! (= (req%vstd!map.impl&%0.index. K&. K& V&. V& self! key!) (=> %%global_location_label%%3 (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& self!) key!))) :pattern ((req%vstd!map.impl&%0.index. K&. K& V&. V& self! key!)))))
(set-info :comment ";; Function-Axioms vstd::map::impl&%0::index")
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self! Poly) (key! Poly)) (! (=> (and (has_type self! (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type key! K&)) (has_type (vstd!map.impl&%0.index.? K&. K& V&. V& self! key!) V&)) :pattern ((vstd!map.impl&%0.index.? K&. K& V&. V& self! key!)))))
(set-info :comment ";; Function-Specs vstd::map::impl&%0::spec_index")
(declare-fun req%vstd!map.impl&%0.spec_index. (Dcr Type Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%4 Bool)
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self! Poly) (key! Poly)) (! (= (req%vstd!map.impl&%0.spec_index. K&. K& V&. V& self! key!) (=> %%global_location_label%%4 (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& self!) key!))) :pattern ((req%vstd!map.impl&%0.spec_index. K&. K& V&. V& self! key!)))))
(set-info :comment ";; Function-Axioms vstd::map::impl&%0::spec_index")
(assert (fuel_bool_default fuel%vstd!map.impl&%0.spec_index.))
(assert (=> (fuel_bool fuel%vstd!map.impl&%0.spec_index.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self! Poly) (key! Poly)) (! (= (vstd!map.impl&%0.spec_index.? K&. K& V&. V& self! key!) (vstd!map.impl&%0.index.? K&. K& V&. V& self! key!)) :pattern ((vstd!map.impl&%0.spec_index.? K&. K& V&. V& self! key!))))))
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self! Poly) (key! Poly)) (! (=> (and (has_type self! (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type key! K&)) (has_type (vstd!map.impl&%0.spec_index.? K&. K& V&. V& self! key!) V&)) :pattern ((vstd!map.impl&%0.spec_index.? K&. K& V&. V& self! key!)))))
(set-info :comment ";; Function-Axioms vstd::set::impl&%0::new")
(assert (forall ((A&. Dcr) (A& Type) (F&. Dcr) (F& Type) (f! Poly)) (! (=> (has_type f! F&) (has_type (vstd!set.impl&%0.new.? A&. A& F&. F& f!) (TYPE%vstd!set.Set. A&. A&))) :pattern ((vstd!set.impl&%0.new.? A&. A& F&. F& f!)))))
(set-info :comment ";; Broadcast vstd::map::axiom_map_index_decreases_finite")
(assert (=> (fuel_bool fuel%vstd!map.axiom_map_index_decreases_finite.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m! Poly) (key! Poly)) (! (=> (and (has_type m! (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type key! K&)) (=> (and (vstd!set.impl&%0.finite.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m!)) (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m!) key!)) (height_lt (height (vstd!map.impl&%0.index.? K&. K& V&. V& m! key!)) (height m!)))) :pattern ((height (vstd!map.impl&%0.index.? K&. K& V&. V& m! key!)))))))
(set-info :comment ";; Broadcast vstd::map::axiom_map_index_decreases_infinite")
(assert (=> (fuel_bool fuel%vstd!map.axiom_map_index_decreases_infinite.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m! Poly) (key! Poly)) (! (=> (and (has_type m! (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type key! K&)) (=> (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m!) key!) (height_lt (height (vstd!map.impl&%0.index.? K&. K& V&. V& m! key!)) (height (fun_from_recursive_field m!))))) :pattern ((height (vstd!map.impl&%0.index.? K&. K& V&. V& m! key!)))))))
(set-info :comment ";; Function-Axioms vstd::set::impl&%0::empty")
(assert (forall ((A&. Dcr) (A& Type)) (! (has_type (vstd!set.impl&%0.empty.? A&. A&) (TYPE%vstd!set.Set. A&. A&)) :pattern ((vstd!set.impl&%0.empty.? A&. A&)))))
(set-info :comment ";; Function-Axioms vstd::set::impl&%0::insert")
(assert (forall ((A&. Dcr) (A& Type) (self! Poly) (a! Poly)) (! (=> (and (has_type self! (TYPE%vstd!set.Set. A&. A&)) (has_type a! A&)) (has_type (vstd!set.impl&%0.insert.? A&. A& self! a!) (TYPE%vstd!set.Set. A&. A&))) :pattern ((vstd!set.impl&%0.insert.? A&. A& self! a!)))))
(set-info :comment ";; Function-Axioms vstd::set::impl&%0::remove")
(assert (forall ((A&. Dcr) (A& Type) (self! Poly) (a! Poly)) (! (=> (and (has_type self! (TYPE%vstd!set.Set. A&. A&)) (has_type a! A&)) (has_type (vstd!set.impl&%0.remove.? A&. A& self! a!) (TYPE%vstd!set.Set. A&. A&))) :pattern ((vstd!set.impl&%0.remove.? A&. A& self! a!)))))
(set-info :comment ";; Broadcast vstd::map::axiom_map_ext_equal")
(assert (=> (fuel_bool fuel%vstd!map.axiom_map_ext_equal.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m1! Poly) (m2! Poly)) (! (=> (and (has_type m1! (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type m2! (TYPE%vstd!map.Map. K&. K& V&. V&))) (= (ext_eq false (TYPE%vstd!map.Map. K&. K& V&. V&) m1! m2!) (and (ext_eq false (TYPE%vstd!set.Set. K&. K&) (vstd!map.impl&%0.dom.? K&. K& V&. V& m1!) (vstd!map.impl&%0.dom.? K&. K& V&. V& m2!)) (forall ((k$ Poly)) (! (=> (has_type k$ K&) (=> (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m1!) k$) (= (vstd!map.impl&%0.index.? K&. K& V&. V& m1! k$) (vstd!map.impl&%0.index.? K&. K& V&. V& m2! k$)))) :pattern ((vstd!map.impl&%0.index.? K&. K& V&. V& m1! k$)) :pattern ((vstd!map.impl&%0.index.? K&. K& V&. V& m2! k$))))))) :pattern ((ext_eq false (TYPE%vstd!map.Map. K&. K& V&. V&) m1! m2!))))))
(set-info :comment ";; Broadcast vstd::map::axiom_map_ext_equal_deep")
(assert (=> (fuel_bool fuel%vstd!map.axiom_map_ext_equal_deep.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m1! Poly) (m2! Poly)) (! (=> (and (has_type m1! (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type m2! (TYPE%vstd!map.Map. K&. K& V&. V&))) (= (ext_eq true (TYPE%vstd!map.Map. K&. K& V&. V&) m1! m2!) (and (ext_eq true (TYPE%vstd!set.Set. K&. K&) (vstd!map.impl&%0.dom.? K&. K& V&. V& m1!) (vstd!map.impl&%0.dom.? K&. K& V&. V& m2!)) (forall ((k$ Poly)) (! (=> (has_type k$ K&) (=> (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m1!) k$) (ext_eq true V& (vstd!map.impl&%0.index.? K&. K& V&. V& m1! k$) (vstd!map.impl&%0.index.? K&. K& V&. V& m2! k$)))) :pattern ((vstd!map.impl&%0.index.? K&. K& V&. V& m1! k$)) :pattern ((vstd!map.impl&%0.index.? K&. K& V&. V& m2! k$))))))) :pattern ((ext_eq true (TYPE%vstd!map.Map. K&. K& V&. V&) m1! m2!))))))
(set-info :comment ";; Function-Axioms vstd::raw_ptr::view_reverse_for_eq")
(assert (forall ((T&. Dcr) (T& Type) (data! Poly)) (! (=> (has_type data! TYPE%vstd!raw_ptr.PtrData.) (has_type (vstd!raw_ptr.view_reverse_for_eq.? T&. T& data!) (PTR T&. T&))) :pattern ((vstd!raw_ptr.view_reverse_for_eq.? T&. T& data!)))))
(set-info :comment ";; Broadcast vstd::raw_ptr::ptrs_mut_eq")
(assert (=> (fuel_bool fuel%vstd!raw_ptr.ptrs_mut_eq.) (forall ((T&. Dcr) (T& Type) (a! Poly)) (! (=> (has_type a! (PTR T&. T&)) (= (vstd!raw_ptr.view_reverse_for_eq.? T&. T& (vstd!view.View.view.? $ (PTR T&. T&) a!)) a!)) :pattern ((vstd!view.View.view.? $ (PTR T&. T&) a!))))))
(set-info :comment ";; Broadcast vstd::seq::axiom_seq_index_decreases")
(assert (=> (fuel_bool fuel%vstd!seq.axiom_seq_index_decreases.) (forall ((A&. Dcr) (A& Type) (s! Poly) (i! Poly)) (! (=> (and (has_type s! (TYPE%vstd!seq.Seq. A&. A&)) (has_type i! INT)) (=> (and (<= 0 (%I i!)) (< (%I i!) (vstd!seq.Seq.len.? A&. A& s!))) (height_lt (height (vstd!seq.Seq.index.? A&. A& s! i!)) (height s!)))) :pattern ((height (vstd!seq.Seq.index.? A&. A& s! i!)))))))
(set-info :comment ";; Broadcast vstd::seq::axiom_seq_new_len")
(assert (=> (fuel_bool fuel%vstd!seq.axiom_seq_new_len.) (forall ((A&. Dcr) (A& Type) (len! Poly) (f! Poly)) (! (=> (and (has_type len! NAT) (has_type f! (TYPE%fun%1. $ INT A&. A&))) (= (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.new.? A&. A& $ (TYPE%fun%1. $ INT A&. A&) len! f!)) (%I len!))) :pattern ((vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.new.? A&. A& $ (TYPE%fun%1. $ INT A&. A&) len! f!)))))))
(set-info :comment ";; Broadcast vstd::seq::axiom_seq_new_index")
(assert (=> (fuel_bool fuel%vstd!seq.axiom_seq_new_index.) (forall ((A&. Dcr) (A& Type) (len! Poly) (f! Poly) (i! Poly)) (! (=> (and (has_type len! NAT) (has_type f! (TYPE%fun%1. $ INT A&. A&)) (has_type i! INT)) (=> (and (<= 0 (%I i!)) (< (%I i!) (%I len!))) (= (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.new.? A&. A& $ (TYPE%fun%1. $ INT A&. A&) len! f!) i!) (%%apply%%0 (%Poly%fun%1. f!) i!)))) :pattern ((vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.new.? A&. A& $ (TYPE%fun%1. $ INT A&. A&) len! f!) i!))))))
(set-info :comment ";; Broadcast vstd::seq::axiom_seq_ext_equal")
(assert (=> (fuel_bool fuel%vstd!seq.axiom_seq_ext_equal.) (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly)) (! (=> (and (has_type s1! (TYPE%vstd!seq.Seq. A&. A&)) (has_type s2! (TYPE%vstd!seq.Seq. A&. A&))) (= (ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) (and (= (vstd!seq.Seq.len.? A&. A& s1!) (vstd!seq.Seq.len.? A&. A& s2!)) (forall ((i$ Poly)) (! (=> (has_type i$ INT) (=> (and (<= 0 (%I i$)) (< (%I i$) (vstd!seq.Seq.len.? A&. A& s1!))) (= (vstd!seq.Seq.index.? A&. A& s1! i$) (vstd!seq.Seq.index.? A&. A& s2! i$)))) :pattern ((vstd!seq.Seq.index.? A&. A& s1! i$)) :pattern ((vstd!seq.Seq.index.? A&. A& s2! i$))))))) :pattern ((ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!))))))
(set-info :comment ";; Broadcast vstd::seq::axiom_seq_ext_equal_deep")
(assert (=> (fuel_bool fuel%vstd!seq.axiom_seq_ext_equal_deep.) (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly)) (! (=> (and (has_type s1! (TYPE%vstd!seq.Seq. A&. A&)) (has_type s2! (TYPE%vstd!seq.Seq. A&. A&))) (= (ext_eq true (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) (and (= (vstd!seq.Seq.len.? A&. A& s1!) (vstd!seq.Seq.len.? A&. A& s2!)) (forall ((i$ Poly)) (! (=> (has_type i$ INT) (=> (and (<= 0 (%I i$)) (< (%I i$) (vstd!seq.Seq.len.? A&. A& s1!))) (ext_eq true A& (vstd!seq.Seq.index.? A&. A& s1! i$) (vstd!seq.Seq.index.? A&. A& s2! i$)))) :pattern ((vstd!seq.Seq.index.? A&. A& s1! i$)) :pattern ((vstd!seq.Seq.index.? A&. A& s2! i$))))))) :pattern ((ext_eq true (TYPE%vstd!seq.Seq. A&. A&) s1! s2!))))))
(set-info :comment ";; Function-Axioms vstd::set::impl&%0::len")
(assert (forall ((A&. Dcr) (A& Type) (self! Poly)) (! (=> (has_type self! (TYPE%vstd!set.Set. A&. A&)) (<= 0 (vstd!set.impl&%0.len.? A&. A& self!))) :pattern ((vstd!set.impl&%0.len.? A&. A& self!)))))
(set-info :comment ";; Broadcast vstd::set::axiom_set_empty")
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_empty.) (forall ((A&. Dcr) (A& Type) (a! Poly)) (! (=> (has_type a! A&) (not (vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.empty.? A&. A&) a!))) :pattern ((vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.empty.? A&. A&) a!))))))
(set-info :comment ";; Broadcast vstd::set::axiom_set_new")
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_new.) (forall ((A&. Dcr) (A& Type) (f! Poly) (a! Poly)) (! (=> (and (has_type f! (TYPE%fun%1. A&. A& $ BOOL)) (has_type a! A&)) (= (vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.new.? A&. A& $ (TYPE%fun%1. A&. A& $ BOOL) f!) a!) (%B (%%apply%%0 (%Poly%fun%1. f!) a!)))) :pattern ((vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.new.? A&. A& $ (TYPE%fun%1. A&. A& $ BOOL) f!) a!))))))
(set-info :comment ";; Broadcast vstd::set::axiom_set_insert_same")
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_insert_same.) (forall ((A&. Dcr) (A& Type) (s! Poly) (a! Poly)) (! (=> (and (has_type s! (TYPE%vstd!set.Set. A&. A&)) (has_type a! A&)) (vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.insert.? A&. A& s! a!) a!)) :pattern ((vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.insert.? A&. A& s! a!) a!))))))
(set-info :comment ";; Broadcast vstd::set::axiom_set_insert_different")
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_insert_different.) (forall ((A&. Dcr) (A& Type) (s! Poly) (a1! Poly) (a2! Poly)) (! (=> (and (has_type s! (TYPE%vstd!set.Set. A&. A&)) (has_type a1! A&) (has_type a2! A&)) (=> (not (= a1! a2!)) (= (vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.insert.? A&. A& s! a2!) a1!) (vstd!set.impl&%0.contains.? A&. A& s! a1!)))) :pattern ((vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.insert.? A&. A& s! a2!) a1!))))))
(set-info :comment ";; Broadcast vstd::set::axiom_set_remove_same")
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_remove_same.) (forall ((A&. Dcr) (A& Type) (s! Poly) (a! Poly)) (! (=> (and (has_type s! (TYPE%vstd!set.Set. A&. A&)) (has_type a! A&)) (not (vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.remove.? A&. A& s! a!) a!))) :pattern ((vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.remove.? A&. A& s! a!) a!))))))
(set-info :comment ";; Broadcast vstd::set::axiom_set_remove_insert")
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_remove_insert.) (forall ((A&. Dcr) (A& Type) (s! Poly) (a! Poly)) (! (=> (and (has_type s! (TYPE%vstd!set.Set. A&. A&)) (has_type a! A&)) (=> (vstd!set.impl&%0.contains.? A&. A& s! a!) (= (vstd!set.impl&%0.insert.? A&. A& (vstd!set.impl&%0.remove.? A&. A& s! a!) a!) s!))) :pattern ((vstd!set.impl&%0.remove.? A&. A& s! a!))))))
(set-info :comment ";; Broadcast vstd::set::axiom_set_remove_different")
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_remove_different.) (forall ((A&. Dcr) (A& Type) (s! Poly) (a1! Poly) (a2! Poly)) (! (=> (and (has_type s! (TYPE%vstd!set.Set. A&. A&)) (has_type a1! A&) (has_type a2! A&)) (=> (not (= a1! a2!)) (= (vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.remove.? A&. A& s! a2!) a1!) (vstd!set.impl&%0.contains.? A&. A& s! a1!)))) :pattern ((vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.remove.? A&. A& s! a2!) a1!))))))
(set-info :comment ";; Broadcast vstd::set::axiom_set_ext_equal")
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_ext_equal.) (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly)) (! (=> (and (has_type s1! (TYPE%vstd!set.Set. A&. A&)) (has_type s2! (TYPE%vstd!set.Set. A&. A&))) (= (ext_eq false (TYPE%vstd!set.Set. A&. A&) s1! s2!) (forall ((a$ Poly)) (! (=> (has_type a$ A&) (= (vstd!set.impl&%0.contains.? A&. A& s1! a$) (vstd!set.impl&%0.contains.? A&. A& s2! a$))) :pattern ((vstd!set.impl&%0.contains.? A&. A& s1! a$)) :pattern ((vstd!set.impl&%0.contains.? A&. A& s2! a$)))))) :pattern ((ext_eq false (TYPE%vstd!set.Set. A&. A&) s1! s2!))))))
(set-info :comment ";; Broadcast vstd::set::axiom_set_ext_equal_deep")
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_ext_equal_deep.) (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly)) (! (=> (and (has_type s1! (TYPE%vstd!set.Set. A&. A&)) (has_type s2! (TYPE%vstd!set.Set. A&. A&))) (= (ext_eq true (TYPE%vstd!set.Set. A&. A&) s1! s2!) (ext_eq false (TYPE%vstd!set.Set. A&. A&) s1! s2!))) :pattern ((ext_eq true (TYPE%vstd!set.Set. A&. A&) s1! s2!))))))
(set-info :comment ";; Broadcast vstd::set::axiom_set_empty_finite")
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_empty_finite.) (forall ((A&. Dcr) (A& Type)) (! (vstd!set.impl&%0.finite.? A&. A& (vstd!set.impl&%0.empty.? A&. A&)) :pattern ((vstd!set.impl&%0.finite.? A&. A& (vstd!set.impl&%0.empty.? A&. A&)))))))
(set-info :comment ";; Broadcast vstd::set::axiom_set_insert_finite")
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_insert_finite.) (forall ((A&. Dcr) (A& Type) (s! Poly) (a! Poly)) (! (=> (and (has_type s! (TYPE%vstd!set.Set. A&. A&)) (has_type a! A&)) (=> (vstd!set.impl&%0.finite.? A&. A& s!) (vstd!set.impl&%0.finite.? A&. A& (vstd!set.impl&%0.insert.? A&. A& s! a!)))) :pattern ((vstd!set.impl&%0.finite.? A&. A& (vstd!set.impl&%0.insert.? A&. A& s! a!)))))))
(set-info :comment ";; Broadcast vstd::set::axiom_set_remove_finite")
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_remove_finite.) (forall ((A&. Dcr) (A& Type) (s! Poly) (a! Poly)) (! (=> (and (has_type s! (TYPE%vstd!set.Set. A&. A&)) (has_type a! A&)) (=> (vstd!set.impl&%0.finite.? A&. A& s!) (vstd!set.impl&%0.finite.? A&. A& (vstd!set.impl&%0.remove.? A&. A& s! a!)))) :pattern ((vstd!set.impl&%0.finite.? A&. A& (vstd!set.impl&%0.remove.? A&. A& s! a!)))))))
(set-info :comment ";; Function-Axioms vstd::set::impl&%0::choose")
(assert (fuel_bool_default fuel%vstd!set.impl&%0.choose.))
(declare-fun %%choose%%0 (Type Dcr Type Poly Dcr Type Poly) Poly)
(assert (forall ((%%hole%%0 Type) (%%hole%%1 Dcr) (%%hole%%2 Type) (%%hole%%3 Poly) (%%hole%%4 Dcr) (%%hole%%5 Type) (%%hole%%6 Poly)) (! (=> (exists ((a$ Poly)) (! (and (has_type a$ %%hole%%0) (vstd!set.impl&%0.contains.? %%hole%%1 %%hole%%2 %%hole%%3 a$)) :pattern ((vstd!set.impl&%0.contains.? %%hole%%4 %%hole%%5 %%hole%%6 a$)))) (exists ((a$ Poly)) (! (and (and (has_type a$ %%hole%%0) (vstd!set.impl&%0.contains.? %%hole%%1 %%hole%%2 %%hole%%3 a$)) (= (%%choose%%0 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5 %%hole%%6) a$)) :pattern ((vstd!set.impl&%0.contains.? %%hole%%4 %%hole%%5 %%hole%%6 a$))))) :pattern ((%%choose%%0 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5 %%hole%%6)))))
(assert (=> (fuel_bool fuel%vstd!set.impl&%0.choose.) (forall ((A&. Dcr) (A& Type) (self! Poly)) (! (= (vstd!set.impl&%0.choose.? A&. A& self!) (as_type (%%choose%%0 A& A&. A& self! A&. A& self!) A&)) :pattern ((vstd!set.impl&%0.choose.? A&. A& self!))))))
(assert (forall ((A&. Dcr) (A& Type) (self! Poly)) (! (=> (has_type self! (TYPE%vstd!set.Set. A&. A&)) (has_type (vstd!set.impl&%0.choose.? A&. A& self!) A&)) :pattern ((vstd!set.impl&%0.choose.? A&. A& self!)))))
(set-info :comment ";; Broadcast vstd::set::axiom_set_choose_finite")
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_choose_finite.) (forall ((A&. Dcr) (A& Type) (s! Poly)) (! (=> (has_type s! (TYPE%vstd!set.Set. A&. A&)) (=> (not (vstd!set.impl&%0.finite.? A&. A& s!)) (vstd!set.impl&%0.contains.? A&. A& s! (vstd!set.impl&%0.choose.? A&. A& s!)))) :pattern ((vstd!set.impl&%0.contains.? A&. A& s! (vstd!set.impl&%0.choose.? A&. A& s!)))))))
(set-info :comment ";; Broadcast vstd::set::axiom_set_empty_len")
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_empty_len.) (forall ((A&. Dcr) (A& Type)) (! (= (vstd!set.impl&%0.len.? A&. A& (vstd!set.impl&%0.empty.? A&. A&)) 0) :pattern ((vstd!set.impl&%0.len.? A&. A& (vstd!set.impl&%0.empty.? A&. A&)))))))
(set-info :comment ";; Broadcast vstd::set::axiom_set_insert_len")
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_insert_len.) (forall ((A&. Dcr) (A& Type) (s! Poly) (a! Poly)) (! (=> (and (has_type s! (TYPE%vstd!set.Set. A&. A&)) (has_type a! A&)) (=> (vstd!set.impl&%0.finite.? A&. A& s!) (= (vstd!set.impl&%0.len.? A&. A& (vstd!set.impl&%0.insert.? A&. A& s! a!)) (Add (vstd!set.impl&%0.len.? A&. A& s!) (ite (vstd!set.impl&%0.contains.? A&. A& s! a!) 0 1))))) :pattern ((vstd!set.impl&%0.len.? A&. A& (vstd!set.impl&%0.insert.? A&. A& s! a!)))))))
(set-info :comment ";; Broadcast vstd::set::axiom_set_remove_len")
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_remove_len.) (forall ((A&. Dcr) (A& Type) (s! Poly) (a! Poly)) (! (=> (and (has_type s! (TYPE%vstd!set.Set. A&. A&)) (has_type a! A&)) (=> (vstd!set.impl&%0.finite.? A&. A& s!) (= (vstd!set.impl&%0.len.? A&. A& s!) (Add (vstd!set.impl&%0.len.? A&. A& (vstd!set.impl&%0.remove.? A&. A& s! a!)) (ite (vstd!set.impl&%0.contains.? A&. A& s! a!) 1 0))))) :pattern ((vstd!set.impl&%0.len.? A&. A& (vstd!set.impl&%0.remove.? A&. A& s! a!)))))))
(set-info :comment ";; Broadcast vstd::set::axiom_set_contains_len")
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_contains_len.) (forall ((A&. Dcr) (A& Type) (s! Poly) (a! Poly)) (! (=> (and (has_type s! (TYPE%vstd!set.Set. A&. A&)) (has_type a! A&)) (=> (and (vstd!set.impl&%0.finite.? A&. A& s!) (vstd!set.impl&%0.contains.? A&. A& s! a!)) (not (= (vstd!set.impl&%0.len.? A&. A& s!) 0)))) :pattern ((vstd!set.impl&%0.contains.? A&. A& s! a!) (vstd!set.impl&%0.len.? A&. A& s!))))))
(set-info :comment ";; Broadcast vstd::set::axiom_set_choose_len")
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_choose_len.) (forall ((A&. Dcr) (A& Type) (s! Poly)) (! (=> (has_type s! (TYPE%vstd!set.Set. A&. A&)) (=> (and (vstd!set.impl&%0.finite.? A&. A& s!) (not (= (vstd!set.impl&%0.len.? A&. A& s!) 0))) (vstd!set.impl&%0.contains.? A&. A& s! (vstd!set.impl&%0.choose.? A&. A& s!)))) :pattern ((vstd!set.impl&%0.len.? A&. A& s!) (vstd!set.impl&%0.contains.? A&. A& s! (vstd!set.impl&%0.choose.? A&. A& s!)))))))
(set-info :comment ";; Function-Specs vstd::set_lib::lemma_set_empty_equivalency_len")
(declare-fun req%vstd!set_lib.lemma_set_empty_equivalency_len. (Dcr Type Poly) Bool)
(declare-const %%global_location_label%%5 Bool)
(assert (forall ((A&. Dcr) (A& Type) (s! Poly)) (! (= (req%vstd!set_lib.lemma_set_empty_equivalency_len. A&. A& s!) (=> %%global_location_label%%5 (vstd!set.impl&%0.finite.? A&. A& s!))) :pattern ((req%vstd!set_lib.lemma_set_empty_equivalency_len. A&. A& s!)))))
(declare-fun ens%vstd!set_lib.lemma_set_empty_equivalency_len. (Dcr Type Poly) Bool)
(assert (forall ((A&. Dcr) (A& Type) (s! Poly)) (! (= (ens%vstd!set_lib.lemma_set_empty_equivalency_len. A&. A& s!) (and (= (= (vstd!set.impl&%0.len.? A&. A& s!) 0) (= s! (vstd!set.impl&%0.empty.? A&. A&))) (=> (not (= (vstd!set.impl&%0.len.? A&. A& s!) 0)) (exists ((x$ Poly)) (! (and (has_type x$ A&) (vstd!set.impl&%0.contains.? A&. A& s! x$)) :pattern ((vstd!set.impl&%0.contains.? A&. A& s! x$))))))) :pattern ((ens%vstd!set_lib.lemma_set_empty_equivalency_len. A&. A& s!)))))
(set-info :comment ";; Function-Axioms lib::config::SLICE_SIZE")
(assert (fuel_bool_default fuel%lib!config.SLICE_SIZE.))
(assert (=> (fuel_bool fuel%lib!config.SLICE_SIZE.) (= lib!config.SLICE_SIZE.? 65536)))
(assert (uInv 64 lib!config.SLICE_SIZE.?))
(set-info :comment ";; Function-Axioms vstd::math::max")
(assert (fuel_bool_default fuel%vstd!math.max.))
(assert (=> (fuel_bool fuel%vstd!math.max.) (forall ((x! Poly) (y! Poly)) (! (= (vstd!math.max.? x! y!) (%I (ite (>= (%I x!) (%I y!)) x! y!))) :pattern ((vstd!math.max.? x! y!))))))
(set-info :comment ";; Function-Specs lib::tokens::heap_u_max")
(declare-fun req%lib!tokens.heap_u_max. (Poly) Bool)
(declare-const %%global_location_label%%6 Bool)
(assert (forall ((s! Poly)) (! (= (req%lib!tokens.heap_u_max. s!) (=> %%global_location_label%%6 (vstd!set.impl&%0.finite.? $ TYPE%lib!tokens.HeapId. s!))) :pattern ((req%lib!tokens.heap_u_max. s!)))))
(set-info :comment ";; Spec-Termination lib::tokens::heap_u_max")
(set-info :comment ";; tokens.rs:245:1: 245:51 (#0)")
(set-info :comment ";; Function-Axioms lib::tokens::heap_u_max")
(assert (fuel_bool_default fuel%lib!tokens.heap_u_max.))
(declare-const fuel_nat%lib!tokens.heap_u_max. Fuel)
(assert (forall ((s! Poly) (fuel% Fuel)) (! (= (lib!tokens.rec%heap_u_max.? s! fuel%) (lib!tokens.rec%heap_u_max.? s! zero)) :pattern ((lib!tokens.rec%heap_u_max.? s! fuel%)))))
(assert (forall ((s! Poly) (fuel% Fuel)) (! (=> (and (has_type s! (TYPE%vstd!set.Set. $ TYPE%lib!tokens.HeapId.)) (vstd!set.impl&%0.finite.? $ TYPE%lib!tokens.HeapId. s!)) (= (lib!tokens.rec%heap_u_max.? s! (succ fuel%)) (ite (= (vstd!set.impl&%0.len.? $ TYPE%lib!tokens.HeapId. s!) 0) 0 (let ((x$ (%Poly%lib!tokens.HeapId. (vstd!set.impl&%0.choose.? $ TYPE%lib!tokens.HeapId. s!)))) (vstd!math.max.? (I (lib!tokens.rec%heap_u_max.? (vstd!set.impl&%0.remove.? $ TYPE%lib!tokens.HeapId. s! (Poly%lib!tokens.HeapId. x$)) fuel%)) (I (lib!tokens.HeapId./HeapId/uniq (%Poly%lib!tokens.HeapId. (Poly%lib!tokens.HeapId. x$))))))))) :pattern ((lib!tokens.rec%heap_u_max.? s! (succ fuel%))))))
(assert (=> (fuel_bool fuel%lib!tokens.heap_u_max.) (forall ((s! Poly)) (! (=> (and (has_type s! (TYPE%vstd!set.Set. $ TYPE%lib!tokens.HeapId.)) (vstd!set.impl&%0.finite.? $ TYPE%lib!tokens.HeapId. s!)) (= (lib!tokens.heap_u_max.? s!) (lib!tokens.rec%heap_u_max.? s! (succ fuel_nat%lib!tokens.heap_u_max.)))) :pattern ((lib!tokens.heap_u_max.? s!))))))
(set-info :comment ";; Function-Axioms lib::tokens::heap_get_unused_uniq_field")
(assert (fuel_bool_default fuel%lib!tokens.heap_get_unused_uniq_field.))
(assert (=> (fuel_bool fuel%lib!tokens.heap_get_unused_uniq_field.) (forall ((s! Poly)) (! (= (lib!tokens.heap_get_unused_uniq_field.? s!) (Add (lib!tokens.heap_u_max.? s!) 1)) :pattern ((lib!tokens.heap_get_unused_uniq_field.? s!))))))
(set-info :comment ";; Function-Specs lib::tokens::segment_u_max")
(declare-fun req%lib!tokens.segment_u_max. (Poly) Bool)
(declare-const %%global_location_label%%7 Bool)
(assert (forall ((s! Poly)) (! (= (req%lib!tokens.segment_u_max. s!) (=> %%global_location_label%%7 (vstd!set.impl&%0.finite.? $ TYPE%lib!tokens.SegmentId. s!))) :pattern ((req%lib!tokens.segment_u_max. s!)))))
(set-info :comment ";; Spec-Termination lib::tokens::segment_u_max")
(set-info :comment ";; tokens.rs:208:1: 208:57 (#0)")
(set-info :comment ";; Function-Axioms lib::tokens::segment_u_max")
(assert (fuel_bool_default fuel%lib!tokens.segment_u_max.))
(declare-const fuel_nat%lib!tokens.segment_u_max. Fuel)
(assert (forall ((s! Poly) (fuel% Fuel)) (! (= (lib!tokens.rec%segment_u_max.? s! fuel%) (lib!tokens.rec%segment_u_max.? s! zero)) :pattern ((lib!tokens.rec%segment_u_max.? s! fuel%)))))
(assert (forall ((s! Poly) (fuel% Fuel)) (! (=> (and (has_type s! (TYPE%vstd!set.Set. $ TYPE%lib!tokens.SegmentId.)) (vstd!set.impl&%0.finite.? $ TYPE%lib!tokens.SegmentId. s!)) (= (lib!tokens.rec%segment_u_max.? s! (succ fuel%)) (ite (= (vstd!set.impl&%0.len.? $ TYPE%lib!tokens.SegmentId. s!) 0) 0 (let ((x$ (%Poly%lib!tokens.SegmentId. (vstd!set.impl&%0.choose.? $ TYPE%lib!tokens.SegmentId. s!)))) (vstd!math.max.? (I (lib!tokens.rec%segment_u_max.? (vstd!set.impl&%0.remove.? $ TYPE%lib!tokens.SegmentId. s! (Poly%lib!tokens.SegmentId. x$)) fuel%)) (I (lib!tokens.SegmentId./SegmentId/uniq (%Poly%lib!tokens.SegmentId. (Poly%lib!tokens.SegmentId. x$))))))))) :pattern ((lib!tokens.rec%segment_u_max.? s! (succ fuel%))))))
(assert (=> (fuel_bool fuel%lib!tokens.segment_u_max.) (forall ((s! Poly)) (! (=> (and (has_type s! (TYPE%vstd!set.Set. $ TYPE%lib!tokens.SegmentId.)) (vstd!set.impl&%0.finite.? $ TYPE%lib!tokens.SegmentId. s!)) (= (lib!tokens.segment_u_max.? s!) (lib!tokens.rec%segment_u_max.? s! (succ fuel_nat%lib!tokens.segment_u_max.)))) :pattern ((lib!tokens.segment_u_max.? s!))))))
(set-info :comment ";; Function-Axioms lib::tokens::segment_get_unused_uniq_field")
(assert (fuel_bool_default fuel%lib!tokens.segment_get_unused_uniq_field.))
(assert (=> (fuel_bool fuel%lib!tokens.segment_get_unused_uniq_field.) (forall ((s! Poly)) (! (= (lib!tokens.segment_get_unused_uniq_field.? s!) (Add (lib!tokens.segment_u_max.? s!) 1)) :pattern ((lib!tokens.segment_get_unused_uniq_field.? s!))))))
(set-info :comment ";; Function-Axioms lib::tokens::BlockId::get_slice_idx")
(assert (fuel_bool_default fuel%lib!tokens.impl&%1.get_slice_idx.))
(assert (=> (fuel_bool fuel%lib!tokens.impl&%1.get_slice_idx.) (forall ((page_id! Poly) (idx! Poly) (block_size! Poly)) (! (= (lib!tokens.impl&%1.get_slice_idx.? page_id! idx! block_size!) (nClip (Add (lib!tokens.PageId./PageId/idx (%Poly%lib!tokens.PageId. page_id!)) (EucDiv (Add (lib!layout.start_offset.? block_size!) (nClip (Mul (%I idx!) (%I block_size!)))) lib!config.SLICE_SIZE.?)))) :pattern ((lib!tokens.impl&%1.get_slice_idx.? page_id! idx! block_size!))))))
(assert (forall ((page_id! Poly) (idx! Poly) (block_size! Poly)) (! (=> (and (has_type page_id! TYPE%lib!tokens.PageId.) (has_type idx! NAT) (has_type block_size! NAT)) (<= 0 (lib!tokens.impl&%1.get_slice_idx.? page_id! idx! block_size!))) :pattern ((lib!tokens.impl&%1.get_slice_idx.? page_id! idx! block_size!)))))
(set-info :comment ";; Function-Axioms lib::tokens::BlockId::slice_idx_is_right")
(assert (fuel_bool_default fuel%lib!tokens.impl&%1.slice_idx_is_right.))
(assert (=> (fuel_bool fuel%lib!tokens.impl&%1.slice_idx_is_right.) (forall ((self! Poly)) (! (= (lib!tokens.impl&%1.slice_idx_is_right.? self!) (= (lib!tokens.BlockId./BlockId/slice_idx (%Poly%lib!tokens.BlockId. self!)) (lib!tokens.impl&%1.get_slice_idx.? (Poly%lib!tokens.PageId. (lib!tokens.BlockId./BlockId/page_id (%Poly%lib!tokens.BlockId. self!))) (I (lib!tokens.BlockId./BlockId/idx (%Poly%lib!tokens.BlockId. self!))) (I (lib!tokens.BlockId./BlockId/block_size (%Poly%lib!tokens.BlockId. self!)))))) :pattern ((lib!tokens.impl&%1.slice_idx_is_right.? self!))))))
(set-info :comment ";; Function-Axioms lib::tokens::BlockId::page_id_for_slice")
(assert (fuel_bool_default fuel%lib!tokens.impl&%1.page_id_for_slice.))
(assert (=> (fuel_bool fuel%lib!tokens.impl&%1.page_id_for_slice.) (forall ((self! Poly)) (! (= (lib!tokens.impl&%1.page_id_for_slice.? self!) (lib!tokens.PageId./PageId (%Poly%lib!tokens.SegmentId. (Poly%lib!tokens.SegmentId. (lib!tokens.PageId./PageId/segment_id (%Poly%lib!tokens.PageId. (Poly%lib!tokens.PageId. (lib!tokens.BlockId./BlockId/page_id (%Poly%lib!tokens.BlockId. self!))))))) (%I (I (lib!tokens.BlockId./BlockId/slice_idx (%Poly%lib!tokens.BlockId. self!)))))) :pattern ((lib!tokens.impl&%1.page_id_for_slice.? self!))))))
(assert (forall ((self! Poly)) (! (=> (has_type self! TYPE%lib!tokens.BlockId.) (has_type (Poly%lib!tokens.PageId. (lib!tokens.impl&%1.page_id_for_slice.? self!)) TYPE%lib!tokens.PageId.)) :pattern ((lib!tokens.impl&%1.page_id_for_slice.? self!)))))
(set-info :comment ";; Function-Axioms lib::tokens::PageId::range_from")
(assert (fuel_bool_default fuel%lib!tokens.impl&%0.range_from.))
(declare-fun %%lambda%%1 (lib!tokens.SegmentId. Int Int) %%Function%%)
(assert (forall ((%%hole%%0 lib!tokens.SegmentId.) (%%hole%%1 Int) (%%hole%%2 Int) (page_id$ Poly)) (! (= (%%apply%%0 (%%lambda%%1 %%hole%%0 %%hole%%1 %%hole%%2) page_id$) (B (and (= (lib!tokens.PageId./PageId/segment_id (%Poly%lib!tokens.PageId. page_id$)) %%hole%%0) (let ((tmp%%$ (lib!tokens.PageId./PageId/idx (%Poly%lib!tokens.PageId. page_id$)))) (and (<= %%hole%%1 tmp%%$) (< tmp%%$ %%hole%%2)))))) :pattern ((%%apply%%0 (%%lambda%%1 %%hole%%0 %%hole%%1 %%hole%%2) page_id$)))))
(assert (=> (fuel_bool fuel%lib!tokens.impl&%0.range_from.) (forall ((self! Poly) (lo! Poly) (hi! Poly)) (! (= (lib!tokens.impl&%0.range_from.? self! lo! hi!) (%Poly%vstd!set.Set<lib!tokens.PageId.>. (vstd!set.impl&%0.new.? $ TYPE%lib!tokens.PageId. $ (TYPE%fun%1. $ TYPE%lib!tokens.PageId. $ BOOL) (Poly%fun%1. (mk_fun (%%lambda%%1 (lib!tokens.PageId./PageId/segment_id (%Poly%lib!tokens.PageId. self!)) (Add (lib!tokens.PageId./PageId/idx (%Poly%lib!tokens.PageId. self!)) (%I lo!)) (Add (lib!tokens.PageId./PageId/idx (%Poly%lib!tokens.PageId. self!)) (%I hi!)))))))) :pattern ((lib!tokens.impl&%0.range_from.? self! lo! hi!))))))
(set-info :comment ";; Function-Axioms vstd::raw_ptr::impl&%4::view")
(assert (fuel_bool_default fuel%vstd!raw_ptr.impl&%4.view.))
(assert (=> (fuel_bool fuel%vstd!raw_ptr.impl&%4.view.) (forall ((T&. Dcr) (T& Type) (self! Poly)) (! (= (vstd!view.View.view.? (CONST_PTR $) (PTR T&. T&) self!) (vstd!view.View.view.? $ (PTR T&. T&) self!)) :pattern ((vstd!view.View.view.? (CONST_PTR $) (PTR T&. T&) self!))))))
(set-info :comment ";; Function-Axioms vstd::view::impl&%0::view")
(assert (fuel_bool_default fuel%vstd!view.impl&%0.view.))
(assert (=> (fuel_bool fuel%vstd!view.impl&%0.view.) (forall ((A&. Dcr) (A& Type) (self! Poly)) (! (=> (tr_bound%vstd!view.View. A&. A&) (= (vstd!view.View.view.? (REF A&.) A& self!) (vstd!view.View.view.? A&. A& self!))) :pattern ((vstd!view.View.view.? (REF A&.) A& self!))))))
(set-info :comment ";; Function-Axioms vstd::view::impl&%2::view")
(assert (fuel_bool_default fuel%vstd!view.impl&%2.view.))
(assert (=> (fuel_bool fuel%vstd!view.impl&%2.view.) (forall ((A&. Dcr) (A& Type) (self! Poly)) (! (=> (tr_bound%vstd!view.View. A&. A&) (= (vstd!view.View.view.? (BOX $ ALLOCATOR_GLOBAL A&.) A& self!) (vstd!view.View.view.? A&. A& self!))) :pattern ((vstd!view.View.view.? (BOX $ ALLOCATOR_GLOBAL A&.) A& self!))))))
(set-info :comment ";; Function-Axioms vstd::view::impl&%4::view")
(assert (fuel_bool_default fuel%vstd!view.impl&%4.view.))
(assert (=> (fuel_bool fuel%vstd!view.impl&%4.view.) (forall ((A&. Dcr) (A& Type) (self! Poly)) (! (=> (tr_bound%vstd!view.View. A&. A&) (= (vstd!view.View.view.? (RC $ ALLOCATOR_GLOBAL A&.) A& self!) (vstd!view.View.view.? A&. A& self!))) :pattern ((vstd!view.View.view.? (RC $ ALLOCATOR_GLOBAL A&.) A& self!))))))
(set-info :comment ";; Function-Axioms vstd::view::impl&%6::view")
(assert (fuel_bool_default fuel%vstd!view.impl&%6.view.))
(assert (=> (fuel_bool fuel%vstd!view.impl&%6.view.) (forall ((A&. Dcr) (A& Type) (self! Poly)) (! (=> (tr_bound%vstd!view.View. A&. A&) (= (vstd!view.View.view.? (ARC $ ALLOCATOR_GLOBAL A&.) A& self!) (vstd!view.View.view.? A&. A& self!))) :pattern ((vstd!view.View.view.? (ARC $ ALLOCATOR_GLOBAL A&.) A& self!))))))
(set-info :comment ";; Function-Axioms vstd::view::impl&%10::view")
(assert (fuel_bool_default fuel%vstd!view.impl&%10.view.))
(assert (=> (fuel_bool fuel%vstd!view.impl&%10.view.) (forall ((self! Poly)) (! (= (vstd!view.View.view.? $ TYPE%tuple%0. self!) self!) :pattern ((vstd!view.View.view.? $ TYPE%tuple%0. self!))))))
(set-info :comment ";; Function-Axioms vstd::view::impl&%12::view")
(assert (fuel_bool_default fuel%vstd!view.impl&%12.view.))
(assert (=> (fuel_bool fuel%vstd!view.impl&%12.view.) (forall ((self! Poly)) (! (= (vstd!view.View.view.? $ BOOL self!) self!) :pattern ((vstd!view.View.view.? $ BOOL self!))))))
(set-info :comment ";; Function-Axioms vstd::view::impl&%14::view")
(assert (fuel_bool_default fuel%vstd!view.impl&%14.view.))
(assert (=> (fuel_bool fuel%vstd!view.impl&%14.view.) (forall ((self! Poly)) (! (= (vstd!view.View.view.? $ (UINT 8) self!) self!) :pattern ((vstd!view.View.view.? $ (UINT 8) self!))))))
(set-info :comment ";; Function-Axioms vstd::view::impl&%16::view")
(assert (fuel_bool_default fuel%vstd!view.impl&%16.view.))
(assert (=> (fuel_bool fuel%vstd!view.impl&%16.view.) (forall ((self! Poly)) (! (= (vstd!view.View.view.? $ (UINT 16) self!) self!) :pattern ((vstd!view.View.view.? $ (UINT 16) self!))))))
(set-info :comment ";; Function-Axioms vstd::view::impl&%18::view")
(assert (fuel_bool_default fuel%vstd!view.impl&%18.view.))
(assert (=> (fuel_bool fuel%vstd!view.impl&%18.view.) (forall ((self! Poly)) (! (= (vstd!view.View.view.? $ (UINT 32) self!) self!) :pattern ((vstd!view.View.view.? $ (UINT 32) self!))))))
(set-info :comment ";; Function-Axioms vstd::view::impl&%20::view")
(assert (fuel_bool_default fuel%vstd!view.impl&%20.view.))
(assert (=> (fuel_bool fuel%vstd!view.impl&%20.view.) (forall ((self! Poly)) (! (= (vstd!view.View.view.? $ (UINT 64) self!) self!) :pattern ((vstd!view.View.view.? $ (UINT 64) self!))))))
(set-info :comment ";; Function-Axioms vstd::view::impl&%24::view")
(assert (fuel_bool_default fuel%vstd!view.impl&%24.view.))
(assert (=> (fuel_bool fuel%vstd!view.impl&%24.view.) (forall ((self! Poly)) (! (= (vstd!view.View.view.? $ (UINT SZ) self!) self!) :pattern ((vstd!view.View.view.? $ (UINT SZ) self!))))))
(set-info :comment ";; Function-Axioms vstd::view::impl&%32::view")
(assert (fuel_bool_default fuel%vstd!view.impl&%32.view.))
(assert (=> (fuel_bool fuel%vstd!view.impl&%32.view.) (forall ((self! Poly)) (! (= (vstd!view.View.view.? $ (SINT 64) self!) self!) :pattern ((vstd!view.View.view.? $ (SINT 64) self!))))))
(set-info :comment ";; Function-Axioms vstd::view::impl&%42::view")
(assert (fuel_bool_default fuel%vstd!view.impl&%42.view.))
(assert (=> (fuel_bool fuel%vstd!view.impl&%42.view.) (forall ((A0&. Dcr) (A0& Type) (A1&. Dcr) (A1& Type) (self! Poly)) (! (=> (and (tr_bound%vstd!view.View. A0&. A0&) (tr_bound%vstd!view.View. A1&. A1&)) (= (vstd!view.View.view.? $ (TYPE%tuple%2. A0&. A0& A1&. A1&) self!) (Poly%tuple%2. (tuple%2./tuple%2 (vstd!view.View.view.? A0&. A0& (tuple%2./tuple%2/0 (%Poly%tuple%2. self!))) (vstd!view.View.view.? A1&. A1& (tuple%2./tuple%2/1 (%Poly%tuple%2. self!))))))) :pattern ((vstd!view.View.view.? $ (TYPE%tuple%2. A0&. A0& A1&. A1&) self!))))))
(set-info :comment ";; Function-Axioms vstd::view::impl&%46::view")
(assert (fuel_bool_default fuel%vstd!view.impl&%46.view.))
(assert (=> (fuel_bool fuel%vstd!view.impl&%46.view.) (forall ((A0&. Dcr) (A0& Type) (A1&. Dcr) (A1& Type) (A2&. Dcr) (A2& Type) (A3&. Dcr) (A3& Type) (self! Poly)) (! (=> (and (tr_bound%vstd!view.View. A0&. A0&) (tr_bound%vstd!view.View. A1&. A1&) (tr_bound%vstd!view.View. A2&. A2&) (tr_bound%vstd!view.View. A3&. A3&)) (= (vstd!view.View.view.? $ (TYPE%tuple%4. A0&. A0& A1&. A1& A2&. A2& A3&. A3&) self!) (Poly%tuple%4. (tuple%4./tuple%4 (vstd!view.View.view.? A0&. A0& (tuple%4./tuple%4/0 (%Poly%tuple%4. self!))) (vstd!view.View.view.? A1&. A1& (tuple%4./tuple%4/1 (%Poly%tuple%4. self!))) (vstd!view.View.view.? A2&. A2& (tuple%4./tuple%4/2 (%Poly%tuple%4. self!))) (vstd!view.View.view.? A3&. A3& (tuple%4./tuple%4/3 (%Poly%tuple%4. self!))))))) :pattern ((vstd!view.View.view.? $ (TYPE%tuple%4. A0&. A0& A1&. A1& A2&. A2& A3&. A3&) self!))))))
(set-info :comment ";; Function-Axioms lib::tokens::BlockId::wf")
(assert (fuel_bool_default fuel%lib!tokens.impl&%1.wf.))
(assert (=> (fuel_bool fuel%lib!tokens.impl&%1.wf.) (forall ((self! Poly)) (! (= (lib!tokens.impl&%1.wf.? self!) (>= (lib!tokens.BlockId./BlockId/slice_idx (%Poly%lib!tokens.BlockId. self!)) (lib!tokens.PageId./PageId/idx (%Poly%lib!tokens.PageId. (Poly%lib!tokens.PageId. (lib!tokens.BlockId./BlockId/page_id (%Poly%lib!tokens.BlockId. self!))))))) :pattern ((lib!tokens.impl&%1.wf.? self!))))))
(set-info :comment ";; Function-Axioms lib::tokens::DelayState::to_int")
(assert (fuel_bool_default fuel%lib!tokens.impl&%2.to_int.))
(define-fun is-lib!tokens.DelayState./UseDelayedFree_ ((c lib!tokens.DelayState.)) Bool ((_ is lib!tokens.DelayState./UseDelayedFree) c))
(define-fun is-lib!tokens.DelayState./Freeing_ ((c lib!tokens.DelayState.)) Bool ((_ is lib!tokens.DelayState./Freeing) c))
(define-fun is-lib!tokens.DelayState./NoDelayedFree_ ((c lib!tokens.DelayState.)) Bool ((_ is lib!tokens.DelayState./NoDelayedFree) c))
(assert (=> (fuel_bool fuel%lib!tokens.impl&%2.to_int.) (forall ((self! Poly)) (! (= (lib!tokens.impl&%2.to_int.? self!) (ite (is-lib!tokens.DelayState./UseDelayedFree_ (%Poly%lib!tokens.DelayState. self!)) 0 (ite (is-lib!tokens.DelayState./Freeing_ (%Poly%lib!tokens.DelayState. self!)) 1 (ite (is-lib!tokens.DelayState./NoDelayedFree_ (%Poly%lib!tokens.DelayState. self!)) 2 3)))) :pattern ((lib!tokens.impl&%2.to_int.? self!))))))
(set-info :comment ";; Function-Axioms lib::tokens::DelayFreeingActor::arrow_0")
(assert (fuel_bool_default fuel%lib!tokens.impl&%3.arrow_0.))
(assert (=> (fuel_bool fuel%lib!tokens.impl&%3.arrow_0.) (forall ((self! Poly)) (! (= (lib!tokens.impl&%3.arrow_0.? self!) (lib!tokens.DelayFreeingActor./Heap/0 (%Poly%lib!tokens.DelayFreeingActor. self!))) :pattern ((lib!tokens.impl&%3.arrow_0.? self!))))))
(assert (forall ((self! Poly)) (! (=> (has_type self! TYPE%lib!tokens.DelayFreeingActor.) (has_type (Poly%lib!tokens.HeapId. (lib!tokens.impl&%3.arrow_0.? self!)) TYPE%lib!tokens.HeapId.)) :pattern ((lib!tokens.impl&%3.arrow_0.? self!)))))
(set-info :comment ";; Function-Axioms lib::tokens::DelayFreeingActor::arrow_2")
(assert (fuel_bool_default fuel%lib!tokens.impl&%3.arrow_2.))
(assert (=> (fuel_bool fuel%lib!tokens.impl&%3.arrow_2.) (forall ((self! Poly)) (! (= (lib!tokens.impl&%3.arrow_2.? self!) (lib!tokens.DelayFreeingActor./Heap/2 (%Poly%lib!tokens.DelayFreeingActor. self!))) :pattern ((lib!tokens.impl&%3.arrow_2.? self!))))))
(set-info :comment ";; Function-Axioms lib::tokens::DelayFreeingActor::arrow_1")
(assert (fuel_bool_default fuel%lib!tokens.impl&%3.arrow_1.))
(assert (=> (fuel_bool fuel%lib!tokens.impl&%3.arrow_1.) (forall ((self! Poly)) (! (= (lib!tokens.impl&%3.arrow_1.? self!) (lib!tokens.DelayFreeingActor./Heap/1 (%Poly%lib!tokens.DelayFreeingActor. self!))) :pattern ((lib!tokens.impl&%3.arrow_1.? self!))))))
(set-info :comment ";; Function-Axioms lib::tokens::DelayFreeingActor::arrow_Heap_0")
(assert (fuel_bool_default fuel%lib!tokens.impl&%3.arrow_Heap_0.))
(assert (=> (fuel_bool fuel%lib!tokens.impl&%3.arrow_Heap_0.) (forall ((self! Poly)) (! (= (lib!tokens.impl&%3.arrow_Heap_0.? self!) (lib!tokens.DelayFreeingActor./Heap/0 (%Poly%lib!tokens.DelayFreeingActor. self!))) :pattern ((lib!tokens.impl&%3.arrow_Heap_0.? self!))))))
(assert (forall ((self! Poly)) (! (=> (has_type self! TYPE%lib!tokens.DelayFreeingActor.) (has_type (Poly%lib!tokens.HeapId. (lib!tokens.impl&%3.arrow_Heap_0.? self!)) TYPE%lib!tokens.HeapId.)) :pattern ((lib!tokens.impl&%3.arrow_Heap_0.? self!)))))
(set-info :comment ";; Function-Axioms lib::tokens::DelayFreeingActor::arrow_Heap_1")
(assert (fuel_bool_default fuel%lib!tokens.impl&%3.arrow_Heap_1.))
(assert (=> (fuel_bool fuel%lib!tokens.impl&%3.arrow_Heap_1.) (forall ((self! Poly)) (! (= (lib!tokens.impl&%3.arrow_Heap_1.? self!) (lib!tokens.DelayFreeingActor./Heap/1 (%Poly%lib!tokens.DelayFreeingActor. self!))) :pattern ((lib!tokens.impl&%3.arrow_Heap_1.? self!))))))
(set-info :comment ";; Function-Axioms lib::tokens::DelayFreeingActor::arrow_Heap_2")
(assert (fuel_bool_default fuel%lib!tokens.impl&%3.arrow_Heap_2.))
(assert (=> (fuel_bool fuel%lib!tokens.impl&%3.arrow_Heap_2.) (forall ((self! Poly)) (! (= (lib!tokens.impl&%3.arrow_Heap_2.? self!) (lib!tokens.DelayFreeingActor./Heap/2 (%Poly%lib!tokens.DelayFreeingActor. self!))) :pattern ((lib!tokens.impl&%3.arrow_Heap_2.? self!))))))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type) (N&. Dcr) (N& Type)) (! (=> (uInv SZ (const_int N&)) (tr_bound%vstd!view.View. $ (ARRAY T&. T& N&. N&))) :pattern ((tr_bound%vstd!view.View. $ (ARRAY T&. T& N&. N&))))))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type) (N&. Dcr) (N& Type)) (! (=> (uInv SZ (const_int N&)) (tr_bound%vstd!array.ArrayAdditionalSpecFns. $ (ARRAY T&. T& N&. N&) T&. T&)) :pattern ((tr_bound%vstd!array.ArrayAdditionalSpecFns. $ (ARRAY T&. T& N&. N&) T&. T&)))))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type)) (! (tr_bound%vstd!view.View. $ (PTR T&. T&)) :pattern ((tr_bound%vstd!view.View. $ (PTR T&. T&))))))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type)) (! (tr_bound%vstd!view.View. (CONST_PTR $) (PTR T&. T&)) :pattern ((tr_bound%vstd!view.View. (CONST_PTR $) (PTR T&. T&))))))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type)) (! (tr_bound%vstd!view.View. $ (TYPE%vstd!raw_ptr.PointsTo. T&. T&)) :pattern ((tr_bound%vstd!view.View. $ (TYPE%vstd!raw_ptr.PointsTo. T&. T&))))))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type)) (! (tr_bound%vstd!view.View. $ (SLICE T&. T&)) :pattern ((tr_bound%vstd!view.View. $ (SLICE T&. T&))))))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((A&. Dcr) (A& Type)) (! (=> (tr_bound%vstd!view.View. A&. A&) (tr_bound%vstd!view.View. (REF A&.) A&)) :pattern ((tr_bound%vstd!view.View. (REF A&.) A&)))))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((A&. Dcr) (A& Type)) (! (=> (tr_bound%vstd!view.View. A&. A&) (tr_bound%vstd!view.View. (BOX $ ALLOCATOR_GLOBAL A&.) A&)) :pattern ((tr_bound%vstd!view.View. (BOX $ ALLOCATOR_GLOBAL A&.) A&)))))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((A&. Dcr) (A& Type)) (! (=> (tr_bound%vstd!view.View. A&. A&) (tr_bound%vstd!view.View. (RC $ ALLOCATOR_GLOBAL A&.) A&)) :pattern ((tr_bound%vstd!view.View. (RC $ ALLOCATOR_GLOBAL A&.) A&)))))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((A&. Dcr) (A& Type)) (! (=> (tr_bound%vstd!view.View. A&. A&) (tr_bound%vstd!view.View. (ARC $ ALLOCATOR_GLOBAL A&.) A&)) :pattern ((tr_bound%vstd!view.View. (ARC $ ALLOCATOR_GLOBAL A&.) A&)))))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%vstd!view.View. $ TYPE%tuple%0.))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%vstd!view.View. $ BOOL))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%vstd!view.View. $ (UINT 8)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%vstd!view.View. $ (UINT 16)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%vstd!view.View. $ (UINT 32)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%vstd!view.View. $ (UINT 64)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%vstd!view.View. $ (UINT SZ)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%vstd!view.View. $ (SINT 64)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((A0&. Dcr) (A0& Type) (A1&. Dcr) (A1& Type)) (! (=> (and (tr_bound%vstd!view.View. A0&. A0&) (tr_bound%vstd!view.View. A1&. A1&)) (tr_bound%vstd!view.View. $ (TYPE%tuple%2. A0&. A0& A1&. A1&))) :pattern ((tr_bound%vstd!view.View. $ (TYPE%tuple%2. A0&. A0& A1&. A1&))))))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((A0&. Dcr) (A0& Type) (A1&. Dcr) (A1& Type) (A2&. Dcr) (A2& Type) (A3&. Dcr) (A3& Type)) (! (=> (and (tr_bound%vstd!view.View. A0&. A0&) (tr_bound%vstd!view.View. A1&. A1&) (tr_bound%vstd!view.View. A2&. A2&) (tr_bound%vstd!view.View. A3&. A3&)) (tr_bound%vstd!view.View. $ (TYPE%tuple%4. A0&. A0& A1&. A1& A2&. A2& A3&. A3&))) :pattern ((tr_bound%vstd!view.View. $ (TYPE%tuple%4. A0&. A0& A1&. A1& A2&. A2& A3&. A3&))))))
(set-info :comment ";; Function-Specs lib::tokens::heap_u_max_not_in")
(declare-fun req%lib!tokens.heap_u_max_not_in. (vstd!set.Set<lib!tokens.HeapId.>.) Bool)
(declare-const %%global_location_label%%8 Bool)
(assert (forall ((s! vstd!set.Set<lib!tokens.HeapId.>.)) (! (= (req%lib!tokens.heap_u_max_not_in. s!) (=> %%global_location_label%%8 (vstd!set.impl&%0.finite.? $ TYPE%lib!tokens.HeapId. (Poly%vstd!set.Set<lib!tokens.HeapId.>. s!)))) :pattern ((req%lib!tokens.heap_u_max_not_in. s!)))))
(declare-fun ens%lib!tokens.heap_u_max_not_in. (vstd!set.Set<lib!tokens.HeapId.>.) Bool)
(assert (forall ((s! vstd!set.Set<lib!tokens.HeapId.>.)) (! (= (ens%lib!tokens.heap_u_max_not_in. s!) (forall ((id$ Poly)) (! (=> (has_type id$ TYPE%lib!tokens.HeapId.) (=> (vstd!set.impl&%0.contains.? $ TYPE%lib!tokens.HeapId. (Poly%vstd!set.Set<lib!tokens.HeapId.>. s!) id$) (< (lib!tokens.HeapId./HeapId/uniq (%Poly%lib!tokens.HeapId. id$)) (Add (lib!tokens.heap_u_max.? (Poly%vstd!set.Set<lib!tokens.HeapId.>. s!)) 1)))) :pattern ((vstd!set.impl&%0.contains.? $ TYPE%lib!tokens.HeapId. (Poly%vstd!set.Set<lib!tokens.HeapId.>. s!) id$))))) :pattern ((ens%lib!tokens.heap_u_max_not_in. s!)))))
(set-info :comment ";; Function-Def lib::tokens::heap_u_max_not_in")
(set-info :comment ";; tokens.rs:256:7: 256:43 (#0)")
(declare-const s! vstd!set.Set<lib!tokens.HeapId.>.)
(declare-const tmp%1 Bool)
(declare-const x@ lib!tokens.HeapId.)
(declare-const t@ vstd!set.Set<lib!tokens.HeapId.>.)
(declare-const decrease%init0 Int)
(assert fuel_defaults)
(assert (vstd!set.impl&%0.finite.? $ TYPE%lib!tokens.HeapId. (Poly%vstd!set.Set<lib!tokens.HeapId.>. s!)))
(declare-const %%switch_label%%0 Bool)
(set-info :comment ";; precondition not satisfied")
(declare-const %%location_label%%0 Bool)
(set-info :comment ";; assertion failed")
(declare-const %%location_label%%1 Bool)
(set-info :comment ";; could not prove termination")
(declare-const %%location_label%%2 Bool)
(set-info :comment ";; precondition not satisfied")
(declare-const %%location_label%%3 Bool)
(set-info :comment ";; postcondition not satisfied")
(declare-const %%location_label%%4 Bool)
(assert (not (=> (= decrease%init0 (vstd!set.impl&%0.len.? $ TYPE%lib!tokens.HeapId. (Poly%vstd!set.Set<lib!tokens.HeapId.>. s!))) (and (=> %%location_label%%0 (req%vstd!set_lib.lemma_set_empty_equivalency_len. $ TYPE%lib!tokens.HeapId. (Poly%vstd!set.Set<lib!tokens.HeapId.>. s!))) (=> (ens%vstd!set_lib.lemma_set_empty_equivalency_len. $ TYPE%lib!tokens.HeapId. (Poly%vstd!set.Set<lib!tokens.HeapId.>. s!)) (or (and (=> (= (vstd!set.impl&%0.len.? $ TYPE%lib!tokens.HeapId. (Poly%vstd!set.Set<lib!tokens.HeapId.>. s!)) 0) (=> (= tmp%1 (ext_eq false (TYPE%vstd!set.Set. $ TYPE%lib!tokens.HeapId.) (Poly%vstd!set.Set<lib!tokens.HeapId.>. s!) (vstd!set.impl&%0.empty.? $ TYPE%lib!tokens.HeapId.))) (and (=> %%location_label%%1 tmp%1) (=> tmp%1 %%switch_label%%0)))) (=> (not (= (vstd!set.impl&%0.len.? $ TYPE%lib!tokens.HeapId. (Poly%vstd!set.Set<lib!tokens.HeapId.>. s!)) 0)) (=> (= x@ (%Poly%lib!tokens.HeapId. (vstd!set.impl&%0.choose.? $ TYPE%lib!tokens.HeapId. (Poly%vstd!set.Set<lib!tokens.HeapId.>. s!)))) (=> (= t@ (%Poly%vstd!set.Set<lib!tokens.HeapId.>. (vstd!set.impl&%0.remove.? $ TYPE%lib!tokens.HeapId. (Poly%vstd!set.Set<lib!tokens.HeapId.>. s!) (Poly%lib!tokens.HeapId. x@)))) (and (=> %%location_label%%2 (check_decrease_int (let ((s!$0 t@)) (vstd!set.impl&%0.len.? $ TYPE%lib!tokens.HeapId. (Poly%vstd!set.Set<lib!tokens.HeapId.>. s!$0))) decrease%init0 false)) (and (=> %%location_label%%3 (req%lib!tokens.heap_u_max_not_in. t@)) (=> (ens%lib!tokens.heap_u_max_not_in. t@) %%switch_label%%0))))))) (and (not %%switch_label%%0) (=> %%location_label%%4 (forall ((id$ Poly)) (! (=> (has_type id$ TYPE%lib!tokens.HeapId.) (=> (vstd!set.impl&%0.contains.? $ TYPE%lib!tokens.HeapId. (Poly%vstd!set.Set<lib!tokens.HeapId.>. s!) id$) (< (lib!tokens.HeapId./HeapId/uniq (%Poly%lib!tokens.HeapId. id$)) (Add (lib!tokens.heap_u_max.? (Poly%vstd!set.Set<lib!tokens.HeapId.>. s!)) 1)))) :pattern ((vstd!set.impl&%0.contains.? $ TYPE%lib!tokens.HeapId. (Poly%vstd!set.Set<lib!tokens.HeapId.>. s!) id$))))))))))))
(check-sat)
(exit)
