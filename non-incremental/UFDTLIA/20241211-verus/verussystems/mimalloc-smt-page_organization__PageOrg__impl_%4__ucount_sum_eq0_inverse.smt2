(set-info :smt-lib-version 2.6)
(set-logic UFDTLIA)
(set-info :source |
Generated by: Amar Shah
Generated on: 2024-12-11
Generator: Verus
Application: Verification of Rust Program
Target solver: z3
Time limit: 10
Benchmarks generated by the Rust verifier Verus (https://verus-lang.github.io/verus/guide/) on the project Verus Systems (https://dl.acm.org/doi/10.1145/3694715.3695952) 
and processed using Mariposa (https://github.com/secure-foundations/mariposa).
|)
(set-info :license "https://creativecommons.org/licenses/by/4.0/")
(set-info :category "industrial")
(set-info :status unsat)
(set-option :auto_config false)
(set-option :smt.mbqi false)
(set-option :smt.case_split 3)
(set-option :smt.qi.eager_threshold 100.0)
(set-option :smt.delay_units true)
(set-option :smt.arith.solver 2)
(set-option :smt.arith.nl false)
(set-option :pi.enabled false)
(set-option :rewriter.sort_disjunctions false)
(set-info :comment ";; Prelude")
(set-info :comment ";; AIR prelude")
(declare-sort %%Function%% 0)
(declare-sort FuelId 0)
(declare-sort Fuel 0)
(declare-const zero Fuel)
(declare-fun succ (Fuel) Fuel)
(declare-fun fuel_bool (FuelId) Bool)
(declare-fun fuel_bool_default (FuelId) Bool)
(declare-const fuel_defaults Bool)
(assert (=> fuel_defaults (forall ((id FuelId)) (! (= (fuel_bool id) (fuel_bool_default id)) :pattern ((fuel_bool id)) ))))
(declare-datatypes ((fndef 0)) (((fndef_singleton ))))
(declare-sort Poly 0)
(declare-sort Height 0)
(declare-fun I (Int) Poly)
(declare-fun B (Bool) Poly)
(declare-fun F (fndef) Poly)
(declare-fun %I (Poly) Int)
(declare-fun %B (Poly) Bool)
(declare-fun %F (Poly) fndef)
(declare-sort Type 0)
(declare-const BOOL Type)
(declare-const INT Type)
(declare-const NAT Type)
(declare-const CHAR Type)
(declare-fun UINT (Int) Type)
(declare-fun SINT (Int) Type)
(declare-fun CONST_INT (Int) Type)
(declare-sort Dcr 0)
(declare-const $ Dcr)
(declare-fun REF (Dcr) Dcr)
(declare-fun MUT_REF (Dcr) Dcr)
(declare-fun BOX (Dcr Type Dcr) Dcr)
(declare-fun RC (Dcr Type Dcr) Dcr)
(declare-fun ARC (Dcr Type Dcr) Dcr)
(declare-fun GHOST (Dcr) Dcr)
(declare-fun TRACKED (Dcr) Dcr)
(declare-fun NEVER (Dcr) Dcr)
(declare-fun CONST_PTR (Dcr) Dcr)
(declare-fun ARRAY (Dcr Type Dcr Type) Type)
(declare-fun SLICE (Dcr Type) Type)
(declare-const STRSLICE Type)
(declare-const ALLOCATOR_GLOBAL Type)
(declare-fun PTR (Dcr Type) Type)
(declare-fun has_type (Poly Type) Bool)
(declare-fun as_type (Poly Type) Poly)
(declare-fun mk_fun (%%Function%%) %%Function%%)
(declare-fun const_int (Type) Int)
(assert (forall ((i Int)) (! (= i (const_int (CONST_INT i))) :pattern ((CONST_INT i)) )))
(assert (forall ((b Bool)) (! (has_type (B b) BOOL) :pattern ((has_type (B b) BOOL)) )))
(assert (forall ((x Poly) (t Type)) (! (and (has_type (as_type x t) t) (=> (has_type x t) (= x (as_type x t)))) :pattern ((as_type x t)) )))
(assert (forall ((x %%Function%%)) (! (= (mk_fun x) x) :pattern ((mk_fun x)) )))
(assert (forall ((x Bool)) (! (= x (%B (B x))) :pattern ((B x)) )))
(assert (forall ((x Int)) (! (= x (%I (I x))) :pattern ((I x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x BOOL) (= x (B (%B x)))) :pattern ((has_type x BOOL)) )))
(assert (forall ((x Poly)) (! (=> (has_type x INT) (= x (I (%I x)))) :pattern ((has_type x INT)) )))
(assert (forall ((x Poly)) (! (=> (has_type x NAT) (= x (I (%I x)))) :pattern ((has_type x NAT)) )))
(assert (forall ((bits Int) (x Poly)) (! (=> (has_type x (UINT bits)) (= x (I (%I x)))) :pattern ((has_type x (UINT bits))) )))
(assert (forall ((bits Int) (x Poly)) (! (=> (has_type x (SINT bits)) (= x (I (%I x)))) :pattern ((has_type x (SINT bits))) )))
(assert (forall ((x Poly)) (! (=> (has_type x CHAR) (= x (I (%I x)))) :pattern ((has_type x CHAR)) )))
(declare-fun ext_eq (Bool Type Poly Poly) Bool)
(assert (forall ((deep Bool) (t Type) (x Poly) (y Poly)) (! (= (= x y) (ext_eq deep t x y)) :pattern ((ext_eq deep t x y)) )))
(declare-const SZ Int)
(assert (= SZ 64))
(declare-fun uHi (Int) Int)
(declare-fun iLo (Int) Int)
(declare-fun iHi (Int) Int)
(assert (= (uHi 8) 256))
(assert (= (uHi 16) 65536))
(assert (= (uHi 32) 4294967296))
(assert (= (uHi 64) 18446744073709551616))
(assert (= (uHi 128) (+ 1 340282366920938463463374607431768211455)))
(assert (= (iLo 8) (- 128)))
(assert (= (iLo 16) (- 32768)))
(assert (= (iLo 32) (- 2147483648)))
(assert (= (iLo 64) (- 9223372036854775808)))
(assert (= (iLo 128) (- 170141183460469231731687303715884105728)))
(assert (= (iHi 8) 128))
(assert (= (iHi 16) 32768))
(assert (= (iHi 32) 2147483648))
(assert (= (iHi 64) 9223372036854775808))
(assert (= (iHi 128) 170141183460469231731687303715884105728))
(declare-fun nClip (Int) Int)
(declare-fun uClip (Int Int) Int)
(declare-fun iClip (Int Int) Int)
(declare-fun charClip (Int) Int)
(assert (forall ((i Int)) (! (and (<= 0 (nClip i)) (=> (<= 0 i) (= i (nClip i)))) :pattern ((nClip i)) )))
(assert (forall ((bits Int) (i Int)) (! (and (<= 0 (uClip bits i)) (< (uClip bits i) (uHi bits)) (=> (and (<= 0 i) (< i (uHi bits))) (= i (uClip bits i)))) :pattern ((uClip bits i)) )))
(assert (forall ((bits Int) (i Int)) (! (and (<= (iLo bits) (iClip bits i)) (< (iClip bits i) (iHi bits)) (=> (and (<= (iLo bits) i) (< i (iHi bits))) (= i (iClip bits i)))) :pattern ((iClip bits i)) )))
(assert (forall ((i Int)) (! (and (or (and (<= 0 (charClip i)) (<= (charClip i) 55295)) (and (<= 57344 (charClip i)) (<= (charClip i) 1114111))) (=> (or (and (<= 0 i) (<= i 55295)) (and (<= 57344 i) (<= i 1114111))) (= i (charClip i)))) :pattern ((charClip i)) )))
(declare-fun uInv (Int Int) Bool)
(declare-fun iInv (Int Int) Bool)
(declare-fun charInv (Int) Bool)
(assert (forall ((bits Int) (i Int)) (! (= (uInv bits i) (and (<= 0 i) (< i (uHi bits)))) :pattern ((uInv bits i)) )))
(assert (forall ((bits Int) (i Int)) (! (= (iInv bits i) (and (<= (iLo bits) i) (< i (iHi bits)))) :pattern ((iInv bits i)) )))
(assert (forall ((i Int)) (! (= (charInv i) (or (and (<= 0 i) (<= i 55295)) (and (<= 57344 i) (<= i 1114111)))) :pattern ((charInv i)) )))
(assert (forall ((x Int)) (! (has_type (I x) INT) :pattern ((has_type (I x) INT)) )))
(assert (forall ((x Int)) (! (=> (<= 0 x) (has_type (I x) NAT)) :pattern ((has_type (I x) NAT)) )))
(assert (forall ((bits Int) (x Int)) (! (=> (uInv bits x) (has_type (I x) (UINT bits))) :pattern ((has_type (I x) (UINT bits))) )))
(assert (forall ((bits Int) (x Int)) (! (=> (iInv bits x) (has_type (I x) (SINT bits))) :pattern ((has_type (I x) (SINT bits))) )))
(assert (forall ((x Int)) (! (=> (charInv x) (has_type (I x) CHAR)) :pattern ((has_type (I x) CHAR)) )))
(assert (forall ((x Poly)) (! (=> (has_type x NAT) (<= 0 (%I x))) :pattern ((has_type x NAT)) )))
(assert (forall ((bits Int) (x Poly)) (! (=> (has_type x (UINT bits)) (uInv bits (%I x))) :pattern ((has_type x (UINT bits))) )))
(assert (forall ((bits Int) (x Poly)) (! (=> (has_type x (SINT bits)) (iInv bits (%I x))) :pattern ((has_type x (SINT bits))) )))
(declare-fun Add (Int Int) Int)
(declare-fun Sub (Int Int) Int)
(assert (forall ((x Int) (y Int)) (! (= (Add x y) (+ x y)) :pattern ((Add x y)))))
(assert (forall ((x Int) (y Int)) (! (= (Sub x y) (- x y)) :pattern ((Sub x y)))))
(declare-fun bitxor (Poly Poly) Int)
(declare-fun bitand (Poly Poly) Int)
(declare-fun bitor (Poly Poly) Int)
(declare-fun bitshr (Poly Poly) Int)
(declare-fun bitshl (Poly Poly) Int)
(declare-fun bitnot (Poly) Int)
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (uInv bits (%I x)) (uInv bits (%I y))) (uInv bits (bitxor x y))) :pattern ((uClip bits (bitxor x y))) )))
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (iInv bits (%I x)) (iInv bits (%I y))) (iInv bits (bitxor x y))) :pattern ((iClip bits (bitxor x y))) )))
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (uInv bits (%I x)) (uInv bits (%I y))) (uInv bits (bitor x y))) :pattern ((uClip bits (bitor x y))) )))
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (iInv bits (%I x)) (iInv bits (%I y))) (iInv bits (bitor x y))) :pattern ((iClip bits (bitor x y))) )))
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (uInv bits (%I x)) (uInv bits (%I y))) (uInv bits (bitand x y))) :pattern ((uClip bits (bitand x y))) )))
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (iInv bits (%I x)) (iInv bits (%I y))) (iInv bits (bitand x y))) :pattern ((iClip bits (bitand x y))) )))
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (uInv bits (%I x)) (<= 0 (%I y))) (uInv bits (bitshr x y))) :pattern ((uClip bits (bitshr x y))) )))
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (iInv bits (%I x)) (<= 0 (%I y))) (iInv bits (bitshr x y))) :pattern ((iClip bits (bitshr x y))) )))
(declare-fun singular_mod (Int Int) Int)
(declare-fun closure_req (Type Dcr Type Poly Poly) Bool)
(declare-fun closure_ens (Type Dcr Type Poly Poly Poly) Bool)
(declare-fun height (Poly) Height)
(declare-fun height_lt (Height Height) Bool)
(declare-fun fun_from_recursive_field (Poly) Poly)
(declare-fun check_decrease_int (Int Int Bool) Bool)
(assert (forall ((cur Int) (prev Int) (otherwise Bool)) (! (= (check_decrease_int cur prev otherwise) (or (and (<= 0 cur) (< cur prev)) (and (= cur prev) otherwise))) :pattern ((check_decrease_int cur prev otherwise)) )))
(declare-fun check_decrease_height (Poly Poly Bool) Bool)
(assert (forall ((cur Poly) (prev Poly) (otherwise Bool)) (! (= (check_decrease_height cur prev otherwise) (or (height_lt (height cur) (height prev)) (and (= (height cur) (height prev)) otherwise))) :pattern ((check_decrease_height cur prev otherwise)) )))
(declare-fun partial-order (Height Height) Bool)
(assert (forall ((x Height)) (partial-order x x)))
(assert (forall ((x Height) (y Height)) (=> (and (partial-order x y) (partial-order y x)) (= x y))))
(assert (forall ((x Height) (y Height) (z Height)) (=> (and (partial-order x y) (partial-order y z)) (partial-order x z))))
(assert (forall ((x Height) (y Height)) (! (= (height_lt x y) (and (partial-order x y) (not (= x y)))) :pattern ((height_lt x y)))))
(set-info :comment ";; MODULE 'module page_organization::PageOrg, function lib::page_organization::PageOrg::State::ucount_sum_eq0_inverse'")
(set-info :comment ";; Fuel")
(declare-const fuel%vstd!map.impl&%0.spec_index. FuelId)
(declare-const fuel%vstd!map.axiom_map_index_decreases_finite. FuelId)
(declare-const fuel%vstd!map.axiom_map_index_decreases_infinite. FuelId)
(declare-const fuel%vstd!map.axiom_map_ext_equal. FuelId)
(declare-const fuel%vstd!map.axiom_map_ext_equal_deep. FuelId)
(declare-const fuel%vstd!seq.impl&%0.spec_index. FuelId)
(declare-const fuel%vstd!seq.axiom_seq_index_decreases. FuelId)
(declare-const fuel%vstd!seq.axiom_seq_ext_equal. FuelId)
(declare-const fuel%vstd!seq.axiom_seq_ext_equal_deep. FuelId)
(declare-const fuel%vstd!set.axiom_set_ext_equal. FuelId)
(declare-const fuel%vstd!set.axiom_set_ext_equal_deep. FuelId)
(declare-const fuel%lib!page_organization.PageOrg.impl&%4.ucount_sum. FuelId)
(declare-const fuel%lib!page_organization.PageOrg.impl&%4.one_count. FuelId)
(declare-const fuel%lib!page_organization.PageOrg.impl&%4.does_count. FuelId)
(declare-const fuel%vstd!array.group_array_axioms. FuelId)
(declare-const fuel%vstd!map.group_map_axioms. FuelId)
(declare-const fuel%vstd!multiset.group_multiset_axioms. FuelId)
(declare-const fuel%vstd!raw_ptr.group_raw_ptr_axioms. FuelId)
(declare-const fuel%vstd!seq.group_seq_axioms. FuelId)
(declare-const fuel%vstd!seq_lib.group_seq_lib_default. FuelId)
(declare-const fuel%vstd!set.group_set_axioms. FuelId)
(declare-const fuel%vstd!set_lib.group_set_lib_axioms. FuelId)
(declare-const fuel%vstd!slice.group_slice_axioms. FuelId)
(declare-const fuel%vstd!string.group_string_axioms. FuelId)
(declare-const fuel%vstd!std_specs.bits.group_bits_axioms. FuelId)
(declare-const fuel%vstd!std_specs.control_flow.group_control_flow_axioms. FuelId)
(declare-const fuel%vstd!std_specs.range.group_range_axioms. FuelId)
(declare-const fuel%vstd!std_specs.vec.group_vec_axioms. FuelId)
(declare-const fuel%vstd!group_vstd_default. FuelId)
(assert (distinct fuel%vstd!map.impl&%0.spec_index. fuel%vstd!map.axiom_map_index_decreases_finite. fuel%vstd!map.axiom_map_index_decreases_infinite. fuel%vstd!map.axiom_map_ext_equal. fuel%vstd!map.axiom_map_ext_equal_deep. fuel%vstd!seq.impl&%0.spec_index. fuel%vstd!seq.axiom_seq_index_decreases. fuel%vstd!seq.axiom_seq_ext_equal. fuel%vstd!seq.axiom_seq_ext_equal_deep. fuel%vstd!set.axiom_set_ext_equal. fuel%vstd!set.axiom_set_ext_equal_deep. fuel%lib!page_organization.PageOrg.impl&%4.ucount_sum. fuel%lib!page_organization.PageOrg.impl&%4.one_count. fuel%lib!page_organization.PageOrg.impl&%4.does_count. fuel%vstd!array.group_array_axioms. fuel%vstd!map.group_map_axioms. fuel%vstd!multiset.group_multiset_axioms. fuel%vstd!raw_ptr.group_raw_ptr_axioms. fuel%vstd!seq.group_seq_axioms. fuel%vstd!seq_lib.group_seq_lib_default. fuel%vstd!set.group_set_axioms. fuel%vstd!set_lib.group_set_lib_axioms. fuel%vstd!slice.group_slice_axioms. fuel%vstd!string.group_string_axioms. fuel%vstd!std_specs.bits.group_bits_axioms. fuel%vstd!std_specs.control_flow.group_control_flow_axioms. fuel%vstd!std_specs.range.group_range_axioms. fuel%vstd!std_specs.vec.group_vec_axioms. fuel%vstd!group_vstd_default.))
(assert (=> (fuel_bool_default fuel%vstd!map.group_map_axioms.) (and (fuel_bool_default fuel%vstd!map.axiom_map_index_decreases_finite.) (fuel_bool_default fuel%vstd!map.axiom_map_index_decreases_infinite.) (fuel_bool_default fuel%vstd!map.axiom_map_ext_equal.) (fuel_bool_default fuel%vstd!map.axiom_map_ext_equal_deep.))))
(assert (=> (fuel_bool_default fuel%vstd!seq.group_seq_axioms.) (and (fuel_bool_default fuel%vstd!seq.axiom_seq_index_decreases.) (fuel_bool_default fuel%vstd!seq.axiom_seq_ext_equal.) (fuel_bool_default fuel%vstd!seq.axiom_seq_ext_equal_deep.))))
(assert (=> (fuel_bool_default fuel%vstd!set.group_set_axioms.) (and (fuel_bool_default fuel%vstd!set.axiom_set_ext_equal.) (fuel_bool_default fuel%vstd!set.axiom_set_ext_equal_deep.))))
(assert (fuel_bool_default fuel%vstd!group_vstd_default.))
(assert (=> (fuel_bool_default fuel%vstd!group_vstd_default.) (and (fuel_bool_default fuel%vstd!seq.group_seq_axioms.) (fuel_bool_default fuel%vstd!seq_lib.group_seq_lib_default.) (fuel_bool_default fuel%vstd!map.group_map_axioms.) (fuel_bool_default fuel%vstd!set.group_set_axioms.) (fuel_bool_default fuel%vstd!set_lib.group_set_lib_axioms.) (fuel_bool_default fuel%vstd!std_specs.bits.group_bits_axioms.) (fuel_bool_default fuel%vstd!std_specs.control_flow.group_control_flow_axioms.) (fuel_bool_default fuel%vstd!std_specs.vec.group_vec_axioms.) (fuel_bool_default fuel%vstd!slice.group_slice_axioms.) (fuel_bool_default fuel%vstd!array.group_array_axioms.) (fuel_bool_default fuel%vstd!multiset.group_multiset_axioms.) (fuel_bool_default fuel%vstd!string.group_string_axioms.) (fuel_bool_default fuel%vstd!std_specs.range.group_range_axioms.) (fuel_bool_default fuel%vstd!raw_ptr.group_raw_ptr_axioms.))))
(set-info :comment ";; Datatypes")
(declare-sort vstd!map.Map<lib!tokens.PageId./lib!page_organization.PageData.>. 0)
(declare-sort vstd!map.Map<lib!tokens.SegmentId./lib!page_organization.SegmentData.>. 0)
(declare-sort vstd!raw_ptr.Provenance. 0)
(declare-sort vstd!seq.Seq<lib!page_organization.DlistHeader.>. 0)
(declare-sort vstd!seq.Seq<lib!tokens.PageId.>. 0)
(declare-sort vstd!seq.Seq<vstd!seq.Seq<lib!tokens.PageId.>.>. 0)
(declare-sort vstd!set.Set<lib!tokens.PageId.>. 0)
(declare-datatypes ((core!option.Option. 0) (lib!page_organization.PageOrg.State. 0) (lib!page_organization.PageOrg.Step. 0) (lib!page_organization.PageOrg.Config. 0) (lib!tokens.SegmentId. 0) (lib!tokens.PageId. 0) (lib!page_organization.DlistHeader. 0) (lib!page_organization.DlistEntry. 0) (lib!page_organization.PageHeaderKind. 0) (lib!page_organization.PageData. 0) (lib!page_organization.SegmentData. 0) (lib!page_organization.Popped. 0) (tuple%0. 0)) (((core!option.Option./None ) (core!option.Option./Some (core!option.Option./Some/?0 Poly))) ((lib!page_organization.PageOrg.State./State (lib!page_organization.PageOrg.State./State/?unused_dlist_headers vstd!seq.Seq<lib!page_organization.DlistHeader.>.) (lib!page_organization.PageOrg.State./State/?used_dlist_headers vstd!seq.Seq<lib!page_organization.DlistHeader.>.) (lib!page_organization.PageOrg.State./State/?pages vstd!map.Map<lib!tokens.PageId./lib!page_organization.PageData.>.) (lib!page_organization.PageOrg.State./State/?segments vstd!map.Map<lib!tokens.SegmentId./lib!page_organization.SegmentData.>.) (lib!page_organization.PageOrg.State./State/?popped lib!page_organization.Popped.) (lib!page_organization.PageOrg.State./State/?unused_lists vstd!seq.Seq<vstd!seq.Seq<lib!tokens.PageId.>.>.) (lib!page_organization.PageOrg.State./State/?used_lists vstd!seq.Seq<vstd!seq.Seq<lib!tokens.PageId.>.>.))) ((lib!page_organization.PageOrg.Step./take_page_from_unused_queue (lib!page_organization.PageOrg.Step./take_page_from_unused_queue/?0 lib!tokens.PageId.) (lib!page_organization.PageOrg.Step./take_page_from_unused_queue/?1 Int) (lib!page_organization.PageOrg.Step./take_page_from_unused_queue/?2 Int)) (lib!page_organization.PageOrg.Step./split_page (lib!page_organization.PageOrg.Step./split_page/?0 lib!tokens.PageId.) (lib!page_organization.PageOrg.Step./split_page/?1 Int) (lib!page_organization.PageOrg.Step./split_page/?2 Int) (lib!page_organization.PageOrg.Step./split_page/?3 Int)) (lib!page_organization.PageOrg.Step./create_segment (lib!page_organization.PageOrg.Step./create_segment/?0 lib!tokens.SegmentId.)) (lib!page_organization.PageOrg.Step./allocate_popped ) (lib!page_organization.PageOrg.Step./forget_about_first_page (lib!page_organization.PageOrg.Step./forget_about_first_page/?0 Int)) (lib!page_organization.PageOrg.Step./forget_about_first_page2 ) (lib!page_organization.PageOrg.Step./clear_ec ) (lib!page_organization.PageOrg.Step./free_to_unused_queue (lib!page_organization.PageOrg.Step./free_to_unused_queue/?0 Int)) (lib!page_organization.PageOrg.Step./set_range_to_used (lib!page_organization.PageOrg.Step./set_range_to_used/?0 lib!page_organization.PageHeaderKind.)) (lib!page_organization.PageOrg.Step./set_range_to_not_used ) (lib!page_organization.PageOrg.Step./into_used_list (lib!page_organization.PageOrg.Step./into_used_list/?0 Int)) (lib!page_organization.PageOrg.Step./into_used_list_back (lib!page_organization.PageOrg.Step./into_used_list_back/?0 Int)) (lib!page_organization.PageOrg.Step./out_of_used_list (lib!page_organization.PageOrg.Step./out_of_used_list/?0 lib!tokens.PageId.) (lib!page_organization.PageOrg.Step./out_of_used_list/?1 Int) (lib!page_organization.PageOrg.Step./out_of_used_list/?2 Int)) (lib!page_organization.PageOrg.Step./segment_freeing_start (lib!page_organization.PageOrg.Step./segment_freeing_start/?0 lib!tokens.SegmentId.)) (lib!page_organization.PageOrg.Step./segment_freeing_finish ) (lib!page_organization.PageOrg.Step./merge_with_after ) (lib!page_organization.PageOrg.Step./merge_with_before ) (lib!page_organization.PageOrg.Step./dummy_to_use_type_params (lib!page_organization.PageOrg.Step./dummy_to_use_type_params/?0 lib!page_organization.PageOrg.State.))) ((lib!page_organization.PageOrg.Config./initialize ) (lib!page_organization.PageOrg.Config./dummy_to_use_type_params (lib!page_organization.PageOrg.Config./dummy_to_use_type_params/?0 lib!page_organization.PageOrg.State.))) ((lib!tokens.SegmentId./SegmentId (lib!tokens.SegmentId./SegmentId/?id Int) (lib!tokens.SegmentId./SegmentId/?provenance vstd!raw_ptr.Provenance.) (lib!tokens.SegmentId./SegmentId/?uniq Int))) ((lib!tokens.PageId./PageId (lib!tokens.PageId./PageId/?segment_id lib!tokens.SegmentId.) (lib!tokens.PageId./PageId/?idx Int))) ((lib!page_organization.DlistHeader./DlistHeader (lib!page_organization.DlistHeader./DlistHeader/?first core!option.Option.) (lib!page_organization.DlistHeader./DlistHeader/?last core!option.Option.))) ((lib!page_organization.DlistEntry./DlistEntry (lib!page_organization.DlistEntry./DlistEntry/?prev core!option.Option.) (lib!page_organization.DlistEntry./DlistEntry/?next core!option.Option.))) ((lib!page_organization.PageHeaderKind./Normal (lib!page_organization.PageHeaderKind./Normal/?0 Int) (lib!page_organization.PageHeaderKind./Normal/?1 Int))) ((lib!page_organization.PageData./PageData (lib!page_organization.PageData./PageData/?dlist_entry core!option.Option.) (lib!page_organization.PageData./PageData/?count core!option.Option.) (lib!page_organization.PageData./PageData/?offset core!option.Option.) (lib!page_organization.PageData./PageData/?is_used Bool) (lib!page_organization.PageData./PageData/?full core!option.Option.) (lib!page_organization.PageData./PageData/?page_header_kind core!option.Option.))) ((lib!page_organization.SegmentData./SegmentData (lib!page_organization.SegmentData./SegmentData/?used Int))) ((lib!page_organization.Popped./No ) (lib!page_organization.Popped./Ready (lib!page_organization.Popped./Ready/?0 lib!tokens.PageId.) (lib!page_organization.Popped./Ready/?1 Bool)) (lib!page_organization.Popped./Used (lib!page_organization.Popped./Used/?0 lib!tokens.PageId.) (lib!page_organization.Popped./Used/?1 Bool)) (lib!page_organization.Popped./SegmentCreating (lib!page_organization.Popped./SegmentCreating/?0 lib!tokens.SegmentId.)) (lib!page_organization.Popped./VeryUnready (lib!page_organization.Popped./VeryUnready/?0 lib!tokens.SegmentId.) (lib!page_organization.Popped./VeryUnready/?1 Int) (lib!page_organization.Popped./VeryUnready/?2 Int) (lib!page_organization.Popped./VeryUnready/?3 Bool)) (lib!page_organization.Popped./SegmentFreeing (lib!page_organization.Popped./SegmentFreeing/?0 lib!tokens.SegmentId.) (lib!page_organization.Popped./SegmentFreeing/?1 Int)) (lib!page_organization.Popped./ExtraCount (lib!page_organization.Popped./ExtraCount/?0 lib!tokens.SegmentId.))) ((tuple%0./tuple%0 ))))
(declare-fun core!option.Option./Some/0 (core!option.Option.) Poly)
(declare-fun lib!page_organization.PageOrg.State./State/unused_dlist_headers (lib!page_organization.PageOrg.State.) vstd!seq.Seq<lib!page_organization.DlistHeader.>.)
(declare-fun lib!page_organization.PageOrg.State./State/used_dlist_headers (lib!page_organization.PageOrg.State.) vstd!seq.Seq<lib!page_organization.DlistHeader.>.)
(declare-fun lib!page_organization.PageOrg.State./State/pages (lib!page_organization.PageOrg.State.) vstd!map.Map<lib!tokens.PageId./lib!page_organization.PageData.>.)
(declare-fun lib!page_organization.PageOrg.State./State/segments (lib!page_organization.PageOrg.State.) vstd!map.Map<lib!tokens.SegmentId./lib!page_organization.SegmentData.>.)
(declare-fun lib!page_organization.PageOrg.State./State/popped (lib!page_organization.PageOrg.State.) lib!page_organization.Popped.)
(declare-fun lib!page_organization.PageOrg.State./State/unused_lists (lib!page_organization.PageOrg.State.) vstd!seq.Seq<vstd!seq.Seq<lib!tokens.PageId.>.>.)
(declare-fun lib!page_organization.PageOrg.State./State/used_lists (lib!page_organization.PageOrg.State.) vstd!seq.Seq<vstd!seq.Seq<lib!tokens.PageId.>.>.)
(declare-fun lib!page_organization.PageOrg.Step./take_page_from_unused_queue/0 (lib!page_organization.PageOrg.Step.) lib!tokens.PageId.)
(declare-fun lib!page_organization.PageOrg.Step./take_page_from_unused_queue/1 (lib!page_organization.PageOrg.Step.) Int)
(declare-fun lib!page_organization.PageOrg.Step./take_page_from_unused_queue/2 (lib!page_organization.PageOrg.Step.) Int)
(declare-fun lib!page_organization.PageOrg.Step./split_page/0 (lib!page_organization.PageOrg.Step.) lib!tokens.PageId.)
(declare-fun lib!page_organization.PageOrg.Step./split_page/1 (lib!page_organization.PageOrg.Step.) Int)
(declare-fun lib!page_organization.PageOrg.Step./split_page/2 (lib!page_organization.PageOrg.Step.) Int)
(declare-fun lib!page_organization.PageOrg.Step./split_page/3 (lib!page_organization.PageOrg.Step.) Int)
(declare-fun lib!page_organization.PageOrg.Step./create_segment/0 (lib!page_organization.PageOrg.Step.) lib!tokens.SegmentId.)
(declare-fun lib!page_organization.PageOrg.Step./forget_about_first_page/0 (lib!page_organization.PageOrg.Step.) Int)
(declare-fun lib!page_organization.PageOrg.Step./free_to_unused_queue/0 (lib!page_organization.PageOrg.Step.) Int)
(declare-fun lib!page_organization.PageOrg.Step./set_range_to_used/0 (lib!page_organization.PageOrg.Step.) lib!page_organization.PageHeaderKind.)
(declare-fun lib!page_organization.PageOrg.Step./into_used_list/0 (lib!page_organization.PageOrg.Step.) Int)
(declare-fun lib!page_organization.PageOrg.Step./into_used_list_back/0 (lib!page_organization.PageOrg.Step.) Int)
(declare-fun lib!page_organization.PageOrg.Step./out_of_used_list/0 (lib!page_organization.PageOrg.Step.) lib!tokens.PageId.)
(declare-fun lib!page_organization.PageOrg.Step./out_of_used_list/1 (lib!page_organization.PageOrg.Step.) Int)
(declare-fun lib!page_organization.PageOrg.Step./out_of_used_list/2 (lib!page_organization.PageOrg.Step.) Int)
(declare-fun lib!page_organization.PageOrg.Step./segment_freeing_start/0 (lib!page_organization.PageOrg.Step.) lib!tokens.SegmentId.)
(declare-fun lib!page_organization.PageOrg.Step./dummy_to_use_type_params/0 (lib!page_organization.PageOrg.Step.) lib!page_organization.PageOrg.State.)
(declare-fun lib!page_organization.PageOrg.Config./dummy_to_use_type_params/0 (lib!page_organization.PageOrg.Config.) lib!page_organization.PageOrg.State.)
(declare-fun lib!tokens.SegmentId./SegmentId/id (lib!tokens.SegmentId.) Int)
(declare-fun lib!tokens.SegmentId./SegmentId/provenance (lib!tokens.SegmentId.) vstd!raw_ptr.Provenance.)
(declare-fun lib!tokens.SegmentId./SegmentId/uniq (lib!tokens.SegmentId.) Int)
(declare-fun lib!tokens.PageId./PageId/segment_id (lib!tokens.PageId.) lib!tokens.SegmentId.)
(declare-fun lib!tokens.PageId./PageId/idx (lib!tokens.PageId.) Int)
(declare-fun lib!page_organization.DlistHeader./DlistHeader/first (lib!page_organization.DlistHeader.) core!option.Option.)
(declare-fun lib!page_organization.DlistHeader./DlistHeader/last (lib!page_organization.DlistHeader.) core!option.Option.)
(declare-fun lib!page_organization.DlistEntry./DlistEntry/prev (lib!page_organization.DlistEntry.) core!option.Option.)
(declare-fun lib!page_organization.DlistEntry./DlistEntry/next (lib!page_organization.DlistEntry.) core!option.Option.)
(declare-fun lib!page_organization.PageHeaderKind./Normal/0 (lib!page_organization.PageHeaderKind.) Int)
(declare-fun lib!page_organization.PageHeaderKind./Normal/1 (lib!page_organization.PageHeaderKind.) Int)
(declare-fun lib!page_organization.PageData./PageData/dlist_entry (lib!page_organization.PageData.) core!option.Option.)
(declare-fun lib!page_organization.PageData./PageData/count (lib!page_organization.PageData.) core!option.Option.)
(declare-fun lib!page_organization.PageData./PageData/offset (lib!page_organization.PageData.) core!option.Option.)
(declare-fun lib!page_organization.PageData./PageData/is_used (lib!page_organization.PageData.) Bool)
(declare-fun lib!page_organization.PageData./PageData/full (lib!page_organization.PageData.) core!option.Option.)
(declare-fun lib!page_organization.PageData./PageData/page_header_kind (lib!page_organization.PageData.) core!option.Option.)
(declare-fun lib!page_organization.SegmentData./SegmentData/used (lib!page_organization.SegmentData.) Int)
(declare-fun lib!page_organization.Popped./Ready/0 (lib!page_organization.Popped.) lib!tokens.PageId.)
(declare-fun lib!page_organization.Popped./Ready/1 (lib!page_organization.Popped.) Bool)
(declare-fun lib!page_organization.Popped./Used/0 (lib!page_organization.Popped.) lib!tokens.PageId.)
(declare-fun lib!page_organization.Popped./Used/1 (lib!page_organization.Popped.) Bool)
(declare-fun lib!page_organization.Popped./SegmentCreating/0 (lib!page_organization.Popped.) lib!tokens.SegmentId.)
(declare-fun lib!page_organization.Popped./VeryUnready/0 (lib!page_organization.Popped.) lib!tokens.SegmentId.)
(declare-fun lib!page_organization.Popped./VeryUnready/1 (lib!page_organization.Popped.) Int)
(declare-fun lib!page_organization.Popped./VeryUnready/2 (lib!page_organization.Popped.) Int)
(declare-fun lib!page_organization.Popped./VeryUnready/3 (lib!page_organization.Popped.) Bool)
(declare-fun lib!page_organization.Popped./SegmentFreeing/0 (lib!page_organization.Popped.) lib!tokens.SegmentId.)
(declare-fun lib!page_organization.Popped./SegmentFreeing/1 (lib!page_organization.Popped.) Int)
(declare-fun lib!page_organization.Popped./ExtraCount/0 (lib!page_organization.Popped.) lib!tokens.SegmentId.)
(declare-fun TYPE%core!option.Option. (Dcr Type) Type)
(declare-fun TYPE%vstd!map.Map. (Dcr Type Dcr Type) Type)
(declare-const TYPE%vstd!raw_ptr.Provenance. Type)
(declare-fun TYPE%vstd!seq.Seq. (Dcr Type) Type)
(declare-fun TYPE%vstd!set.Set. (Dcr Type) Type)
(declare-const TYPE%lib!page_organization.PageOrg.State. Type)
(declare-const TYPE%lib!page_organization.PageOrg.Step. Type)
(declare-const TYPE%lib!page_organization.PageOrg.Config. Type)
(declare-const TYPE%lib!tokens.SegmentId. Type)
(declare-const TYPE%lib!tokens.PageId. Type)
(declare-const TYPE%lib!page_organization.DlistHeader. Type)
(declare-const TYPE%lib!page_organization.DlistEntry. Type)
(declare-const TYPE%lib!page_organization.PageHeaderKind. Type)
(declare-const TYPE%lib!page_organization.PageData. Type)
(declare-const TYPE%lib!page_organization.SegmentData. Type)
(declare-const TYPE%lib!page_organization.Popped. Type)
(declare-const TYPE%tuple%0. Type)
(declare-fun Poly%vstd!map.Map<lib!tokens.PageId./lib!page_organization.PageData.>. (vstd!map.Map<lib!tokens.PageId./lib!page_organization.PageData.>.) Poly)
(declare-fun %Poly%vstd!map.Map<lib!tokens.PageId./lib!page_organization.PageData.>. (Poly) vstd!map.Map<lib!tokens.PageId./lib!page_organization.PageData.>.)
(declare-fun Poly%vstd!map.Map<lib!tokens.SegmentId./lib!page_organization.SegmentData.>. (vstd!map.Map<lib!tokens.SegmentId./lib!page_organization.SegmentData.>.) Poly)
(declare-fun %Poly%vstd!map.Map<lib!tokens.SegmentId./lib!page_organization.SegmentData.>. (Poly) vstd!map.Map<lib!tokens.SegmentId./lib!page_organization.SegmentData.>.)
(declare-fun Poly%vstd!raw_ptr.Provenance. (vstd!raw_ptr.Provenance.) Poly)
(declare-fun %Poly%vstd!raw_ptr.Provenance. (Poly) vstd!raw_ptr.Provenance.)
(declare-fun Poly%vstd!seq.Seq<lib!page_organization.DlistHeader.>. (vstd!seq.Seq<lib!page_organization.DlistHeader.>.) Poly)
(declare-fun %Poly%vstd!seq.Seq<lib!page_organization.DlistHeader.>. (Poly) vstd!seq.Seq<lib!page_organization.DlistHeader.>.)
(declare-fun Poly%vstd!seq.Seq<lib!tokens.PageId.>. (vstd!seq.Seq<lib!tokens.PageId.>.) Poly)
(declare-fun %Poly%vstd!seq.Seq<lib!tokens.PageId.>. (Poly) vstd!seq.Seq<lib!tokens.PageId.>.)
(declare-fun Poly%vstd!seq.Seq<vstd!seq.Seq<lib!tokens.PageId.>.>. (vstd!seq.Seq<vstd!seq.Seq<lib!tokens.PageId.>.>.) Poly)
(declare-fun %Poly%vstd!seq.Seq<vstd!seq.Seq<lib!tokens.PageId.>.>. (Poly) vstd!seq.Seq<vstd!seq.Seq<lib!tokens.PageId.>.>.)
(declare-fun Poly%vstd!set.Set<lib!tokens.PageId.>. (vstd!set.Set<lib!tokens.PageId.>.) Poly)
(declare-fun %Poly%vstd!set.Set<lib!tokens.PageId.>. (Poly) vstd!set.Set<lib!tokens.PageId.>.)
(declare-fun Poly%core!option.Option. (core!option.Option.) Poly)
(declare-fun %Poly%core!option.Option. (Poly) core!option.Option.)
(declare-fun Poly%lib!page_organization.PageOrg.State. (lib!page_organization.PageOrg.State.) Poly)
(declare-fun %Poly%lib!page_organization.PageOrg.State. (Poly) lib!page_organization.PageOrg.State.)
(declare-fun Poly%lib!page_organization.PageOrg.Step. (lib!page_organization.PageOrg.Step.) Poly)
(declare-fun %Poly%lib!page_organization.PageOrg.Step. (Poly) lib!page_organization.PageOrg.Step.)
(declare-fun Poly%lib!page_organization.PageOrg.Config. (lib!page_organization.PageOrg.Config.) Poly)
(declare-fun %Poly%lib!page_organization.PageOrg.Config. (Poly) lib!page_organization.PageOrg.Config.)
(declare-fun Poly%lib!tokens.SegmentId. (lib!tokens.SegmentId.) Poly)
(declare-fun %Poly%lib!tokens.SegmentId. (Poly) lib!tokens.SegmentId.)
(declare-fun Poly%lib!tokens.PageId. (lib!tokens.PageId.) Poly)
(declare-fun %Poly%lib!tokens.PageId. (Poly) lib!tokens.PageId.)
(declare-fun Poly%lib!page_organization.DlistHeader. (lib!page_organization.DlistHeader.) Poly)
(declare-fun %Poly%lib!page_organization.DlistHeader. (Poly) lib!page_organization.DlistHeader.)
(declare-fun Poly%lib!page_organization.DlistEntry. (lib!page_organization.DlistEntry.) Poly)
(declare-fun %Poly%lib!page_organization.DlistEntry. (Poly) lib!page_organization.DlistEntry.)
(declare-fun Poly%lib!page_organization.PageHeaderKind. (lib!page_organization.PageHeaderKind.) Poly)
(declare-fun %Poly%lib!page_organization.PageHeaderKind. (Poly) lib!page_organization.PageHeaderKind.)
(declare-fun Poly%lib!page_organization.PageData. (lib!page_organization.PageData.) Poly)
(declare-fun %Poly%lib!page_organization.PageData. (Poly) lib!page_organization.PageData.)
(declare-fun Poly%lib!page_organization.SegmentData. (lib!page_organization.SegmentData.) Poly)
(declare-fun %Poly%lib!page_organization.SegmentData. (Poly) lib!page_organization.SegmentData.)
(declare-fun Poly%lib!page_organization.Popped. (lib!page_organization.Popped.) Poly)
(declare-fun %Poly%lib!page_organization.Popped. (Poly) lib!page_organization.Popped.)
(declare-fun Poly%tuple%0. (tuple%0.) Poly)
(declare-fun %Poly%tuple%0. (Poly) tuple%0.)
(assert (forall ((x vstd!map.Map<lib!tokens.PageId./lib!page_organization.PageData.>.)) (! (= x (%Poly%vstd!map.Map<lib!tokens.PageId./lib!page_organization.PageData.>. (Poly%vstd!map.Map<lib!tokens.PageId./lib!page_organization.PageData.>. x))) :pattern ((Poly%vstd!map.Map<lib!tokens.PageId./lib!page_organization.PageData.>. x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x (TYPE%vstd!map.Map. $ TYPE%lib!tokens.PageId. $ TYPE%lib!page_organization.PageData.)) (= x (Poly%vstd!map.Map<lib!tokens.PageId./lib!page_organization.PageData.>. (%Poly%vstd!map.Map<lib!tokens.PageId./lib!page_organization.PageData.>. x)))) :pattern ((has_type x (TYPE%vstd!map.Map. $ TYPE%lib!tokens.PageId. $ TYPE%lib!page_organization.PageData.))) )))
(assert (forall ((x vstd!map.Map<lib!tokens.PageId./lib!page_organization.PageData.>.)) (! (has_type (Poly%vstd!map.Map<lib!tokens.PageId./lib!page_organization.PageData.>. x) (TYPE%vstd!map.Map. $ TYPE%lib!tokens.PageId. $ TYPE%lib!page_organization.PageData.)) :pattern ((has_type (Poly%vstd!map.Map<lib!tokens.PageId./lib!page_organization.PageData.>. x) (TYPE%vstd!map.Map. $ TYPE%lib!tokens.PageId. $ TYPE%lib!page_organization.PageData.))) )))
(assert (forall ((x vstd!map.Map<lib!tokens.SegmentId./lib!page_organization.SegmentData.>.)) (! (= x (%Poly%vstd!map.Map<lib!tokens.SegmentId./lib!page_organization.SegmentData.>. (Poly%vstd!map.Map<lib!tokens.SegmentId./lib!page_organization.SegmentData.>. x))) :pattern ((Poly%vstd!map.Map<lib!tokens.SegmentId./lib!page_organization.SegmentData.>. x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x (TYPE%vstd!map.Map. $ TYPE%lib!tokens.SegmentId. $ TYPE%lib!page_organization.SegmentData.)) (= x (Poly%vstd!map.Map<lib!tokens.SegmentId./lib!page_organization.SegmentData.>. (%Poly%vstd!map.Map<lib!tokens.SegmentId./lib!page_organization.SegmentData.>. x)))) :pattern ((has_type x (TYPE%vstd!map.Map. $ TYPE%lib!tokens.SegmentId. $ TYPE%lib!page_organization.SegmentData.))) )))
(assert (forall ((x vstd!map.Map<lib!tokens.SegmentId./lib!page_organization.SegmentData.>.)) (! (has_type (Poly%vstd!map.Map<lib!tokens.SegmentId./lib!page_organization.SegmentData.>. x) (TYPE%vstd!map.Map. $ TYPE%lib!tokens.SegmentId. $ TYPE%lib!page_organization.SegmentData.)) :pattern ((has_type (Poly%vstd!map.Map<lib!tokens.SegmentId./lib!page_organization.SegmentData.>. x) (TYPE%vstd!map.Map. $ TYPE%lib!tokens.SegmentId. $ TYPE%lib!page_organization.SegmentData.))) )))
(assert (forall ((x vstd!raw_ptr.Provenance.)) (! (= x (%Poly%vstd!raw_ptr.Provenance. (Poly%vstd!raw_ptr.Provenance. x))) :pattern ((Poly%vstd!raw_ptr.Provenance. x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%vstd!raw_ptr.Provenance.) (= x (Poly%vstd!raw_ptr.Provenance. (%Poly%vstd!raw_ptr.Provenance. x)))) :pattern ((has_type x TYPE%vstd!raw_ptr.Provenance.)) )))
(assert (forall ((x vstd!raw_ptr.Provenance.)) (! (has_type (Poly%vstd!raw_ptr.Provenance. x) TYPE%vstd!raw_ptr.Provenance.) :pattern ((has_type (Poly%vstd!raw_ptr.Provenance. x) TYPE%vstd!raw_ptr.Provenance.)) )))
(assert (forall ((x vstd!seq.Seq<lib!page_organization.DlistHeader.>.)) (! (= x (%Poly%vstd!seq.Seq<lib!page_organization.DlistHeader.>. (Poly%vstd!seq.Seq<lib!page_organization.DlistHeader.>. x))) :pattern ((Poly%vstd!seq.Seq<lib!page_organization.DlistHeader.>. x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x (TYPE%vstd!seq.Seq. $ TYPE%lib!page_organization.DlistHeader.)) (= x (Poly%vstd!seq.Seq<lib!page_organization.DlistHeader.>. (%Poly%vstd!seq.Seq<lib!page_organization.DlistHeader.>. x)))) :pattern ((has_type x (TYPE%vstd!seq.Seq. $ TYPE%lib!page_organization.DlistHeader.))) )))
(assert (forall ((x vstd!seq.Seq<lib!page_organization.DlistHeader.>.)) (! (has_type (Poly%vstd!seq.Seq<lib!page_organization.DlistHeader.>. x) (TYPE%vstd!seq.Seq. $ TYPE%lib!page_organization.DlistHeader.)) :pattern ((has_type (Poly%vstd!seq.Seq<lib!page_organization.DlistHeader.>. x) (TYPE%vstd!seq.Seq. $ TYPE%lib!page_organization.DlistHeader.))) )))
(assert (forall ((x vstd!seq.Seq<lib!tokens.PageId.>.)) (! (= x (%Poly%vstd!seq.Seq<lib!tokens.PageId.>. (Poly%vstd!seq.Seq<lib!tokens.PageId.>. x))) :pattern ((Poly%vstd!seq.Seq<lib!tokens.PageId.>. x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x (TYPE%vstd!seq.Seq. $ TYPE%lib!tokens.PageId.)) (= x (Poly%vstd!seq.Seq<lib!tokens.PageId.>. (%Poly%vstd!seq.Seq<lib!tokens.PageId.>. x)))) :pattern ((has_type x (TYPE%vstd!seq.Seq. $ TYPE%lib!tokens.PageId.))) )))
(assert (forall ((x vstd!seq.Seq<lib!tokens.PageId.>.)) (! (has_type (Poly%vstd!seq.Seq<lib!tokens.PageId.>. x) (TYPE%vstd!seq.Seq. $ TYPE%lib!tokens.PageId.)) :pattern ((has_type (Poly%vstd!seq.Seq<lib!tokens.PageId.>. x) (TYPE%vstd!seq.Seq. $ TYPE%lib!tokens.PageId.))) )))
(assert (forall ((x vstd!seq.Seq<vstd!seq.Seq<lib!tokens.PageId.>.>.)) (! (= x (%Poly%vstd!seq.Seq<vstd!seq.Seq<lib!tokens.PageId.>.>. (Poly%vstd!seq.Seq<vstd!seq.Seq<lib!tokens.PageId.>.>. x))) :pattern ((Poly%vstd!seq.Seq<vstd!seq.Seq<lib!tokens.PageId.>.>. x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ TYPE%lib!tokens.PageId.))) (= x (Poly%vstd!seq.Seq<vstd!seq.Seq<lib!tokens.PageId.>.>. (%Poly%vstd!seq.Seq<vstd!seq.Seq<lib!tokens.PageId.>.>. x)))) :pattern ((has_type x (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ TYPE%lib!tokens.PageId.)))) )))
(assert (forall ((x vstd!seq.Seq<vstd!seq.Seq<lib!tokens.PageId.>.>.)) (! (has_type (Poly%vstd!seq.Seq<vstd!seq.Seq<lib!tokens.PageId.>.>. x) (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ TYPE%lib!tokens.PageId.))) :pattern ((has_type (Poly%vstd!seq.Seq<vstd!seq.Seq<lib!tokens.PageId.>.>. x) (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ TYPE%lib!tokens.PageId.)))) )))
(assert (forall ((x vstd!set.Set<lib!tokens.PageId.>.)) (! (= x (%Poly%vstd!set.Set<lib!tokens.PageId.>. (Poly%vstd!set.Set<lib!tokens.PageId.>. x))) :pattern ((Poly%vstd!set.Set<lib!tokens.PageId.>. x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x (TYPE%vstd!set.Set. $ TYPE%lib!tokens.PageId.)) (= x (Poly%vstd!set.Set<lib!tokens.PageId.>. (%Poly%vstd!set.Set<lib!tokens.PageId.>. x)))) :pattern ((has_type x (TYPE%vstd!set.Set. $ TYPE%lib!tokens.PageId.))) )))
(assert (forall ((x vstd!set.Set<lib!tokens.PageId.>.)) (! (has_type (Poly%vstd!set.Set<lib!tokens.PageId.>. x) (TYPE%vstd!set.Set. $ TYPE%lib!tokens.PageId.)) :pattern ((has_type (Poly%vstd!set.Set<lib!tokens.PageId.>. x) (TYPE%vstd!set.Set. $ TYPE%lib!tokens.PageId.))) )))
(assert (forall ((x core!option.Option.)) (! (= x (%Poly%core!option.Option. (Poly%core!option.Option. x))) :pattern ((Poly%core!option.Option. x)) )))
(assert (forall ((V&. Dcr) (V& Type) (x Poly)) (! (=> (has_type x (TYPE%core!option.Option. V&. V&)) (= x (Poly%core!option.Option. (%Poly%core!option.Option. x)))) :pattern ((has_type x (TYPE%core!option.Option. V&. V&))) )))
(assert (forall ((V&. Dcr) (V& Type)) (! (has_type (Poly%core!option.Option. core!option.Option./None) (TYPE%core!option.Option. V&. V&)) :pattern ((has_type (Poly%core!option.Option. core!option.Option./None) (TYPE%core!option.Option. V&. V&))) )))
(assert (forall ((V&. Dcr) (V& Type) (_0! Poly)) (! (=> (has_type _0! V&) (has_type (Poly%core!option.Option. (core!option.Option./Some _0!)) (TYPE%core!option.Option. V&. V&))) :pattern ((has_type (Poly%core!option.Option. (core!option.Option./Some _0!)) (TYPE%core!option.Option. V&. V&))) )))
(assert (forall ((x core!option.Option.)) (! (= (core!option.Option./Some/0 x) (core!option.Option./Some/?0 x)) :pattern ((core!option.Option./Some/0 x)) )))
(assert (forall ((V&. Dcr) (V& Type) (x Poly)) (! (=> (has_type x (TYPE%core!option.Option. V&. V&)) (has_type (core!option.Option./Some/0 (%Poly%core!option.Option. x)) V&)) :pattern ((core!option.Option./Some/0 (%Poly%core!option.Option. x)) (has_type x (TYPE%core!option.Option. V&. V&))) )))
(define-fun is-core!option.Option./Some_ ((c core!option.Option.)) Bool ((_ is core!option.Option./Some) c))
(assert (forall ((x core!option.Option.)) (! (=> (is-core!option.Option./Some_ x) (height_lt (height (core!option.Option./Some/0 x)) (height (Poly%core!option.Option. x)))) :pattern ((height (core!option.Option./Some/0 x))) )))
(define-fun is-core!option.Option./None_ ((c core!option.Option.)) Bool ((_ is core!option.Option./None) c))
(assert (forall ((V&. Dcr) (V& Type) (deep Bool) (x Poly) (y Poly)) (! (=> (and (has_type x (TYPE%core!option.Option. V&. V&)) (has_type y (TYPE%core!option.Option. V&. V&)) (is-core!option.Option./None_ (%Poly%core!option.Option. x)) (is-core!option.Option./None_ (%Poly%core!option.Option. y))) (ext_eq deep (TYPE%core!option.Option. V&. V&) x y)) :pattern ((ext_eq deep (TYPE%core!option.Option. V&. V&) x y)) )))
(assert (forall ((V&. Dcr) (V& Type) (deep Bool) (x Poly) (y Poly)) (! (=> (and (has_type x (TYPE%core!option.Option. V&. V&)) (has_type y (TYPE%core!option.Option. V&. V&)) (is-core!option.Option./Some_ (%Poly%core!option.Option. x)) (is-core!option.Option./Some_ (%Poly%core!option.Option. y)) (ext_eq deep V& (core!option.Option./Some/0 (%Poly%core!option.Option. x)) (core!option.Option./Some/0 (%Poly%core!option.Option. y)))) (ext_eq deep (TYPE%core!option.Option. V&. V&) x y)) :pattern ((ext_eq deep (TYPE%core!option.Option. V&. V&) x y)) )))
(assert (forall ((x lib!page_organization.PageOrg.State.)) (! (= x (%Poly%lib!page_organization.PageOrg.State. (Poly%lib!page_organization.PageOrg.State. x))) :pattern ((Poly%lib!page_organization.PageOrg.State. x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!page_organization.PageOrg.State.) (= x (Poly%lib!page_organization.PageOrg.State. (%Poly%lib!page_organization.PageOrg.State. x)))) :pattern ((has_type x TYPE%lib!page_organization.PageOrg.State.)) )))
(assert (forall ((_unused_dlist_headers! vstd!seq.Seq<lib!page_organization.DlistHeader.>.) (_used_dlist_headers! vstd!seq.Seq<lib!page_organization.DlistHeader.>.) (_pages! vstd!map.Map<lib!tokens.PageId./lib!page_organization.PageData.>.) (_segments! vstd!map.Map<lib!tokens.SegmentId./lib!page_organization.SegmentData.>.) (_popped! lib!page_organization.Popped.) (_unused_lists! vstd!seq.Seq<vstd!seq.Seq<lib!tokens.PageId.>.>.) (_used_lists! vstd!seq.Seq<vstd!seq.Seq<lib!tokens.PageId.>.>.)) (! (=> (has_type (Poly%lib!page_organization.Popped. _popped!) TYPE%lib!page_organization.Popped.) (has_type (Poly%lib!page_organization.PageOrg.State. (lib!page_organization.PageOrg.State./State _unused_dlist_headers! _used_dlist_headers! _pages! _segments! _popped! _unused_lists! _used_lists!)) TYPE%lib!page_organization.PageOrg.State.)) :pattern ((has_type (Poly%lib!page_organization.PageOrg.State. (lib!page_organization.PageOrg.State./State _unused_dlist_headers! _used_dlist_headers! _pages! _segments! _popped! _unused_lists! _used_lists!)) TYPE%lib!page_organization.PageOrg.State.)) )))
(assert (forall ((x lib!page_organization.PageOrg.State.)) (! (= (lib!page_organization.PageOrg.State./State/unused_dlist_headers x) (lib!page_organization.PageOrg.State./State/?unused_dlist_headers x)) :pattern ((lib!page_organization.PageOrg.State./State/unused_dlist_headers x)) )))
(assert (forall ((x lib!page_organization.PageOrg.State.)) (! (= (lib!page_organization.PageOrg.State./State/used_dlist_headers x) (lib!page_organization.PageOrg.State./State/?used_dlist_headers x)) :pattern ((lib!page_organization.PageOrg.State./State/used_dlist_headers x)) )))
(assert (forall ((x lib!page_organization.PageOrg.State.)) (! (= (lib!page_organization.PageOrg.State./State/pages x) (lib!page_organization.PageOrg.State./State/?pages x)) :pattern ((lib!page_organization.PageOrg.State./State/pages x)) )))
(assert (forall ((x lib!page_organization.PageOrg.State.)) (! (= (lib!page_organization.PageOrg.State./State/segments x) (lib!page_organization.PageOrg.State./State/?segments x)) :pattern ((lib!page_organization.PageOrg.State./State/segments x)) )))
(assert (forall ((x lib!page_organization.PageOrg.State.)) (! (= (lib!page_organization.PageOrg.State./State/popped x) (lib!page_organization.PageOrg.State./State/?popped x)) :pattern ((lib!page_organization.PageOrg.State./State/popped x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!page_organization.PageOrg.State.) (has_type (Poly%lib!page_organization.Popped. (lib!page_organization.PageOrg.State./State/popped (%Poly%lib!page_organization.PageOrg.State. x))) TYPE%lib!page_organization.Popped.)) :pattern ((lib!page_organization.PageOrg.State./State/popped (%Poly%lib!page_organization.PageOrg.State. x)) (has_type x TYPE%lib!page_organization.PageOrg.State.)) )))
(assert (forall ((x lib!page_organization.PageOrg.State.)) (! (= (lib!page_organization.PageOrg.State./State/unused_lists x) (lib!page_organization.PageOrg.State./State/?unused_lists x)) :pattern ((lib!page_organization.PageOrg.State./State/unused_lists x)) )))
(assert (forall ((x lib!page_organization.PageOrg.State.)) (! (= (lib!page_organization.PageOrg.State./State/used_lists x) (lib!page_organization.PageOrg.State./State/?used_lists x)) :pattern ((lib!page_organization.PageOrg.State./State/used_lists x)) )))
(assert (forall ((x lib!page_organization.PageOrg.Step.)) (! (= x (%Poly%lib!page_organization.PageOrg.Step. (Poly%lib!page_organization.PageOrg.Step. x))) :pattern ((Poly%lib!page_organization.PageOrg.Step. x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!page_organization.PageOrg.Step.) (= x (Poly%lib!page_organization.PageOrg.Step. (%Poly%lib!page_organization.PageOrg.Step. x)))) :pattern ((has_type x TYPE%lib!page_organization.PageOrg.Step.)) )))
(assert (forall ((_0! lib!tokens.PageId.) (_1! Int) (_2! Int)) (! (=> (has_type (Poly%lib!tokens.PageId. _0!) TYPE%lib!tokens.PageId.) (has_type (Poly%lib!page_organization.PageOrg.Step. (lib!page_organization.PageOrg.Step./take_page_from_unused_queue _0! _1! _2!)) TYPE%lib!page_organization.PageOrg.Step.)) :pattern ((has_type (Poly%lib!page_organization.PageOrg.Step. (lib!page_organization.PageOrg.Step./take_page_from_unused_queue _0! _1! _2!)) TYPE%lib!page_organization.PageOrg.Step.)) )))
(assert (forall ((x lib!page_organization.PageOrg.Step.)) (! (= (lib!page_organization.PageOrg.Step./take_page_from_unused_queue/0 x) (lib!page_organization.PageOrg.Step./take_page_from_unused_queue/?0 x)) :pattern ((lib!page_organization.PageOrg.Step./take_page_from_unused_queue/0 x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!page_organization.PageOrg.Step.) (has_type (Poly%lib!tokens.PageId. (lib!page_organization.PageOrg.Step./take_page_from_unused_queue/0 (%Poly%lib!page_organization.PageOrg.Step. x))) TYPE%lib!tokens.PageId.)) :pattern ((lib!page_organization.PageOrg.Step./take_page_from_unused_queue/0 (%Poly%lib!page_organization.PageOrg.Step. x)) (has_type x TYPE%lib!page_organization.PageOrg.Step.)) )))
(assert (forall ((x lib!page_organization.PageOrg.Step.)) (! (= (lib!page_organization.PageOrg.Step./take_page_from_unused_queue/1 x) (lib!page_organization.PageOrg.Step./take_page_from_unused_queue/?1 x)) :pattern ((lib!page_organization.PageOrg.Step./take_page_from_unused_queue/1 x)) )))
(assert (forall ((x lib!page_organization.PageOrg.Step.)) (! (= (lib!page_organization.PageOrg.Step./take_page_from_unused_queue/2 x) (lib!page_organization.PageOrg.Step./take_page_from_unused_queue/?2 x)) :pattern ((lib!page_organization.PageOrg.Step./take_page_from_unused_queue/2 x)) )))
(assert (forall ((_0! lib!tokens.PageId.) (_1! Int) (_2! Int) (_3! Int)) (! (=> (has_type (Poly%lib!tokens.PageId. _0!) TYPE%lib!tokens.PageId.) (has_type (Poly%lib!page_organization.PageOrg.Step. (lib!page_organization.PageOrg.Step./split_page _0! _1! _2! _3!)) TYPE%lib!page_organization.PageOrg.Step.)) :pattern ((has_type (Poly%lib!page_organization.PageOrg.Step. (lib!page_organization.PageOrg.Step./split_page _0! _1! _2! _3!)) TYPE%lib!page_organization.PageOrg.Step.)) )))
(assert (forall ((x lib!page_organization.PageOrg.Step.)) (! (= (lib!page_organization.PageOrg.Step./split_page/0 x) (lib!page_organization.PageOrg.Step./split_page/?0 x)) :pattern ((lib!page_organization.PageOrg.Step./split_page/0 x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!page_organization.PageOrg.Step.) (has_type (Poly%lib!tokens.PageId. (lib!page_organization.PageOrg.Step./split_page/0 (%Poly%lib!page_organization.PageOrg.Step. x))) TYPE%lib!tokens.PageId.)) :pattern ((lib!page_organization.PageOrg.Step./split_page/0 (%Poly%lib!page_organization.PageOrg.Step. x)) (has_type x TYPE%lib!page_organization.PageOrg.Step.)) )))
(assert (forall ((x lib!page_organization.PageOrg.Step.)) (! (= (lib!page_organization.PageOrg.Step./split_page/1 x) (lib!page_organization.PageOrg.Step./split_page/?1 x)) :pattern ((lib!page_organization.PageOrg.Step./split_page/1 x)) )))
(assert (forall ((x lib!page_organization.PageOrg.Step.)) (! (= (lib!page_organization.PageOrg.Step./split_page/2 x) (lib!page_organization.PageOrg.Step./split_page/?2 x)) :pattern ((lib!page_organization.PageOrg.Step./split_page/2 x)) )))
(assert (forall ((x lib!page_organization.PageOrg.Step.)) (! (= (lib!page_organization.PageOrg.Step./split_page/3 x) (lib!page_organization.PageOrg.Step./split_page/?3 x)) :pattern ((lib!page_organization.PageOrg.Step./split_page/3 x)) )))
(assert (forall ((_0! lib!tokens.SegmentId.)) (! (=> (has_type (Poly%lib!tokens.SegmentId. _0!) TYPE%lib!tokens.SegmentId.) (has_type (Poly%lib!page_organization.PageOrg.Step. (lib!page_organization.PageOrg.Step./create_segment _0!)) TYPE%lib!page_organization.PageOrg.Step.)) :pattern ((has_type (Poly%lib!page_organization.PageOrg.Step. (lib!page_organization.PageOrg.Step./create_segment _0!)) TYPE%lib!page_organization.PageOrg.Step.)) )))
(assert (forall ((x lib!page_organization.PageOrg.Step.)) (! (= (lib!page_organization.PageOrg.Step./create_segment/0 x) (lib!page_organization.PageOrg.Step./create_segment/?0 x)) :pattern ((lib!page_organization.PageOrg.Step./create_segment/0 x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!page_organization.PageOrg.Step.) (has_type (Poly%lib!tokens.SegmentId. (lib!page_organization.PageOrg.Step./create_segment/0 (%Poly%lib!page_organization.PageOrg.Step. x))) TYPE%lib!tokens.SegmentId.)) :pattern ((lib!page_organization.PageOrg.Step./create_segment/0 (%Poly%lib!page_organization.PageOrg.Step. x)) (has_type x TYPE%lib!page_organization.PageOrg.Step.)) )))
(assert (has_type (Poly%lib!page_organization.PageOrg.Step. lib!page_organization.PageOrg.Step./allocate_popped) TYPE%lib!page_organization.PageOrg.Step.))
(assert (forall ((_0! Int)) (! (has_type (Poly%lib!page_organization.PageOrg.Step. (lib!page_organization.PageOrg.Step./forget_about_first_page _0!)) TYPE%lib!page_organization.PageOrg.Step.) :pattern ((has_type (Poly%lib!page_organization.PageOrg.Step. (lib!page_organization.PageOrg.Step./forget_about_first_page _0!)) TYPE%lib!page_organization.PageOrg.Step.)) )))
(assert (forall ((x lib!page_organization.PageOrg.Step.)) (! (= (lib!page_organization.PageOrg.Step./forget_about_first_page/0 x) (lib!page_organization.PageOrg.Step./forget_about_first_page/?0 x)) :pattern ((lib!page_organization.PageOrg.Step./forget_about_first_page/0 x)) )))
(assert (has_type (Poly%lib!page_organization.PageOrg.Step. lib!page_organization.PageOrg.Step./forget_about_first_page2) TYPE%lib!page_organization.PageOrg.Step.))
(assert (has_type (Poly%lib!page_organization.PageOrg.Step. lib!page_organization.PageOrg.Step./clear_ec) TYPE%lib!page_organization.PageOrg.Step.))
(assert (forall ((_0! Int)) (! (has_type (Poly%lib!page_organization.PageOrg.Step. (lib!page_organization.PageOrg.Step./free_to_unused_queue _0!)) TYPE%lib!page_organization.PageOrg.Step.) :pattern ((has_type (Poly%lib!page_organization.PageOrg.Step. (lib!page_organization.PageOrg.Step./free_to_unused_queue _0!)) TYPE%lib!page_organization.PageOrg.Step.)) )))
(assert (forall ((x lib!page_organization.PageOrg.Step.)) (! (= (lib!page_organization.PageOrg.Step./free_to_unused_queue/0 x) (lib!page_organization.PageOrg.Step./free_to_unused_queue/?0 x)) :pattern ((lib!page_organization.PageOrg.Step./free_to_unused_queue/0 x)) )))
(assert (forall ((_0! lib!page_organization.PageHeaderKind.)) (! (has_type (Poly%lib!page_organization.PageOrg.Step. (lib!page_organization.PageOrg.Step./set_range_to_used _0!)) TYPE%lib!page_organization.PageOrg.Step.) :pattern ((has_type (Poly%lib!page_organization.PageOrg.Step. (lib!page_organization.PageOrg.Step./set_range_to_used _0!)) TYPE%lib!page_organization.PageOrg.Step.)) )))
(assert (forall ((x lib!page_organization.PageOrg.Step.)) (! (= (lib!page_organization.PageOrg.Step./set_range_to_used/0 x) (lib!page_organization.PageOrg.Step./set_range_to_used/?0 x)) :pattern ((lib!page_organization.PageOrg.Step./set_range_to_used/0 x)) )))
(assert (has_type (Poly%lib!page_organization.PageOrg.Step. lib!page_organization.PageOrg.Step./set_range_to_not_used) TYPE%lib!page_organization.PageOrg.Step.))
(assert (forall ((_0! Int)) (! (has_type (Poly%lib!page_organization.PageOrg.Step. (lib!page_organization.PageOrg.Step./into_used_list _0!)) TYPE%lib!page_organization.PageOrg.Step.) :pattern ((has_type (Poly%lib!page_organization.PageOrg.Step. (lib!page_organization.PageOrg.Step./into_used_list _0!)) TYPE%lib!page_organization.PageOrg.Step.)) )))
(assert (forall ((x lib!page_organization.PageOrg.Step.)) (! (= (lib!page_organization.PageOrg.Step./into_used_list/0 x) (lib!page_organization.PageOrg.Step./into_used_list/?0 x)) :pattern ((lib!page_organization.PageOrg.Step./into_used_list/0 x)) )))
(assert (forall ((_0! Int)) (! (has_type (Poly%lib!page_organization.PageOrg.Step. (lib!page_organization.PageOrg.Step./into_used_list_back _0!)) TYPE%lib!page_organization.PageOrg.Step.) :pattern ((has_type (Poly%lib!page_organization.PageOrg.Step. (lib!page_organization.PageOrg.Step./into_used_list_back _0!)) TYPE%lib!page_organization.PageOrg.Step.)) )))
(assert (forall ((x lib!page_organization.PageOrg.Step.)) (! (= (lib!page_organization.PageOrg.Step./into_used_list_back/0 x) (lib!page_organization.PageOrg.Step./into_used_list_back/?0 x)) :pattern ((lib!page_organization.PageOrg.Step./into_used_list_back/0 x)) )))
(assert (forall ((_0! lib!tokens.PageId.) (_1! Int) (_2! Int)) (! (=> (has_type (Poly%lib!tokens.PageId. _0!) TYPE%lib!tokens.PageId.) (has_type (Poly%lib!page_organization.PageOrg.Step. (lib!page_organization.PageOrg.Step./out_of_used_list _0! _1! _2!)) TYPE%lib!page_organization.PageOrg.Step.)) :pattern ((has_type (Poly%lib!page_organization.PageOrg.Step. (lib!page_organization.PageOrg.Step./out_of_used_list _0! _1! _2!)) TYPE%lib!page_organization.PageOrg.Step.)) )))
(assert (forall ((x lib!page_organization.PageOrg.Step.)) (! (= (lib!page_organization.PageOrg.Step./out_of_used_list/0 x) (lib!page_organization.PageOrg.Step./out_of_used_list/?0 x)) :pattern ((lib!page_organization.PageOrg.Step./out_of_used_list/0 x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!page_organization.PageOrg.Step.) (has_type (Poly%lib!tokens.PageId. (lib!page_organization.PageOrg.Step./out_of_used_list/0 (%Poly%lib!page_organization.PageOrg.Step. x))) TYPE%lib!tokens.PageId.)) :pattern ((lib!page_organization.PageOrg.Step./out_of_used_list/0 (%Poly%lib!page_organization.PageOrg.Step. x)) (has_type x TYPE%lib!page_organization.PageOrg.Step.)) )))
(assert (forall ((x lib!page_organization.PageOrg.Step.)) (! (= (lib!page_organization.PageOrg.Step./out_of_used_list/1 x) (lib!page_organization.PageOrg.Step./out_of_used_list/?1 x)) :pattern ((lib!page_organization.PageOrg.Step./out_of_used_list/1 x)) )))
(assert (forall ((x lib!page_organization.PageOrg.Step.)) (! (= (lib!page_organization.PageOrg.Step./out_of_used_list/2 x) (lib!page_organization.PageOrg.Step./out_of_used_list/?2 x)) :pattern ((lib!page_organization.PageOrg.Step./out_of_used_list/2 x)) )))
(assert (forall ((_0! lib!tokens.SegmentId.)) (! (=> (has_type (Poly%lib!tokens.SegmentId. _0!) TYPE%lib!tokens.SegmentId.) (has_type (Poly%lib!page_organization.PageOrg.Step. (lib!page_organization.PageOrg.Step./segment_freeing_start _0!)) TYPE%lib!page_organization.PageOrg.Step.)) :pattern ((has_type (Poly%lib!page_organization.PageOrg.Step. (lib!page_organization.PageOrg.Step./segment_freeing_start _0!)) TYPE%lib!page_organization.PageOrg.Step.)) )))
(assert (forall ((x lib!page_organization.PageOrg.Step.)) (! (= (lib!page_organization.PageOrg.Step./segment_freeing_start/0 x) (lib!page_organization.PageOrg.Step./segment_freeing_start/?0 x)) :pattern ((lib!page_organization.PageOrg.Step./segment_freeing_start/0 x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!page_organization.PageOrg.Step.) (has_type (Poly%lib!tokens.SegmentId. (lib!page_organization.PageOrg.Step./segment_freeing_start/0 (%Poly%lib!page_organization.PageOrg.Step. x))) TYPE%lib!tokens.SegmentId.)) :pattern ((lib!page_organization.PageOrg.Step./segment_freeing_start/0 (%Poly%lib!page_organization.PageOrg.Step. x)) (has_type x TYPE%lib!page_organization.PageOrg.Step.)) )))
(assert (has_type (Poly%lib!page_organization.PageOrg.Step. lib!page_organization.PageOrg.Step./segment_freeing_finish) TYPE%lib!page_organization.PageOrg.Step.))
(assert (has_type (Poly%lib!page_organization.PageOrg.Step. lib!page_organization.PageOrg.Step./merge_with_after) TYPE%lib!page_organization.PageOrg.Step.))
(assert (has_type (Poly%lib!page_organization.PageOrg.Step. lib!page_organization.PageOrg.Step./merge_with_before) TYPE%lib!page_organization.PageOrg.Step.))
(assert (forall ((_0! lib!page_organization.PageOrg.State.)) (! (=> (has_type (Poly%lib!page_organization.PageOrg.State. _0!) TYPE%lib!page_organization.PageOrg.State.) (has_type (Poly%lib!page_organization.PageOrg.Step. (lib!page_organization.PageOrg.Step./dummy_to_use_type_params _0!)) TYPE%lib!page_organization.PageOrg.Step.)) :pattern ((has_type (Poly%lib!page_organization.PageOrg.Step. (lib!page_organization.PageOrg.Step./dummy_to_use_type_params _0!)) TYPE%lib!page_organization.PageOrg.Step.)) )))
(assert (forall ((x lib!page_organization.PageOrg.Step.)) (! (= (lib!page_organization.PageOrg.Step./dummy_to_use_type_params/0 x) (lib!page_organization.PageOrg.Step./dummy_to_use_type_params/?0 x)) :pattern ((lib!page_organization.PageOrg.Step./dummy_to_use_type_params/0 x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!page_organization.PageOrg.Step.) (has_type (Poly%lib!page_organization.PageOrg.State. (lib!page_organization.PageOrg.Step./dummy_to_use_type_params/0 (%Poly%lib!page_organization.PageOrg.Step. x))) TYPE%lib!page_organization.PageOrg.State.)) :pattern ((lib!page_organization.PageOrg.Step./dummy_to_use_type_params/0 (%Poly%lib!page_organization.PageOrg.Step. x)) (has_type x TYPE%lib!page_organization.PageOrg.Step.)) )))
(assert (forall ((x lib!page_organization.PageOrg.Config.)) (! (= x (%Poly%lib!page_organization.PageOrg.Config. (Poly%lib!page_organization.PageOrg.Config. x))) :pattern ((Poly%lib!page_organization.PageOrg.Config. x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!page_organization.PageOrg.Config.) (= x (Poly%lib!page_organization.PageOrg.Config. (%Poly%lib!page_organization.PageOrg.Config. x)))) :pattern ((has_type x TYPE%lib!page_organization.PageOrg.Config.)) )))
(assert (has_type (Poly%lib!page_organization.PageOrg.Config. lib!page_organization.PageOrg.Config./initialize) TYPE%lib!page_organization.PageOrg.Config.))
(assert (forall ((_0! lib!page_organization.PageOrg.State.)) (! (=> (has_type (Poly%lib!page_organization.PageOrg.State. _0!) TYPE%lib!page_organization.PageOrg.State.) (has_type (Poly%lib!page_organization.PageOrg.Config. (lib!page_organization.PageOrg.Config./dummy_to_use_type_params _0!)) TYPE%lib!page_organization.PageOrg.Config.)) :pattern ((has_type (Poly%lib!page_organization.PageOrg.Config. (lib!page_organization.PageOrg.Config./dummy_to_use_type_params _0!)) TYPE%lib!page_organization.PageOrg.Config.)) )))
(assert (forall ((x lib!page_organization.PageOrg.Config.)) (! (= (lib!page_organization.PageOrg.Config./dummy_to_use_type_params/0 x) (lib!page_organization.PageOrg.Config./dummy_to_use_type_params/?0 x)) :pattern ((lib!page_organization.PageOrg.Config./dummy_to_use_type_params/0 x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!page_organization.PageOrg.Config.) (has_type (Poly%lib!page_organization.PageOrg.State. (lib!page_organization.PageOrg.Config./dummy_to_use_type_params/0 (%Poly%lib!page_organization.PageOrg.Config. x))) TYPE%lib!page_organization.PageOrg.State.)) :pattern ((lib!page_organization.PageOrg.Config./dummy_to_use_type_params/0 (%Poly%lib!page_organization.PageOrg.Config. x)) (has_type x TYPE%lib!page_organization.PageOrg.Config.)) )))
(assert (forall ((x lib!tokens.SegmentId.)) (! (= x (%Poly%lib!tokens.SegmentId. (Poly%lib!tokens.SegmentId. x))) :pattern ((Poly%lib!tokens.SegmentId. x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!tokens.SegmentId.) (= x (Poly%lib!tokens.SegmentId. (%Poly%lib!tokens.SegmentId. x)))) :pattern ((has_type x TYPE%lib!tokens.SegmentId.)) )))
(assert (forall ((_id! Int) (_provenance! vstd!raw_ptr.Provenance.) (_uniq! Int)) (! (=> (<= 0 _id!) (has_type (Poly%lib!tokens.SegmentId. (lib!tokens.SegmentId./SegmentId _id! _provenance! _uniq!)) TYPE%lib!tokens.SegmentId.)) :pattern ((has_type (Poly%lib!tokens.SegmentId. (lib!tokens.SegmentId./SegmentId _id! _provenance! _uniq!)) TYPE%lib!tokens.SegmentId.)) )))
(assert (forall ((x lib!tokens.SegmentId.)) (! (= (lib!tokens.SegmentId./SegmentId/id x) (lib!tokens.SegmentId./SegmentId/?id x)) :pattern ((lib!tokens.SegmentId./SegmentId/id x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!tokens.SegmentId.) (<= 0 (lib!tokens.SegmentId./SegmentId/id (%Poly%lib!tokens.SegmentId. x)))) :pattern ((lib!tokens.SegmentId./SegmentId/id (%Poly%lib!tokens.SegmentId. x)) (has_type x TYPE%lib!tokens.SegmentId.)) )))
(assert (forall ((x lib!tokens.SegmentId.)) (! (= (lib!tokens.SegmentId./SegmentId/provenance x) (lib!tokens.SegmentId./SegmentId/?provenance x)) :pattern ((lib!tokens.SegmentId./SegmentId/provenance x)) )))
(assert (forall ((x lib!tokens.SegmentId.)) (! (= (lib!tokens.SegmentId./SegmentId/uniq x) (lib!tokens.SegmentId./SegmentId/?uniq x)) :pattern ((lib!tokens.SegmentId./SegmentId/uniq x)) )))
(assert (forall ((x lib!tokens.PageId.)) (! (= x (%Poly%lib!tokens.PageId. (Poly%lib!tokens.PageId. x))) :pattern ((Poly%lib!tokens.PageId. x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!tokens.PageId.) (= x (Poly%lib!tokens.PageId. (%Poly%lib!tokens.PageId. x)))) :pattern ((has_type x TYPE%lib!tokens.PageId.)) )))
(assert (forall ((_segment_id! lib!tokens.SegmentId.) (_idx! Int)) (! (=> (and (has_type (Poly%lib!tokens.SegmentId. _segment_id!) TYPE%lib!tokens.SegmentId.) (<= 0 _idx!)) (has_type (Poly%lib!tokens.PageId. (lib!tokens.PageId./PageId _segment_id! _idx!)) TYPE%lib!tokens.PageId.)) :pattern ((has_type (Poly%lib!tokens.PageId. (lib!tokens.PageId./PageId _segment_id! _idx!)) TYPE%lib!tokens.PageId.)) )))
(assert (forall ((x lib!tokens.PageId.)) (! (= (lib!tokens.PageId./PageId/segment_id x) (lib!tokens.PageId./PageId/?segment_id x)) :pattern ((lib!tokens.PageId./PageId/segment_id x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!tokens.PageId.) (has_type (Poly%lib!tokens.SegmentId. (lib!tokens.PageId./PageId/segment_id (%Poly%lib!tokens.PageId. x))) TYPE%lib!tokens.SegmentId.)) :pattern ((lib!tokens.PageId./PageId/segment_id (%Poly%lib!tokens.PageId. x)) (has_type x TYPE%lib!tokens.PageId.)) )))
(assert (forall ((x lib!tokens.PageId.)) (! (= (lib!tokens.PageId./PageId/idx x) (lib!tokens.PageId./PageId/?idx x)) :pattern ((lib!tokens.PageId./PageId/idx x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!tokens.PageId.) (<= 0 (lib!tokens.PageId./PageId/idx (%Poly%lib!tokens.PageId. x)))) :pattern ((lib!tokens.PageId./PageId/idx (%Poly%lib!tokens.PageId. x)) (has_type x TYPE%lib!tokens.PageId.)) )))
(assert (forall ((x lib!page_organization.DlistHeader.)) (! (= x (%Poly%lib!page_organization.DlistHeader. (Poly%lib!page_organization.DlistHeader. x))) :pattern ((Poly%lib!page_organization.DlistHeader. x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!page_organization.DlistHeader.) (= x (Poly%lib!page_organization.DlistHeader. (%Poly%lib!page_organization.DlistHeader. x)))) :pattern ((has_type x TYPE%lib!page_organization.DlistHeader.)) )))
(assert (forall ((_first! core!option.Option.) (_last! core!option.Option.)) (! (=> (and (has_type (Poly%core!option.Option. _first!) (TYPE%core!option.Option. $ TYPE%lib!tokens.PageId.)) (has_type (Poly%core!option.Option. _last!) (TYPE%core!option.Option. $ TYPE%lib!tokens.PageId.))) (has_type (Poly%lib!page_organization.DlistHeader. (lib!page_organization.DlistHeader./DlistHeader _first! _last!)) TYPE%lib!page_organization.DlistHeader.)) :pattern ((has_type (Poly%lib!page_organization.DlistHeader. (lib!page_organization.DlistHeader./DlistHeader _first! _last!)) TYPE%lib!page_organization.DlistHeader.)) )))
(assert (forall ((x lib!page_organization.DlistHeader.)) (! (= (lib!page_organization.DlistHeader./DlistHeader/first x) (lib!page_organization.DlistHeader./DlistHeader/?first x)) :pattern ((lib!page_organization.DlistHeader./DlistHeader/first x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!page_organization.DlistHeader.) (has_type (Poly%core!option.Option. (lib!page_organization.DlistHeader./DlistHeader/first (%Poly%lib!page_organization.DlistHeader. x))) (TYPE%core!option.Option. $ TYPE%lib!tokens.PageId.))) :pattern ((lib!page_organization.DlistHeader./DlistHeader/first (%Poly%lib!page_organization.DlistHeader. x)) (has_type x TYPE%lib!page_organization.DlistHeader.)) )))
(assert (forall ((x lib!page_organization.DlistHeader.)) (! (= (lib!page_organization.DlistHeader./DlistHeader/last x) (lib!page_organization.DlistHeader./DlistHeader/?last x)) :pattern ((lib!page_organization.DlistHeader./DlistHeader/last x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!page_organization.DlistHeader.) (has_type (Poly%core!option.Option. (lib!page_organization.DlistHeader./DlistHeader/last (%Poly%lib!page_organization.DlistHeader. x))) (TYPE%core!option.Option. $ TYPE%lib!tokens.PageId.))) :pattern ((lib!page_organization.DlistHeader./DlistHeader/last (%Poly%lib!page_organization.DlistHeader. x)) (has_type x TYPE%lib!page_organization.DlistHeader.)) )))
(assert (forall ((x lib!page_organization.DlistEntry.)) (! (= x (%Poly%lib!page_organization.DlistEntry. (Poly%lib!page_organization.DlistEntry. x))) :pattern ((Poly%lib!page_organization.DlistEntry. x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!page_organization.DlistEntry.) (= x (Poly%lib!page_organization.DlistEntry. (%Poly%lib!page_organization.DlistEntry. x)))) :pattern ((has_type x TYPE%lib!page_organization.DlistEntry.)) )))
(assert (forall ((_prev! core!option.Option.) (_next! core!option.Option.)) (! (=> (and (has_type (Poly%core!option.Option. _prev!) (TYPE%core!option.Option. $ TYPE%lib!tokens.PageId.)) (has_type (Poly%core!option.Option. _next!) (TYPE%core!option.Option. $ TYPE%lib!tokens.PageId.))) (has_type (Poly%lib!page_organization.DlistEntry. (lib!page_organization.DlistEntry./DlistEntry _prev! _next!)) TYPE%lib!page_organization.DlistEntry.)) :pattern ((has_type (Poly%lib!page_organization.DlistEntry. (lib!page_organization.DlistEntry./DlistEntry _prev! _next!)) TYPE%lib!page_organization.DlistEntry.)) )))
(assert (forall ((x lib!page_organization.DlistEntry.)) (! (= (lib!page_organization.DlistEntry./DlistEntry/prev x) (lib!page_organization.DlistEntry./DlistEntry/?prev x)) :pattern ((lib!page_organization.DlistEntry./DlistEntry/prev x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!page_organization.DlistEntry.) (has_type (Poly%core!option.Option. (lib!page_organization.DlistEntry./DlistEntry/prev (%Poly%lib!page_organization.DlistEntry. x))) (TYPE%core!option.Option. $ TYPE%lib!tokens.PageId.))) :pattern ((lib!page_organization.DlistEntry./DlistEntry/prev (%Poly%lib!page_organization.DlistEntry. x)) (has_type x TYPE%lib!page_organization.DlistEntry.)) )))
(assert (forall ((x lib!page_organization.DlistEntry.)) (! (= (lib!page_organization.DlistEntry./DlistEntry/next x) (lib!page_organization.DlistEntry./DlistEntry/?next x)) :pattern ((lib!page_organization.DlistEntry./DlistEntry/next x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!page_organization.DlistEntry.) (has_type (Poly%core!option.Option. (lib!page_organization.DlistEntry./DlistEntry/next (%Poly%lib!page_organization.DlistEntry. x))) (TYPE%core!option.Option. $ TYPE%lib!tokens.PageId.))) :pattern ((lib!page_organization.DlistEntry./DlistEntry/next (%Poly%lib!page_organization.DlistEntry. x)) (has_type x TYPE%lib!page_organization.DlistEntry.)) )))
(assert (forall ((x lib!page_organization.PageHeaderKind.)) (! (= x (%Poly%lib!page_organization.PageHeaderKind. (Poly%lib!page_organization.PageHeaderKind. x))) :pattern ((Poly%lib!page_organization.PageHeaderKind. x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!page_organization.PageHeaderKind.) (= x (Poly%lib!page_organization.PageHeaderKind. (%Poly%lib!page_organization.PageHeaderKind. x)))) :pattern ((has_type x TYPE%lib!page_organization.PageHeaderKind.)) )))
(assert (forall ((x lib!page_organization.PageHeaderKind.)) (! (= (lib!page_organization.PageHeaderKind./Normal/0 x) (lib!page_organization.PageHeaderKind./Normal/?0 x)) :pattern ((lib!page_organization.PageHeaderKind./Normal/0 x)) )))
(assert (forall ((x lib!page_organization.PageHeaderKind.)) (! (= (lib!page_organization.PageHeaderKind./Normal/1 x) (lib!page_organization.PageHeaderKind./Normal/?1 x)) :pattern ((lib!page_organization.PageHeaderKind./Normal/1 x)) )))
(assert (forall ((x lib!page_organization.PageHeaderKind.)) (! (has_type (Poly%lib!page_organization.PageHeaderKind. x) TYPE%lib!page_organization.PageHeaderKind.) :pattern ((has_type (Poly%lib!page_organization.PageHeaderKind. x) TYPE%lib!page_organization.PageHeaderKind.)) )))
(assert (forall ((x lib!page_organization.PageData.)) (! (= x (%Poly%lib!page_organization.PageData. (Poly%lib!page_organization.PageData. x))) :pattern ((Poly%lib!page_organization.PageData. x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!page_organization.PageData.) (= x (Poly%lib!page_organization.PageData. (%Poly%lib!page_organization.PageData. x)))) :pattern ((has_type x TYPE%lib!page_organization.PageData.)) )))
(assert (forall ((_dlist_entry! core!option.Option.) (_count! core!option.Option.) (_offset! core!option.Option.) (_is_used! Bool) (_full! core!option.Option.) (_page_header_kind! core!option.Option.)) (! (=> (and (has_type (Poly%core!option.Option. _dlist_entry!) (TYPE%core!option.Option. $ TYPE%lib!page_organization.DlistEntry.)) (has_type (Poly%core!option.Option. _count!) (TYPE%core!option.Option. $ NAT)) (has_type (Poly%core!option.Option. _offset!) (TYPE%core!option.Option. $ NAT)) (has_type (Poly%core!option.Option. _full!) (TYPE%core!option.Option. $ BOOL)) (has_type (Poly%core!option.Option. _page_header_kind!) (TYPE%core!option.Option. $ TYPE%lib!page_organization.PageHeaderKind.))) (has_type (Poly%lib!page_organization.PageData. (lib!page_organization.PageData./PageData _dlist_entry! _count! _offset! _is_used! _full! _page_header_kind!)) TYPE%lib!page_organization.PageData.)) :pattern ((has_type (Poly%lib!page_organization.PageData. (lib!page_organization.PageData./PageData _dlist_entry! _count! _offset! _is_used! _full! _page_header_kind!)) TYPE%lib!page_organization.PageData.)) )))
(assert (forall ((x lib!page_organization.PageData.)) (! (= (lib!page_organization.PageData./PageData/dlist_entry x) (lib!page_organization.PageData./PageData/?dlist_entry x)) :pattern ((lib!page_organization.PageData./PageData/dlist_entry x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!page_organization.PageData.) (has_type (Poly%core!option.Option. (lib!page_organization.PageData./PageData/dlist_entry (%Poly%lib!page_organization.PageData. x))) (TYPE%core!option.Option. $ TYPE%lib!page_organization.DlistEntry.))) :pattern ((lib!page_organization.PageData./PageData/dlist_entry (%Poly%lib!page_organization.PageData. x)) (has_type x TYPE%lib!page_organization.PageData.)) )))
(assert (forall ((x lib!page_organization.PageData.)) (! (= (lib!page_organization.PageData./PageData/count x) (lib!page_organization.PageData./PageData/?count x)) :pattern ((lib!page_organization.PageData./PageData/count x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!page_organization.PageData.) (has_type (Poly%core!option.Option. (lib!page_organization.PageData./PageData/count (%Poly%lib!page_organization.PageData. x))) (TYPE%core!option.Option. $ NAT))) :pattern ((lib!page_organization.PageData./PageData/count (%Poly%lib!page_organization.PageData. x)) (has_type x TYPE%lib!page_organization.PageData.)) )))
(assert (forall ((x lib!page_organization.PageData.)) (! (= (lib!page_organization.PageData./PageData/offset x) (lib!page_organization.PageData./PageData/?offset x)) :pattern ((lib!page_organization.PageData./PageData/offset x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!page_organization.PageData.) (has_type (Poly%core!option.Option. (lib!page_organization.PageData./PageData/offset (%Poly%lib!page_organization.PageData. x))) (TYPE%core!option.Option. $ NAT))) :pattern ((lib!page_organization.PageData./PageData/offset (%Poly%lib!page_organization.PageData. x)) (has_type x TYPE%lib!page_organization.PageData.)) )))
(assert (forall ((x lib!page_organization.PageData.)) (! (= (lib!page_organization.PageData./PageData/is_used x) (lib!page_organization.PageData./PageData/?is_used x)) :pattern ((lib!page_organization.PageData./PageData/is_used x)) )))
(assert (forall ((x lib!page_organization.PageData.)) (! (= (lib!page_organization.PageData./PageData/full x) (lib!page_organization.PageData./PageData/?full x)) :pattern ((lib!page_organization.PageData./PageData/full x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!page_organization.PageData.) (has_type (Poly%core!option.Option. (lib!page_organization.PageData./PageData/full (%Poly%lib!page_organization.PageData. x))) (TYPE%core!option.Option. $ BOOL))) :pattern ((lib!page_organization.PageData./PageData/full (%Poly%lib!page_organization.PageData. x)) (has_type x TYPE%lib!page_organization.PageData.)) )))
(assert (forall ((x lib!page_organization.PageData.)) (! (= (lib!page_organization.PageData./PageData/page_header_kind x) (lib!page_organization.PageData./PageData/?page_header_kind x)) :pattern ((lib!page_organization.PageData./PageData/page_header_kind x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!page_organization.PageData.) (has_type (Poly%core!option.Option. (lib!page_organization.PageData./PageData/page_header_kind (%Poly%lib!page_organization.PageData. x))) (TYPE%core!option.Option. $ TYPE%lib!page_organization.PageHeaderKind.))) :pattern ((lib!page_organization.PageData./PageData/page_header_kind (%Poly%lib!page_organization.PageData. x)) (has_type x TYPE%lib!page_organization.PageData.)) )))
(assert (forall ((x lib!page_organization.SegmentData.)) (! (= x (%Poly%lib!page_organization.SegmentData. (Poly%lib!page_organization.SegmentData. x))) :pattern ((Poly%lib!page_organization.SegmentData. x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!page_organization.SegmentData.) (= x (Poly%lib!page_organization.SegmentData. (%Poly%lib!page_organization.SegmentData. x)))) :pattern ((has_type x TYPE%lib!page_organization.SegmentData.)) )))
(assert (forall ((x lib!page_organization.SegmentData.)) (! (= (lib!page_organization.SegmentData./SegmentData/used x) (lib!page_organization.SegmentData./SegmentData/?used x)) :pattern ((lib!page_organization.SegmentData./SegmentData/used x)) )))
(assert (forall ((x lib!page_organization.SegmentData.)) (! (has_type (Poly%lib!page_organization.SegmentData. x) TYPE%lib!page_organization.SegmentData.) :pattern ((has_type (Poly%lib!page_organization.SegmentData. x) TYPE%lib!page_organization.SegmentData.)) )))
(assert (forall ((x lib!page_organization.Popped.)) (! (= x (%Poly%lib!page_organization.Popped. (Poly%lib!page_organization.Popped. x))) :pattern ((Poly%lib!page_organization.Popped. x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!page_organization.Popped.) (= x (Poly%lib!page_organization.Popped. (%Poly%lib!page_organization.Popped. x)))) :pattern ((has_type x TYPE%lib!page_organization.Popped.)) )))
(assert (has_type (Poly%lib!page_organization.Popped. lib!page_organization.Popped./No) TYPE%lib!page_organization.Popped.))
(assert (forall ((_0! lib!tokens.PageId.) (_1! Bool)) (! (=> (has_type (Poly%lib!tokens.PageId. _0!) TYPE%lib!tokens.PageId.) (has_type (Poly%lib!page_organization.Popped. (lib!page_organization.Popped./Ready _0! _1!)) TYPE%lib!page_organization.Popped.)) :pattern ((has_type (Poly%lib!page_organization.Popped. (lib!page_organization.Popped./Ready _0! _1!)) TYPE%lib!page_organization.Popped.)) )))
(assert (forall ((x lib!page_organization.Popped.)) (! (= (lib!page_organization.Popped./Ready/0 x) (lib!page_organization.Popped./Ready/?0 x)) :pattern ((lib!page_organization.Popped./Ready/0 x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!page_organization.Popped.) (has_type (Poly%lib!tokens.PageId. (lib!page_organization.Popped./Ready/0 (%Poly%lib!page_organization.Popped. x))) TYPE%lib!tokens.PageId.)) :pattern ((lib!page_organization.Popped./Ready/0 (%Poly%lib!page_organization.Popped. x)) (has_type x TYPE%lib!page_organization.Popped.)) )))
(assert (forall ((x lib!page_organization.Popped.)) (! (= (lib!page_organization.Popped./Ready/1 x) (lib!page_organization.Popped./Ready/?1 x)) :pattern ((lib!page_organization.Popped./Ready/1 x)) )))
(assert (forall ((_0! lib!tokens.PageId.) (_1! Bool)) (! (=> (has_type (Poly%lib!tokens.PageId. _0!) TYPE%lib!tokens.PageId.) (has_type (Poly%lib!page_organization.Popped. (lib!page_organization.Popped./Used _0! _1!)) TYPE%lib!page_organization.Popped.)) :pattern ((has_type (Poly%lib!page_organization.Popped. (lib!page_organization.Popped./Used _0! _1!)) TYPE%lib!page_organization.Popped.)) )))
(assert (forall ((x lib!page_organization.Popped.)) (! (= (lib!page_organization.Popped./Used/0 x) (lib!page_organization.Popped./Used/?0 x)) :pattern ((lib!page_organization.Popped./Used/0 x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!page_organization.Popped.) (has_type (Poly%lib!tokens.PageId. (lib!page_organization.Popped./Used/0 (%Poly%lib!page_organization.Popped. x))) TYPE%lib!tokens.PageId.)) :pattern ((lib!page_organization.Popped./Used/0 (%Poly%lib!page_organization.Popped. x)) (has_type x TYPE%lib!page_organization.Popped.)) )))
(assert (forall ((x lib!page_organization.Popped.)) (! (= (lib!page_organization.Popped./Used/1 x) (lib!page_organization.Popped./Used/?1 x)) :pattern ((lib!page_organization.Popped./Used/1 x)) )))
(assert (forall ((_0! lib!tokens.SegmentId.)) (! (=> (has_type (Poly%lib!tokens.SegmentId. _0!) TYPE%lib!tokens.SegmentId.) (has_type (Poly%lib!page_organization.Popped. (lib!page_organization.Popped./SegmentCreating _0!)) TYPE%lib!page_organization.Popped.)) :pattern ((has_type (Poly%lib!page_organization.Popped. (lib!page_organization.Popped./SegmentCreating _0!)) TYPE%lib!page_organization.Popped.)) )))
(assert (forall ((x lib!page_organization.Popped.)) (! (= (lib!page_organization.Popped./SegmentCreating/0 x) (lib!page_organization.Popped./SegmentCreating/?0 x)) :pattern ((lib!page_organization.Popped./SegmentCreating/0 x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!page_organization.Popped.) (has_type (Poly%lib!tokens.SegmentId. (lib!page_organization.Popped./SegmentCreating/0 (%Poly%lib!page_organization.Popped. x))) TYPE%lib!tokens.SegmentId.)) :pattern ((lib!page_organization.Popped./SegmentCreating/0 (%Poly%lib!page_organization.Popped. x)) (has_type x TYPE%lib!page_organization.Popped.)) )))
(assert (forall ((_0! lib!tokens.SegmentId.) (_1! Int) (_2! Int) (_3! Bool)) (! (=> (has_type (Poly%lib!tokens.SegmentId. _0!) TYPE%lib!tokens.SegmentId.) (has_type (Poly%lib!page_organization.Popped. (lib!page_organization.Popped./VeryUnready _0! _1! _2! _3!)) TYPE%lib!page_organization.Popped.)) :pattern ((has_type (Poly%lib!page_organization.Popped. (lib!page_organization.Popped./VeryUnready _0! _1! _2! _3!)) TYPE%lib!page_organization.Popped.)) )))
(assert (forall ((x lib!page_organization.Popped.)) (! (= (lib!page_organization.Popped./VeryUnready/0 x) (lib!page_organization.Popped./VeryUnready/?0 x)) :pattern ((lib!page_organization.Popped./VeryUnready/0 x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!page_organization.Popped.) (has_type (Poly%lib!tokens.SegmentId. (lib!page_organization.Popped./VeryUnready/0 (%Poly%lib!page_organization.Popped. x))) TYPE%lib!tokens.SegmentId.)) :pattern ((lib!page_organization.Popped./VeryUnready/0 (%Poly%lib!page_organization.Popped. x)) (has_type x TYPE%lib!page_organization.Popped.)) )))
(assert (forall ((x lib!page_organization.Popped.)) (! (= (lib!page_organization.Popped./VeryUnready/1 x) (lib!page_organization.Popped./VeryUnready/?1 x)) :pattern ((lib!page_organization.Popped./VeryUnready/1 x)) )))
(assert (forall ((x lib!page_organization.Popped.)) (! (= (lib!page_organization.Popped./VeryUnready/2 x) (lib!page_organization.Popped./VeryUnready/?2 x)) :pattern ((lib!page_organization.Popped./VeryUnready/2 x)) )))
(assert (forall ((x lib!page_organization.Popped.)) (! (= (lib!page_organization.Popped./VeryUnready/3 x) (lib!page_organization.Popped./VeryUnready/?3 x)) :pattern ((lib!page_organization.Popped./VeryUnready/3 x)) )))
(assert (forall ((_0! lib!tokens.SegmentId.) (_1! Int)) (! (=> (has_type (Poly%lib!tokens.SegmentId. _0!) TYPE%lib!tokens.SegmentId.) (has_type (Poly%lib!page_organization.Popped. (lib!page_organization.Popped./SegmentFreeing _0! _1!)) TYPE%lib!page_organization.Popped.)) :pattern ((has_type (Poly%lib!page_organization.Popped. (lib!page_organization.Popped./SegmentFreeing _0! _1!)) TYPE%lib!page_organization.Popped.)) )))
(assert (forall ((x lib!page_organization.Popped.)) (! (= (lib!page_organization.Popped./SegmentFreeing/0 x) (lib!page_organization.Popped./SegmentFreeing/?0 x)) :pattern ((lib!page_organization.Popped./SegmentFreeing/0 x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!page_organization.Popped.) (has_type (Poly%lib!tokens.SegmentId. (lib!page_organization.Popped./SegmentFreeing/0 (%Poly%lib!page_organization.Popped. x))) TYPE%lib!tokens.SegmentId.)) :pattern ((lib!page_organization.Popped./SegmentFreeing/0 (%Poly%lib!page_organization.Popped. x)) (has_type x TYPE%lib!page_organization.Popped.)) )))
(assert (forall ((x lib!page_organization.Popped.)) (! (= (lib!page_organization.Popped./SegmentFreeing/1 x) (lib!page_organization.Popped./SegmentFreeing/?1 x)) :pattern ((lib!page_organization.Popped./SegmentFreeing/1 x)) )))
(assert (forall ((_0! lib!tokens.SegmentId.)) (! (=> (has_type (Poly%lib!tokens.SegmentId. _0!) TYPE%lib!tokens.SegmentId.) (has_type (Poly%lib!page_organization.Popped. (lib!page_organization.Popped./ExtraCount _0!)) TYPE%lib!page_organization.Popped.)) :pattern ((has_type (Poly%lib!page_organization.Popped. (lib!page_organization.Popped./ExtraCount _0!)) TYPE%lib!page_organization.Popped.)) )))
(assert (forall ((x lib!page_organization.Popped.)) (! (= (lib!page_organization.Popped./ExtraCount/0 x) (lib!page_organization.Popped./ExtraCount/?0 x)) :pattern ((lib!page_organization.Popped./ExtraCount/0 x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!page_organization.Popped.) (has_type (Poly%lib!tokens.SegmentId. (lib!page_organization.Popped./ExtraCount/0 (%Poly%lib!page_organization.Popped. x))) TYPE%lib!tokens.SegmentId.)) :pattern ((lib!page_organization.Popped./ExtraCount/0 (%Poly%lib!page_organization.Popped. x)) (has_type x TYPE%lib!page_organization.Popped.)) )))
(assert (forall ((x tuple%0.)) (! (= x (%Poly%tuple%0. (Poly%tuple%0. x))) :pattern ((Poly%tuple%0. x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%tuple%0.) (= x (Poly%tuple%0. (%Poly%tuple%0. x)))) :pattern ((has_type x TYPE%tuple%0.)) )))
(assert (forall ((x tuple%0.)) (! (has_type (Poly%tuple%0. x) TYPE%tuple%0.) :pattern ((has_type (Poly%tuple%0. x) TYPE%tuple%0.)) )))
(set-info :comment ";; Function-Decl vstd::seq::Seq::len")
(declare-fun vstd!seq.Seq.len.? (Dcr Type Poly) Int)
(set-info :comment ";; Function-Decl vstd::seq::Seq::index")
(declare-fun vstd!seq.Seq.index.? (Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::seq::impl&%0::spec_index")
(declare-fun vstd!seq.impl&%0.spec_index.? (Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::map::impl&%0::dom")
(declare-fun vstd!map.impl&%0.dom.? (Dcr Type Dcr Type Poly) Poly)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::contains")
(declare-fun vstd!set.impl&%0.contains.? (Dcr Type Poly Poly) Bool)
(set-info :comment ";; Function-Decl vstd::map::impl&%0::index")
(declare-fun vstd!map.impl&%0.index.? (Dcr Type Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::map::impl&%0::spec_index")
(declare-fun vstd!map.impl&%0.spec_index.? (Dcr Type Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::finite")
(declare-fun vstd!set.impl&%0.finite.? (Dcr Type Poly) Bool)
(set-info :comment ";; Function-Decl lib::page_organization::PageOrg::State::does_count")
(declare-fun lib!page_organization.PageOrg.impl&%4.does_count.? (Poly Poly) Bool)
(set-info :comment ";; Function-Decl lib::page_organization::PageOrg::State::one_count")
(declare-fun lib!page_organization.PageOrg.impl&%4.one_count.? (Poly Poly) Int)
(set-info :comment ";; Function-Decl lib::page_organization::PageOrg::State::ucount_sum")
(declare-fun lib!page_organization.PageOrg.impl&%4.ucount_sum.? (Poly Poly Poly) Int)
(declare-fun lib!page_organization.PageOrg.impl&%4.rec%ucount_sum.? (Poly Poly Poly Fuel) Int)
(set-info :comment ";; Function-Axioms vstd::seq::Seq::len")
(assert (forall ((A&. Dcr) (A& Type) (self! Poly)) (! (=> (has_type self! (TYPE%vstd!seq.Seq. A&. A&)) (<= 0 (vstd!seq.Seq.len.? A&. A& self!))) :pattern ((vstd!seq.Seq.len.? A&. A& self!)) )))
(set-info :comment ";; Function-Specs vstd::seq::Seq::index")
(declare-fun req%vstd!seq.Seq.index. (Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%0 Bool)
(assert (forall ((A&. Dcr) (A& Type) (self! Poly) (i! Poly)) (! (= (req%vstd!seq.Seq.index. A&. A& self! i!) (=> %%global_location_label%%0 (and (<= 0 (%I i!)) (< (%I i!) (vstd!seq.Seq.len.? A&. A& self!))))) :pattern ((req%vstd!seq.Seq.index. A&. A& self! i!)) )))
(set-info :comment ";; Function-Axioms vstd::seq::Seq::index")
(assert (forall ((A&. Dcr) (A& Type) (self! Poly) (i! Poly)) (! (=> (and (has_type self! (TYPE%vstd!seq.Seq. A&. A&)) (has_type i! INT)) (has_type (vstd!seq.Seq.index.? A&. A& self! i!) A&)) :pattern ((vstd!seq.Seq.index.? A&. A& self! i!)) )))
(set-info :comment ";; Function-Specs vstd::seq::impl&%0::spec_index")
(declare-fun req%vstd!seq.impl&%0.spec_index. (Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%1 Bool)
(assert (forall ((A&. Dcr) (A& Type) (self! Poly) (i! Poly)) (! (= (req%vstd!seq.impl&%0.spec_index. A&. A& self! i!) (=> %%global_location_label%%1 (and (<= 0 (%I i!)) (< (%I i!) (vstd!seq.Seq.len.? A&. A& self!))))) :pattern ((req%vstd!seq.impl&%0.spec_index. A&. A& self! i!)) )))
(set-info :comment ";; Function-Axioms vstd::seq::impl&%0::spec_index")
(assert (fuel_bool_default fuel%vstd!seq.impl&%0.spec_index.))
(assert (=> (fuel_bool fuel%vstd!seq.impl&%0.spec_index.) (forall ((A&. Dcr) (A& Type) (self! Poly) (i! Poly)) (! (= (vstd!seq.impl&%0.spec_index.? A&. A& self! i!) (vstd!seq.Seq.index.? A&. A& self! i!)) :pattern ((vstd!seq.impl&%0.spec_index.? A&. A& self! i!)) ))))
(assert (forall ((A&. Dcr) (A& Type) (self! Poly) (i! Poly)) (! (=> (and (has_type self! (TYPE%vstd!seq.Seq. A&. A&)) (has_type i! INT)) (has_type (vstd!seq.impl&%0.spec_index.? A&. A& self! i!) A&)) :pattern ((vstd!seq.impl&%0.spec_index.? A&. A& self! i!)) )))
(set-info :comment ";; Function-Axioms vstd::map::impl&%0::dom")
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self! Poly)) (! (=> (has_type self! (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type (vstd!map.impl&%0.dom.? K&. K& V&. V& self!) (TYPE%vstd!set.Set. K&. K&))) :pattern ((vstd!map.impl&%0.dom.? K&. K& V&. V& self!)) )))
(set-info :comment ";; Function-Specs vstd::map::impl&%0::index")
(declare-fun req%vstd!map.impl&%0.index. (Dcr Type Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%2 Bool)
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self! Poly) (key! Poly)) (! (= (req%vstd!map.impl&%0.index. K&. K& V&. V& self! key!) (=> %%global_location_label%%2 (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& self!) key!))) :pattern ((req%vstd!map.impl&%0.index. K&. K& V&. V& self! key!)) )))
(set-info :comment ";; Function-Axioms vstd::map::impl&%0::index")
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self! Poly) (key! Poly)) (! (=> (and (has_type self! (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type key! K&)) (has_type (vstd!map.impl&%0.index.? K&. K& V&. V& self! key!) V&)) :pattern ((vstd!map.impl&%0.index.? K&. K& V&. V& self! key!)) )))
(set-info :comment ";; Function-Specs vstd::map::impl&%0::spec_index")
(declare-fun req%vstd!map.impl&%0.spec_index. (Dcr Type Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%3 Bool)
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self! Poly) (key! Poly)) (! (= (req%vstd!map.impl&%0.spec_index. K&. K& V&. V& self! key!) (=> %%global_location_label%%3 (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& self!) key!))) :pattern ((req%vstd!map.impl&%0.spec_index. K&. K& V&. V& self! key!)) )))
(set-info :comment ";; Function-Axioms vstd::map::impl&%0::spec_index")
(assert (fuel_bool_default fuel%vstd!map.impl&%0.spec_index.))
(assert (=> (fuel_bool fuel%vstd!map.impl&%0.spec_index.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self! Poly) (key! Poly)) (! (= (vstd!map.impl&%0.spec_index.? K&. K& V&. V& self! key!) (vstd!map.impl&%0.index.? K&. K& V&. V& self! key!)) :pattern ((vstd!map.impl&%0.spec_index.? K&. K& V&. V& self! key!)) ))))
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self! Poly) (key! Poly)) (! (=> (and (has_type self! (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type key! K&)) (has_type (vstd!map.impl&%0.spec_index.? K&. K& V&. V& self! key!) V&)) :pattern ((vstd!map.impl&%0.spec_index.? K&. K& V&. V& self! key!)) )))
(set-info :comment ";; Broadcast vstd::map::axiom_map_index_decreases_finite")
(assert (=> (fuel_bool fuel%vstd!map.axiom_map_index_decreases_finite.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m! Poly) (key! Poly)) (! (=> (and (has_type m! (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type key! K&)) (=> (and (vstd!set.impl&%0.finite.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m!)) (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m!) key!)) (height_lt (height (vstd!map.impl&%0.index.? K&. K& V&. V& m! key!)) (height m!)))) :pattern ((height (vstd!map.impl&%0.index.? K&. K& V&. V& m! key!))) ))))
(set-info :comment ";; Broadcast vstd::map::axiom_map_index_decreases_infinite")
(assert (=> (fuel_bool fuel%vstd!map.axiom_map_index_decreases_infinite.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m! Poly) (key! Poly)) (! (=> (and (has_type m! (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type key! K&)) (=> (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m!) key!) (height_lt (height (vstd!map.impl&%0.index.? K&. K& V&. V& m! key!)) (height (fun_from_recursive_field m!))))) :pattern ((height (vstd!map.impl&%0.index.? K&. K& V&. V& m! key!))) ))))
(set-info :comment ";; Broadcast vstd::map::axiom_map_ext_equal")
(assert (=> (fuel_bool fuel%vstd!map.axiom_map_ext_equal.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m1! Poly) (m2! Poly)) (! (=> (and (has_type m1! (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type m2! (TYPE%vstd!map.Map. K&. K& V&. V&))) (= (ext_eq false (TYPE%vstd!map.Map. K&. K& V&. V&) m1! m2!) (and (ext_eq false (TYPE%vstd!set.Set. K&. K&) (vstd!map.impl&%0.dom.? K&. K& V&. V& m1!) (vstd!map.impl&%0.dom.? K&. K& V&. V& m2!)) (forall ((k$ Poly)) (! (=> (has_type k$ K&) (=> (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m1!) k$) (= (vstd!map.impl&%0.index.? K&. K& V&. V& m1! k$) (vstd!map.impl&%0.index.? K&. K& V&. V& m2! k$)))) :pattern ((vstd!map.impl&%0.index.? K&. K& V&. V& m1! k$)) :pattern ((vstd!map.impl&%0.index.? K&. K& V&. V& m2! k$)) ))))) :pattern ((ext_eq false (TYPE%vstd!map.Map. K&. K& V&. V&) m1! m2!)) ))))
(set-info :comment ";; Broadcast vstd::map::axiom_map_ext_equal_deep")
(assert (=> (fuel_bool fuel%vstd!map.axiom_map_ext_equal_deep.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m1! Poly) (m2! Poly)) (! (=> (and (has_type m1! (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type m2! (TYPE%vstd!map.Map. K&. K& V&. V&))) (= (ext_eq true (TYPE%vstd!map.Map. K&. K& V&. V&) m1! m2!) (and (ext_eq true (TYPE%vstd!set.Set. K&. K&) (vstd!map.impl&%0.dom.? K&. K& V&. V& m1!) (vstd!map.impl&%0.dom.? K&. K& V&. V& m2!)) (forall ((k$ Poly)) (! (=> (has_type k$ K&) (=> (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m1!) k$) (ext_eq true V& (vstd!map.impl&%0.index.? K&. K& V&. V& m1! k$) (vstd!map.impl&%0.index.? K&. K& V&. V& m2! k$)))) :pattern ((vstd!map.impl&%0.index.? K&. K& V&. V& m1! k$)) :pattern ((vstd!map.impl&%0.index.? K&. K& V&. V& m2! k$)) ))))) :pattern ((ext_eq true (TYPE%vstd!map.Map. K&. K& V&. V&) m1! m2!)) ))))
(set-info :comment ";; Broadcast vstd::seq::axiom_seq_index_decreases")
(assert (=> (fuel_bool fuel%vstd!seq.axiom_seq_index_decreases.) (forall ((A&. Dcr) (A& Type) (s! Poly) (i! Poly)) (! (=> (and (has_type s! (TYPE%vstd!seq.Seq. A&. A&)) (has_type i! INT)) (=> (and (<= 0 (%I i!)) (< (%I i!) (vstd!seq.Seq.len.? A&. A& s!))) (height_lt (height (vstd!seq.Seq.index.? A&. A& s! i!)) (height s!)))) :pattern ((height (vstd!seq.Seq.index.? A&. A& s! i!))) ))))
(set-info :comment ";; Broadcast vstd::seq::axiom_seq_ext_equal")
(assert (=> (fuel_bool fuel%vstd!seq.axiom_seq_ext_equal.) (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly)) (! (=> (and (has_type s1! (TYPE%vstd!seq.Seq. A&. A&)) (has_type s2! (TYPE%vstd!seq.Seq. A&. A&))) (= (ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) (and (= (vstd!seq.Seq.len.? A&. A& s1!) (vstd!seq.Seq.len.? A&. A& s2!)) (forall ((i$ Poly)) (! (=> (has_type i$ INT) (=> (and (<= 0 (%I i$)) (< (%I i$) (vstd!seq.Seq.len.? A&. A& s1!))) (= (vstd!seq.Seq.index.? A&. A& s1! i$) (vstd!seq.Seq.index.? A&. A& s2! i$)))) :pattern ((vstd!seq.Seq.index.? A&. A& s1! i$)) :pattern ((vstd!seq.Seq.index.? A&. A& s2! i$)) ))))) :pattern ((ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!)) ))))
(set-info :comment ";; Broadcast vstd::seq::axiom_seq_ext_equal_deep")
(assert (=> (fuel_bool fuel%vstd!seq.axiom_seq_ext_equal_deep.) (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly)) (! (=> (and (has_type s1! (TYPE%vstd!seq.Seq. A&. A&)) (has_type s2! (TYPE%vstd!seq.Seq. A&. A&))) (= (ext_eq true (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) (and (= (vstd!seq.Seq.len.? A&. A& s1!) (vstd!seq.Seq.len.? A&. A& s2!)) (forall ((i$ Poly)) (! (=> (has_type i$ INT) (=> (and (<= 0 (%I i$)) (< (%I i$) (vstd!seq.Seq.len.? A&. A& s1!))) (ext_eq true A& (vstd!seq.Seq.index.? A&. A& s1! i$) (vstd!seq.Seq.index.? A&. A& s2! i$)))) :pattern ((vstd!seq.Seq.index.? A&. A& s1! i$)) :pattern ((vstd!seq.Seq.index.? A&. A& s2! i$)) ))))) :pattern ((ext_eq true (TYPE%vstd!seq.Seq. A&. A&) s1! s2!)) ))))
(set-info :comment ";; Broadcast vstd::set::axiom_set_ext_equal")
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_ext_equal.) (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly)) (! (=> (and (has_type s1! (TYPE%vstd!set.Set. A&. A&)) (has_type s2! (TYPE%vstd!set.Set. A&. A&))) (= (ext_eq false (TYPE%vstd!set.Set. A&. A&) s1! s2!) (forall ((a$ Poly)) (! (=> (has_type a$ A&) (= (vstd!set.impl&%0.contains.? A&. A& s1! a$) (vstd!set.impl&%0.contains.? A&. A& s2! a$))) :pattern ((vstd!set.impl&%0.contains.? A&. A& s1! a$)) :pattern ((vstd!set.impl&%0.contains.? A&. A& s2! a$)) )))) :pattern ((ext_eq false (TYPE%vstd!set.Set. A&. A&) s1! s2!)) ))))
(set-info :comment ";; Broadcast vstd::set::axiom_set_ext_equal_deep")
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_ext_equal_deep.) (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly)) (! (=> (and (has_type s1! (TYPE%vstd!set.Set. A&. A&)) (has_type s2! (TYPE%vstd!set.Set. A&. A&))) (= (ext_eq true (TYPE%vstd!set.Set. A&. A&) s1! s2!) (ext_eq false (TYPE%vstd!set.Set. A&. A&) s1! s2!))) :pattern ((ext_eq true (TYPE%vstd!set.Set. A&. A&) s1! s2!)) ))))
(set-info :comment ";; Function-Axioms lib::page_organization::PageOrg::State::does_count")
(assert (fuel_bool_default fuel%lib!page_organization.PageOrg.impl&%4.does_count.))
(assert (=> (fuel_bool fuel%lib!page_organization.PageOrg.impl&%4.does_count.) (forall ((self! Poly) (page_id! Poly)) (! (= (lib!page_organization.PageOrg.impl&%4.does_count.? self! page_id!) (and (and (and (vstd!set.impl&%0.contains.? $ TYPE%lib!tokens.PageId. (vstd!map.impl&%0.dom.? $ TYPE%lib!tokens.PageId. $ TYPE%lib!page_organization.PageData. (Poly%vstd!map.Map<lib!tokens.PageId./lib!page_organization.PageData.>. (lib!page_organization.PageOrg.State./State/pages (%Poly%lib!page_organization.PageOrg.State. self!)))) page_id!) (not (= (lib!tokens.PageId./PageId/idx (%Poly%lib!tokens.PageId. page_id!)) 0))) (lib!page_organization.PageData./PageData/is_used (%Poly%lib!page_organization.PageData. (vstd!map.impl&%0.index.? $ TYPE%lib!tokens.PageId. $ TYPE%lib!page_organization.PageData. (Poly%vstd!map.Map<lib!tokens.PageId./lib!page_organization.PageData.>. (lib!page_organization.PageOrg.State./State/pages (%Poly%lib!page_organization.PageOrg.State. self!))) page_id!)))) (= (lib!page_organization.PageData./PageData/offset (%Poly%lib!page_organization.PageData. (vstd!map.impl&%0.index.? $ TYPE%lib!tokens.PageId. $ TYPE%lib!page_organization.PageData. (Poly%vstd!map.Map<lib!tokens.PageId./lib!page_organization.PageData.>. (lib!page_organization.PageOrg.State./State/pages (%Poly%lib!page_organization.PageOrg.State. self!))) page_id!))) (core!option.Option./Some (I 0))))) :pattern ((lib!page_organization.PageOrg.impl&%4.does_count.? self! page_id!)) ))))
(set-info :comment ";; Function-Axioms lib::page_organization::PageOrg::State::one_count")
(assert (fuel_bool_default fuel%lib!page_organization.PageOrg.impl&%4.one_count.))
(assert (=> (fuel_bool fuel%lib!page_organization.PageOrg.impl&%4.one_count.) (forall ((self! Poly) (page_id! Poly)) (! (= (lib!page_organization.PageOrg.impl&%4.one_count.? self! page_id!) (ite (lib!page_organization.PageOrg.impl&%4.does_count.? self! page_id!) 1 0)) :pattern ((lib!page_organization.PageOrg.impl&%4.one_count.? self! page_id!)) ))))
(assert (forall ((self! Poly) (page_id! Poly)) (! (=> (and (has_type self! TYPE%lib!page_organization.PageOrg.State.) (has_type page_id! TYPE%lib!tokens.PageId.)) (<= 0 (lib!page_organization.PageOrg.impl&%4.one_count.? self! page_id!))) :pattern ((lib!page_organization.PageOrg.impl&%4.one_count.? self! page_id!)) )))
(set-info :comment ";; Function-Axioms lib::page_organization::PageOrg::State::ucount_sum")
(assert (fuel_bool_default fuel%lib!page_organization.PageOrg.impl&%4.ucount_sum.))
(declare-const fuel_nat%lib!page_organization.PageOrg.impl&%4.ucount_sum. Fuel)
(assert (forall ((self! Poly) (segment_id! Poly) (idx! Poly) (fuel% Fuel)) (! (= (lib!page_organization.PageOrg.impl&%4.rec%ucount_sum.? self! segment_id! idx! fuel%) (lib!page_organization.PageOrg.impl&%4.rec%ucount_sum.? self! segment_id! idx! zero)) :pattern ((lib!page_organization.PageOrg.impl&%4.rec%ucount_sum.? self! segment_id! idx! fuel%)) )))
(assert (forall ((self! Poly) (segment_id! Poly) (idx! Poly) (fuel% Fuel)) (! (=> (and (has_type self! TYPE%lib!page_organization.PageOrg.State.) (has_type segment_id! TYPE%lib!tokens.SegmentId.) (has_type idx! INT)) (= (lib!page_organization.PageOrg.impl&%4.rec%ucount_sum.? self! segment_id! idx! (succ fuel%)) (ite (<= (%I idx!) 0) 0 (nClip (Add (lib!page_organization.PageOrg.impl&%4.rec%ucount_sum.? self! segment_id! (I (Sub (%I idx!) 1)) fuel%) (lib!page_organization.PageOrg.impl&%4.one_count.? self! (Poly%lib!tokens.PageId. (lib!tokens.PageId./PageId (%Poly%lib!tokens.SegmentId. segment_id!) (%I (I (nClip (Sub (%I idx!) 1)))))))))))) :pattern ((lib!page_organization.PageOrg.impl&%4.rec%ucount_sum.? self! segment_id! idx! (succ fuel%))) )))
(assert (=> (fuel_bool fuel%lib!page_organization.PageOrg.impl&%4.ucount_sum.) (forall ((self! Poly) (segment_id! Poly) (idx! Poly)) (! (=> (and (has_type self! TYPE%lib!page_organization.PageOrg.State.) (has_type segment_id! TYPE%lib!tokens.SegmentId.) (has_type idx! INT)) (= (lib!page_organization.PageOrg.impl&%4.ucount_sum.? self! segment_id! idx!) (lib!page_organization.PageOrg.impl&%4.rec%ucount_sum.? self! segment_id! idx! (succ fuel_nat%lib!page_organization.PageOrg.impl&%4.ucount_sum.)))) :pattern ((lib!page_organization.PageOrg.impl&%4.ucount_sum.? self! segment_id! idx!)) ))))
(assert (forall ((self! Poly) (segment_id! Poly) (idx! Poly)) (! (=> (and (has_type self! TYPE%lib!page_organization.PageOrg.State.) (has_type segment_id! TYPE%lib!tokens.SegmentId.) (has_type idx! INT)) (<= 0 (lib!page_organization.PageOrg.impl&%4.ucount_sum.? self! segment_id! idx!))) :pattern ((lib!page_organization.PageOrg.impl&%4.ucount_sum.? self! segment_id! idx!)) )))
(set-info :comment ";; Function-Specs lib::page_organization::PageOrg::State::ucount_sum_eq0_inverse")
(declare-fun req%lib!page_organization.PageOrg.impl&%4.ucount_sum_eq0_inverse. (lib!page_organization.PageOrg.State. lib!tokens.PageId. Int) Bool)
(declare-const %%global_location_label%%4 Bool)
(declare-const %%global_location_label%%5 Bool)
(assert (forall ((self! lib!page_organization.PageOrg.State.) (page_id! lib!tokens.PageId.) (idx! Int)) (! (= (req%lib!page_organization.PageOrg.impl&%4.ucount_sum_eq0_inverse. self! page_id! idx!) (and (=> %%global_location_label%%4 (= (lib!page_organization.PageOrg.impl&%4.ucount_sum.? (Poly%lib!page_organization.PageOrg.State. self!) (Poly%lib!tokens.SegmentId. (lib!tokens.PageId./PageId/segment_id (%Poly%lib!tokens.PageId. (Poly%lib!tokens.PageId. page_id!)))) (I idx!)) 0)) (=> %%global_location_label%%5 (let ((tmp%%$ (lib!tokens.PageId./PageId/idx (%Poly%lib!tokens.PageId. (Poly%lib!tokens.PageId. page_id!))))) (and (<= 0 tmp%%$) (< tmp%%$ idx!)))))) :pattern ((req%lib!page_organization.PageOrg.impl&%4.ucount_sum_eq0_inverse. self! page_id! idx!)) )))
(declare-fun ens%lib!page_organization.PageOrg.impl&%4.ucount_sum_eq0_inverse. (lib!page_organization.PageOrg.State. lib!tokens.PageId. Int) Bool)
(assert (forall ((self! lib!page_organization.PageOrg.State.) (page_id! lib!tokens.PageId.) (idx! Int)) (! (= (ens%lib!page_organization.PageOrg.impl&%4.ucount_sum_eq0_inverse. self! page_id! idx!) (not (lib!page_organization.PageOrg.impl&%4.does_count.? (Poly%lib!page_organization.PageOrg.State. self!) (Poly%lib!tokens.PageId. page_id!)))) :pattern ((ens%lib!page_organization.PageOrg.impl&%4.ucount_sum_eq0_inverse. self! page_id! idx!)) )))
(set-info :comment ";; Function-Def lib::page_organization::PageOrg::State::ucount_sum_eq0_inverse")
(set-info :comment ";; page_organization.rs:4493:5: 4493:74 (#0)")
(declare-const self! lib!page_organization.PageOrg.State.)
(declare-const page_id! lib!tokens.PageId.)
(declare-const idx! Int)
(declare-const tmp%1 Int)
(declare-const tmp%2 Bool)
(declare-const tmp%3 Bool)
(declare-const tmp%4 Bool)
(declare-const tmp%5 Bool)
(declare-const decrease%init0 Int)
(assert fuel_defaults)
(assert (has_type (Poly%lib!page_organization.PageOrg.State. self!) TYPE%lib!page_organization.PageOrg.State.))
(assert (has_type (Poly%lib!tokens.PageId. page_id!) TYPE%lib!tokens.PageId.))
(assert (= (lib!page_organization.PageOrg.impl&%4.ucount_sum.? (Poly%lib!page_organization.PageOrg.State. self!) (Poly%lib!tokens.SegmentId. (lib!tokens.PageId./PageId/segment_id (%Poly%lib!tokens.PageId. (Poly%lib!tokens.PageId. page_id!)))) (I idx!)) 0))
(assert (let ((tmp%%$ (lib!tokens.PageId./PageId/idx (%Poly%lib!tokens.PageId. (Poly%lib!tokens.PageId. page_id!))))) (and (<= 0 tmp%%$) (< tmp%%$ idx!))))
(declare-const %%switch_label%%0 Bool)
(set-info :comment ";; could not prove termination")
(declare-const %%location_label%%0 Bool)
(set-info :comment ";; precondition not satisfied")
(declare-const %%location_label%%1 Bool)
(set-info :comment ";; assertion failed")
(declare-const %%location_label%%2 Bool)
(set-info :comment ";; assertion failed")
(declare-const %%location_label%%3 Bool)
(set-info :comment ";; assertion failed")
(declare-const %%location_label%%4 Bool)
(set-info :comment ";; assertion failed")
(declare-const %%location_label%%5 Bool)
(set-info :comment ";; postcondition not satisfied")
(declare-const %%location_label%%6 Bool)
(assert (not (=> (= decrease%init0 idx!) (or (and (=> (> (Sub idx! 1) (lib!tokens.PageId./PageId/idx (%Poly%lib!tokens.PageId. (Poly%lib!tokens.PageId. page_id!)))) (=> (= tmp%1 (Sub idx! 1)) (and (=> %%location_label%%0 (check_decrease_int (let ((self!$0 self!) (page_id!$1 page_id!) (idx!$2 tmp%1)) idx!$2) decrease%init0 false)) (and (=> %%location_label%%1 (req%lib!page_organization.PageOrg.impl&%4.ucount_sum_eq0_inverse. self! page_id! tmp%1)) (=> (ens%lib!page_organization.PageOrg.impl&%4.ucount_sum_eq0_inverse. self! page_id! tmp%1) (=> (= tmp%2 (not (lib!page_organization.PageOrg.impl&%4.does_count.? (Poly%lib!page_organization.PageOrg.State. self!) (Poly%lib!tokens.PageId. page_id!)))) (and (=> %%location_label%%2 tmp%2) (=> tmp%2 %%switch_label%%0)))))))) (=> (not (> (Sub idx! 1) (lib!tokens.PageId./PageId/idx (%Poly%lib!tokens.PageId. (Poly%lib!tokens.PageId. page_id!))))) (=> (= tmp%3 (= (Sub idx! 1) (lib!tokens.PageId./PageId/idx (%Poly%lib!tokens.PageId. (Poly%lib!tokens.PageId. page_id!))))) (and (=> %%location_label%%3 tmp%3) (=> tmp%3 (=> (= tmp%4 (= (nClip (Add (lib!page_organization.PageOrg.impl&%4.ucount_sum.? (Poly%lib!page_organization.PageOrg.State. self!) (Poly%lib!tokens.SegmentId. (lib!tokens.PageId./PageId/segment_id (%Poly%lib!tokens.PageId. (Poly%lib!tokens.PageId. page_id!)))) (I (Sub idx! 1))) (lib!page_organization.PageOrg.impl&%4.one_count.? (Poly%lib!page_organization.PageOrg.State. self!) (Poly%lib!tokens.PageId. (lib!tokens.PageId./PageId (%Poly%lib!tokens.SegmentId. (Poly%lib!tokens.SegmentId. (lib!tokens.PageId./PageId/segment_id (%Poly%lib!tokens.PageId. (Poly%lib!tokens.PageId. page_id!))))) (%I (I (nClip (Sub idx! 1))))))))) 0)) (and (=> %%location_label%%4 tmp%4) (=> tmp%4 (=> (= tmp%5 (not (lib!page_organization.PageOrg.impl&%4.does_count.? (Poly%lib!page_organization.PageOrg.State. self!) (Poly%lib!tokens.PageId. page_id!)))) (and (=> %%location_label%%5 tmp%5) (=> tmp%5 %%switch_label%%0))))))))))) (and (not %%switch_label%%0) (=> %%location_label%%6 (not (lib!page_organization.PageOrg.impl&%4.does_count.? (Poly%lib!page_organization.PageOrg.State. self!) (Poly%lib!tokens.PageId. page_id!)))))))))
(check-sat)
(exit)
