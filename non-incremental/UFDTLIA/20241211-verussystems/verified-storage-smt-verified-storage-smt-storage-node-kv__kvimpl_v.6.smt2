(set-info :smt-lib-version 2.6)
(set-logic UFDTLIA)
(set-info :source |
Generated by: Amar Shah
Generated on: 2024-12-11
Generator: Verus
Application: Verification of Rust Program
Target solver: z3
Time limit: 10
Benchmarks generated by the Rust verifier Verus (https://verus-lang.github.io/verus/guide/) on the project Verus Systems (https://dl.acm.org/doi/10.1145/3694715.3695952) 
and processed using Mariposa (https://github.com/secure-foundations/mariposa).
|)
(set-info :license "https://creativecommons.org/licenses/by/4.0/")
(set-info :category "industrial")
(set-info :status unsat)
(set-option :auto_config false)
(set-option :smt.mbqi false)
(set-option :smt.case_split 3)
(set-option :smt.qi.eager_threshold 100.0)
(set-option :smt.delay_units true)
(set-option :smt.arith.solver 2)
(set-option :smt.arith.nl false)
(set-option :pi.enabled false)
(set-option :rewriter.sort_disjunctions false)
(set-info :comment ";; Prelude")
(set-info :comment ";; AIR prelude")
(declare-sort %%Function%% 0)
(declare-sort FuelId 0)
(declare-sort Fuel 0)
(declare-const zero Fuel)
(declare-fun succ (Fuel) Fuel)
(declare-fun fuel_bool (FuelId) Bool)
(declare-fun fuel_bool_default (FuelId) Bool)
(declare-const fuel_defaults Bool)
(assert (=> fuel_defaults (forall ((id FuelId)) (! (= (fuel_bool id) (fuel_bool_default id)) :pattern ((fuel_bool id)) ))))
(declare-datatypes ((fndef 0)) (((fndef_singleton ))))
(declare-sort Poly 0)
(declare-sort Height 0)
(declare-fun I (Int) Poly)
(declare-fun B (Bool) Poly)
(declare-fun F (fndef) Poly)
(declare-fun %I (Poly) Int)
(declare-fun %B (Poly) Bool)
(declare-fun %F (Poly) fndef)
(declare-sort Type 0)
(declare-const BOOL Type)
(declare-const INT Type)
(declare-const NAT Type)
(declare-const CHAR Type)
(declare-fun UINT (Int) Type)
(declare-fun SINT (Int) Type)
(declare-fun CONST_INT (Int) Type)
(declare-sort Dcr 0)
(declare-const $ Dcr)
(declare-fun REF (Dcr) Dcr)
(declare-fun MUT_REF (Dcr) Dcr)
(declare-fun BOX (Dcr Type Dcr) Dcr)
(declare-fun RC (Dcr Type Dcr) Dcr)
(declare-fun ARC (Dcr Type Dcr) Dcr)
(declare-fun GHOST (Dcr) Dcr)
(declare-fun TRACKED (Dcr) Dcr)
(declare-fun NEVER (Dcr) Dcr)
(declare-fun CONST_PTR (Dcr) Dcr)
(declare-fun ARRAY (Dcr Type Dcr Type) Type)
(declare-fun SLICE (Dcr Type) Type)
(declare-const STRSLICE Type)
(declare-const ALLOCATOR_GLOBAL Type)
(declare-fun PTR (Dcr Type) Type)
(declare-fun has_type (Poly Type) Bool)
(declare-fun as_type (Poly Type) Poly)
(declare-fun mk_fun (%%Function%%) %%Function%%)
(declare-fun const_int (Type) Int)
(assert (forall ((i Int)) (! (= i (const_int (CONST_INT i))) :pattern ((CONST_INT i)) )))
(assert (forall ((b Bool)) (! (has_type (B b) BOOL) :pattern ((has_type (B b) BOOL)) )))
(assert (forall ((x Poly) (t Type)) (! (and (has_type (as_type x t) t) (=> (has_type x t) (= x (as_type x t)))) :pattern ((as_type x t)) )))
(assert (forall ((x %%Function%%)) (! (= (mk_fun x) x) :pattern ((mk_fun x)) )))
(assert (forall ((x Bool)) (! (= x (%B (B x))) :pattern ((B x)) )))
(assert (forall ((x Int)) (! (= x (%I (I x))) :pattern ((I x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x BOOL) (= x (B (%B x)))) :pattern ((has_type x BOOL)) )))
(assert (forall ((x Poly)) (! (=> (has_type x INT) (= x (I (%I x)))) :pattern ((has_type x INT)) )))
(assert (forall ((x Poly)) (! (=> (has_type x NAT) (= x (I (%I x)))) :pattern ((has_type x NAT)) )))
(assert (forall ((bits Int) (x Poly)) (! (=> (has_type x (UINT bits)) (= x (I (%I x)))) :pattern ((has_type x (UINT bits))) )))
(assert (forall ((bits Int) (x Poly)) (! (=> (has_type x (SINT bits)) (= x (I (%I x)))) :pattern ((has_type x (SINT bits))) )))
(assert (forall ((x Poly)) (! (=> (has_type x CHAR) (= x (I (%I x)))) :pattern ((has_type x CHAR)) )))
(declare-fun ext_eq (Bool Type Poly Poly) Bool)
(assert (forall ((deep Bool) (t Type) (x Poly) (y Poly)) (! (= (= x y) (ext_eq deep t x y)) :pattern ((ext_eq deep t x y)) )))
(declare-const SZ Int)
(assert (= SZ 64))
(declare-fun uHi (Int) Int)
(declare-fun iLo (Int) Int)
(declare-fun iHi (Int) Int)
(assert (= (uHi 8) 256))
(assert (= (uHi 16) 65536))
(assert (= (uHi 32) 4294967296))
(assert (= (uHi 64) 18446744073709551616))
(assert (= (uHi 128) (+ 1 340282366920938463463374607431768211455)))
(assert (= (iLo 8) (- 128)))
(assert (= (iLo 16) (- 32768)))
(assert (= (iLo 32) (- 2147483648)))
(assert (= (iLo 64) (- 9223372036854775808)))
(assert (= (iLo 128) (- 170141183460469231731687303715884105728)))
(assert (= (iHi 8) 128))
(assert (= (iHi 16) 32768))
(assert (= (iHi 32) 2147483648))
(assert (= (iHi 64) 9223372036854775808))
(assert (= (iHi 128) 170141183460469231731687303715884105728))
(declare-fun nClip (Int) Int)
(declare-fun uClip (Int Int) Int)
(declare-fun iClip (Int Int) Int)
(declare-fun charClip (Int) Int)
(assert (forall ((i Int)) (! (and (<= 0 (nClip i)) (=> (<= 0 i) (= i (nClip i)))) :pattern ((nClip i)) )))
(assert (forall ((bits Int) (i Int)) (! (and (<= 0 (uClip bits i)) (< (uClip bits i) (uHi bits)) (=> (and (<= 0 i) (< i (uHi bits))) (= i (uClip bits i)))) :pattern ((uClip bits i)) )))
(assert (forall ((bits Int) (i Int)) (! (and (<= (iLo bits) (iClip bits i)) (< (iClip bits i) (iHi bits)) (=> (and (<= (iLo bits) i) (< i (iHi bits))) (= i (iClip bits i)))) :pattern ((iClip bits i)) )))
(assert (forall ((i Int)) (! (and (or (and (<= 0 (charClip i)) (<= (charClip i) 55295)) (and (<= 57344 (charClip i)) (<= (charClip i) 1114111))) (=> (or (and (<= 0 i) (<= i 55295)) (and (<= 57344 i) (<= i 1114111))) (= i (charClip i)))) :pattern ((charClip i)) )))
(declare-fun uInv (Int Int) Bool)
(declare-fun iInv (Int Int) Bool)
(declare-fun charInv (Int) Bool)
(assert (forall ((bits Int) (i Int)) (! (= (uInv bits i) (and (<= 0 i) (< i (uHi bits)))) :pattern ((uInv bits i)) )))
(assert (forall ((bits Int) (i Int)) (! (= (iInv bits i) (and (<= (iLo bits) i) (< i (iHi bits)))) :pattern ((iInv bits i)) )))
(assert (forall ((i Int)) (! (= (charInv i) (or (and (<= 0 i) (<= i 55295)) (and (<= 57344 i) (<= i 1114111)))) :pattern ((charInv i)) )))
(assert (forall ((x Int)) (! (has_type (I x) INT) :pattern ((has_type (I x) INT)) )))
(assert (forall ((x Int)) (! (=> (<= 0 x) (has_type (I x) NAT)) :pattern ((has_type (I x) NAT)) )))
(assert (forall ((bits Int) (x Int)) (! (=> (uInv bits x) (has_type (I x) (UINT bits))) :pattern ((has_type (I x) (UINT bits))) )))
(assert (forall ((bits Int) (x Int)) (! (=> (iInv bits x) (has_type (I x) (SINT bits))) :pattern ((has_type (I x) (SINT bits))) )))
(assert (forall ((x Int)) (! (=> (charInv x) (has_type (I x) CHAR)) :pattern ((has_type (I x) CHAR)) )))
(assert (forall ((x Poly)) (! (=> (has_type x NAT) (<= 0 (%I x))) :pattern ((has_type x NAT)) )))
(assert (forall ((bits Int) (x Poly)) (! (=> (has_type x (UINT bits)) (uInv bits (%I x))) :pattern ((has_type x (UINT bits))) )))
(assert (forall ((bits Int) (x Poly)) (! (=> (has_type x (SINT bits)) (iInv bits (%I x))) :pattern ((has_type x (SINT bits))) )))
(declare-fun Add (Int Int) Int)
(declare-fun Sub (Int Int) Int)
(assert (forall ((x Int) (y Int)) (! (= (Add x y) (+ x y)) :pattern ((Add x y)))))
(assert (forall ((x Int) (y Int)) (! (= (Sub x y) (- x y)) :pattern ((Sub x y)))))
(declare-fun bitxor (Poly Poly) Int)
(declare-fun bitand (Poly Poly) Int)
(declare-fun bitor (Poly Poly) Int)
(declare-fun bitshr (Poly Poly) Int)
(declare-fun bitshl (Poly Poly) Int)
(declare-fun bitnot (Poly) Int)
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (uInv bits (%I x)) (uInv bits (%I y))) (uInv bits (bitxor x y))) :pattern ((uClip bits (bitxor x y))) )))
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (iInv bits (%I x)) (iInv bits (%I y))) (iInv bits (bitxor x y))) :pattern ((iClip bits (bitxor x y))) )))
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (uInv bits (%I x)) (uInv bits (%I y))) (uInv bits (bitor x y))) :pattern ((uClip bits (bitor x y))) )))
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (iInv bits (%I x)) (iInv bits (%I y))) (iInv bits (bitor x y))) :pattern ((iClip bits (bitor x y))) )))
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (uInv bits (%I x)) (uInv bits (%I y))) (uInv bits (bitand x y))) :pattern ((uClip bits (bitand x y))) )))
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (iInv bits (%I x)) (iInv bits (%I y))) (iInv bits (bitand x y))) :pattern ((iClip bits (bitand x y))) )))
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (uInv bits (%I x)) (<= 0 (%I y))) (uInv bits (bitshr x y))) :pattern ((uClip bits (bitshr x y))) )))
(assert (forall ((x Poly) (y Poly) (bits Int)) (! (=> (and (iInv bits (%I x)) (<= 0 (%I y))) (iInv bits (bitshr x y))) :pattern ((iClip bits (bitshr x y))) )))
(declare-fun singular_mod (Int Int) Int)
(declare-fun closure_req (Type Dcr Type Poly Poly) Bool)
(declare-fun closure_ens (Type Dcr Type Poly Poly Poly) Bool)
(declare-fun height (Poly) Height)
(declare-fun height_lt (Height Height) Bool)
(declare-fun fun_from_recursive_field (Poly) Poly)
(declare-fun check_decrease_int (Int Int Bool) Bool)
(assert (forall ((cur Int) (prev Int) (otherwise Bool)) (! (= (check_decrease_int cur prev otherwise) (or (and (<= 0 cur) (< cur prev)) (and (= cur prev) otherwise))) :pattern ((check_decrease_int cur prev otherwise)) )))
(declare-fun check_decrease_height (Poly Poly Bool) Bool)
(assert (forall ((cur Poly) (prev Poly) (otherwise Bool)) (! (= (check_decrease_height cur prev otherwise) (or (height_lt (height cur) (height prev)) (and (= (height cur) (height prev)) otherwise))) :pattern ((check_decrease_height cur prev otherwise)) )))
(declare-fun partial-order (Height Height) Bool)
(assert (forall ((x Height)) (partial-order x x)))
(assert (forall ((x Height) (y Height)) (=> (and (partial-order x y) (partial-order y x)) (= x y))))
(assert (forall ((x Height) (y Height) (z Height)) (=> (and (partial-order x y) (partial-order y z)) (partial-order x z))))
(assert (forall ((x Height) (y Height)) (! (= (height_lt x y) (and (partial-order x y) (not (= x y)))) :pattern ((height_lt x y)))))
(set-info :comment ";; MODULE 'module kv::kvimpl_v'")
(set-info :comment ";; Fuel")
(declare-const fuel%vstd!std_specs.control_flow.spec_from_blanket_identity. FuelId)
(declare-const fuel%vstd!std_specs.option.impl&%0.is_Some. FuelId)
(declare-const fuel%vstd!std_specs.option.impl&%0.get_Some_0. FuelId)
(declare-const fuel%vstd!std_specs.option.impl&%0.is_None. FuelId)
(declare-const fuel%vstd!std_specs.option.is_some. FuelId)
(declare-const fuel%vstd!std_specs.option.spec_unwrap. FuelId)
(declare-const fuel%vstd!std_specs.result.impl&%0.is_Ok. FuelId)
(declare-const fuel%vstd!std_specs.result.impl&%0.get_Ok_0. FuelId)
(declare-const fuel%vstd!std_specs.result.spec_unwrap. FuelId)
(declare-const fuel%vstd!map.impl&%0.new. FuelId)
(declare-const fuel%vstd!map.impl&%0.spec_index. FuelId)
(declare-const fuel%vstd!map.impl&%0.len. FuelId)
(declare-const fuel%vstd!map.axiom_map_index_decreases_finite. FuelId)
(declare-const fuel%vstd!map.axiom_map_index_decreases_infinite. FuelId)
(declare-const fuel%vstd!map.axiom_map_empty. FuelId)
(declare-const fuel%vstd!map.axiom_map_insert_domain. FuelId)
(declare-const fuel%vstd!map.axiom_map_insert_same. FuelId)
(declare-const fuel%vstd!map.axiom_map_insert_different. FuelId)
(declare-const fuel%vstd!map.axiom_map_remove_domain. FuelId)
(declare-const fuel%vstd!map.axiom_map_remove_different. FuelId)
(declare-const fuel%vstd!map.axiom_map_ext_equal. FuelId)
(declare-const fuel%vstd!map.axiom_map_ext_equal_deep. FuelId)
(declare-const fuel%vstd!map_lib.impl&%0.is_empty. FuelId)
(declare-const fuel%vstd!map_lib.impl&%0.contains_key. FuelId)
(declare-const fuel%vstd!map_lib.impl&%0.remove_keys. FuelId)
(declare-const fuel%vstd!raw_ptr.impl&%4.view. FuelId)
(declare-const fuel%vstd!raw_ptr.ptrs_mut_eq. FuelId)
(declare-const fuel%vstd!seq.impl&%0.spec_index. FuelId)
(declare-const fuel%vstd!seq.axiom_seq_index_decreases. FuelId)
(declare-const fuel%vstd!seq.axiom_seq_subrange_decreases. FuelId)
(declare-const fuel%vstd!seq.axiom_seq_empty. FuelId)
(declare-const fuel%vstd!seq.axiom_seq_push_len. FuelId)
(declare-const fuel%vstd!seq.axiom_seq_push_index_same. FuelId)
(declare-const fuel%vstd!seq.axiom_seq_push_index_different. FuelId)
(declare-const fuel%vstd!seq.axiom_seq_update_len. FuelId)
(declare-const fuel%vstd!seq.axiom_seq_update_same. FuelId)
(declare-const fuel%vstd!seq.axiom_seq_update_different. FuelId)
(declare-const fuel%vstd!seq.axiom_seq_ext_equal. FuelId)
(declare-const fuel%vstd!seq.axiom_seq_ext_equal_deep. FuelId)
(declare-const fuel%vstd!seq.axiom_seq_subrange_len. FuelId)
(declare-const fuel%vstd!seq.axiom_seq_subrange_index. FuelId)
(declare-const fuel%vstd!seq_lib.impl&%0.contains. FuelId)
(declare-const fuel%vstd!seq_lib.impl&%0.to_set. FuelId)
(declare-const fuel%vstd!seq_lib.seq_to_set_is_finite. FuelId)
(declare-const fuel%vstd!set.axiom_set_empty. FuelId)
(declare-const fuel%vstd!set.axiom_set_new. FuelId)
(declare-const fuel%vstd!set.axiom_set_insert_same. FuelId)
(declare-const fuel%vstd!set.axiom_set_insert_different. FuelId)
(declare-const fuel%vstd!set.axiom_set_remove_same. FuelId)
(declare-const fuel%vstd!set.axiom_set_remove_insert. FuelId)
(declare-const fuel%vstd!set.axiom_set_remove_different. FuelId)
(declare-const fuel%vstd!set.axiom_set_ext_equal. FuelId)
(declare-const fuel%vstd!set.axiom_set_ext_equal_deep. FuelId)
(declare-const fuel%vstd!set.axiom_mk_map_domain. FuelId)
(declare-const fuel%vstd!set.axiom_mk_map_index. FuelId)
(declare-const fuel%vstd!set.axiom_set_empty_finite. FuelId)
(declare-const fuel%vstd!set.axiom_set_insert_finite. FuelId)
(declare-const fuel%vstd!set.axiom_set_remove_finite. FuelId)
(declare-const fuel%vstd!set.axiom_set_empty_len. FuelId)
(declare-const fuel%vstd!set.axiom_set_insert_len. FuelId)
(declare-const fuel%vstd!set.axiom_set_remove_len. FuelId)
(declare-const fuel%vstd!set.axiom_set_contains_len. FuelId)
(declare-const fuel%vstd!set_lib.impl&%0.is_empty. FuelId)
(declare-const fuel%vstd!set_lib.axiom_is_empty. FuelId)
(declare-const fuel%vstd!view.impl&%0.view. FuelId)
(declare-const fuel%vstd!view.impl&%2.view. FuelId)
(declare-const fuel%vstd!view.impl&%4.view. FuelId)
(declare-const fuel%vstd!view.impl&%6.view. FuelId)
(declare-const fuel%vstd!view.impl&%10.view. FuelId)
(declare-const fuel%vstd!view.impl&%12.view. FuelId)
(declare-const fuel%vstd!view.impl&%14.view. FuelId)
(declare-const fuel%vstd!view.impl&%20.view. FuelId)
(declare-const fuel%vstd!view.impl&%22.view. FuelId)
(declare-const fuel%vstd!view.impl&%24.view. FuelId)
(declare-const fuel%vstd!view.impl&%42.view. FuelId)
(declare-const fuel%vstd!view.impl&%44.view. FuelId)
(declare-const fuel%lib!kv.durable.durablespec_t.impl&%0.spec_index. FuelId)
(declare-const fuel%lib!kv.durable.durablespec_t.impl&%0.offset_index. FuelId)
(declare-const fuel%lib!kv.durable.durablespec_t.impl&%0.len. FuelId)
(declare-const fuel%lib!kv.durable.durablespec_t.impl&%0.empty. FuelId)
(declare-const fuel%lib!kv.durable.durablespec_t.impl&%1.key. FuelId)
(declare-const fuel%lib!kv.durable.durablespec_t.impl&%1.item. FuelId)
(declare-const fuel%lib!kv.durable.durablespec_t.impl&%1.list. FuelId)
(declare-const fuel%lib!kv.durable.durablespec_t.impl&%2.spec_index. FuelId)
(declare-const fuel%lib!kv.durable.durablespec_t.impl&%2.contains_key. FuelId)
(declare-const fuel%lib!kv.durable.durablespec_t.impl&%2.empty. FuelId)
(declare-const fuel%lib!kv.durable.durablespec_t.impl&%2.len. FuelId)
(declare-const fuel%lib!kv.durable.durablespec_t.impl&%2.create. FuelId)
(declare-const fuel%lib!kv.durable.durablespec_t.impl&%2.valid. FuelId)
(declare-const fuel%lib!kv.durable.durablespec_t.impl&%2.matches_volatile_index. FuelId)
(declare-const fuel%lib!kv.volatile.volatilespec_t.impl&%0.has_free_space. FuelId)
(declare-const fuel%lib!kv.volatile.volatilespec_t.impl&%0.append_entry. FuelId)
(declare-const fuel%lib!kv.volatile.volatilespec_t.impl&%1.spec_index. FuelId)
(declare-const fuel%lib!kv.volatile.volatilespec_t.impl&%1.contains_key. FuelId)
(declare-const fuel%lib!kv.volatile.volatilespec_t.impl&%1.len. FuelId)
(declare-const fuel%lib!kv.volatile.volatilespec_t.impl&%1.insert_item_offset. FuelId)
(declare-const fuel%lib!kv.volatile.volatilespec_t.impl&%1.get_node_view. FuelId)
(declare-const fuel%lib!kv.volatile.volatilespec_t.impl&%1.get_node_offset. FuelId)
(declare-const fuel%lib!kv.volatile.volatilespec_t.impl&%1.list_len. FuelId)
(declare-const fuel%lib!kv.volatile.volatilespec_t.impl&%1.append_to_list. FuelId)
(declare-const fuel%lib!kv.volatile.volatilespec_t.impl&%1.trim_list. FuelId)
(declare-const fuel%lib!kv.volatile.volatilespec_t.impl&%1.empty. FuelId)
(declare-const fuel%lib!kv.volatile.volatilespec_t.impl&%1.keys. FuelId)
(declare-const fuel%lib!kv.kvimpl_v.impl&%0.recover. FuelId)
(declare-const fuel%lib!kv.kvimpl_v.impl&%0.view. FuelId)
(declare-const fuel%lib!kv.kvimpl_v.impl&%0.valid. FuelId)
(declare-const fuel%lib!kv.kvspec_t.impl&%2.spec_index. FuelId)
(declare-const fuel%lib!kv.kvspec_t.impl&%2.empty. FuelId)
(declare-const fuel%lib!kv.kvspec_t.impl&%2.construct_view_contents. FuelId)
(declare-const fuel%lib!kv.kvspec_t.impl&%2.create. FuelId)
(declare-const fuel%lib!kv.kvspec_t.impl&%2.read_item_and_list. FuelId)
(declare-const fuel%lib!kv.kvspec_t.impl&%2.read_list_entry_at_index. FuelId)
(declare-const fuel%lib!kv.kvspec_t.impl&%2.update_item. FuelId)
(declare-const fuel%lib!kv.kvspec_t.impl&%2.delete. FuelId)
(declare-const fuel%lib!kv.kvspec_t.impl&%2.append_to_list. FuelId)
(declare-const fuel%lib!kv.kvspec_t.impl&%2.append_to_list_and_update_item. FuelId)
(declare-const fuel%lib!kv.kvspec_t.impl&%2.update_list_entry_at_index. FuelId)
(declare-const fuel%lib!kv.kvspec_t.impl&%2.update_entry_at_index_and_item. FuelId)
(declare-const fuel%lib!kv.kvspec_t.impl&%2.trim_list. FuelId)
(declare-const fuel%lib!kv.kvspec_t.impl&%2.trim_list_and_update_item. FuelId)
(declare-const fuel%lib!kv.kvspec_t.impl&%2.get_keys. FuelId)
(declare-const fuel%vstd!array.group_array_axioms. FuelId)
(declare-const fuel%vstd!map.group_map_axioms. FuelId)
(declare-const fuel%vstd!multiset.group_multiset_axioms. FuelId)
(declare-const fuel%vstd!raw_ptr.group_raw_ptr_axioms. FuelId)
(declare-const fuel%vstd!seq.group_seq_axioms. FuelId)
(declare-const fuel%vstd!seq_lib.group_seq_lib_default. FuelId)
(declare-const fuel%vstd!set.group_set_axioms. FuelId)
(declare-const fuel%vstd!set_lib.group_set_lib_axioms. FuelId)
(declare-const fuel%vstd!slice.group_slice_axioms. FuelId)
(declare-const fuel%vstd!string.group_string_axioms. FuelId)
(declare-const fuel%vstd!std_specs.bits.group_bits_axioms. FuelId)
(declare-const fuel%vstd!std_specs.control_flow.group_control_flow_axioms. FuelId)
(declare-const fuel%vstd!std_specs.range.group_range_axioms. FuelId)
(declare-const fuel%vstd!std_specs.vec.group_vec_axioms. FuelId)
(declare-const fuel%vstd!group_vstd_default. FuelId)
(assert (distinct fuel%vstd!std_specs.control_flow.spec_from_blanket_identity. fuel%vstd!std_specs.option.impl&%0.is_Some. fuel%vstd!std_specs.option.impl&%0.get_Some_0. fuel%vstd!std_specs.option.impl&%0.is_None. fuel%vstd!std_specs.option.is_some. fuel%vstd!std_specs.option.spec_unwrap. fuel%vstd!std_specs.result.impl&%0.is_Ok. fuel%vstd!std_specs.result.impl&%0.get_Ok_0. fuel%vstd!std_specs.result.spec_unwrap. fuel%vstd!map.impl&%0.new. fuel%vstd!map.impl&%0.spec_index. fuel%vstd!map.impl&%0.len. fuel%vstd!map.axiom_map_index_decreases_finite. fuel%vstd!map.axiom_map_index_decreases_infinite. fuel%vstd!map.axiom_map_empty. fuel%vstd!map.axiom_map_insert_domain. fuel%vstd!map.axiom_map_insert_same. fuel%vstd!map.axiom_map_insert_different. fuel%vstd!map.axiom_map_remove_domain. fuel%vstd!map.axiom_map_remove_different. fuel%vstd!map.axiom_map_ext_equal. fuel%vstd!map.axiom_map_ext_equal_deep. fuel%vstd!map_lib.impl&%0.is_empty. fuel%vstd!map_lib.impl&%0.contains_key. fuel%vstd!map_lib.impl&%0.remove_keys. fuel%vstd!raw_ptr.impl&%4.view. fuel%vstd!raw_ptr.ptrs_mut_eq. fuel%vstd!seq.impl&%0.spec_index. fuel%vstd!seq.axiom_seq_index_decreases. fuel%vstd!seq.axiom_seq_subrange_decreases. fuel%vstd!seq.axiom_seq_empty. fuel%vstd!seq.axiom_seq_push_len. fuel%vstd!seq.axiom_seq_push_index_same. fuel%vstd!seq.axiom_seq_push_index_different. fuel%vstd!seq.axiom_seq_update_len. fuel%vstd!seq.axiom_seq_update_same. fuel%vstd!seq.axiom_seq_update_different. fuel%vstd!seq.axiom_seq_ext_equal. fuel%vstd!seq.axiom_seq_ext_equal_deep. fuel%vstd!seq.axiom_seq_subrange_len. fuel%vstd!seq.axiom_seq_subrange_index. fuel%vstd!seq_lib.impl&%0.contains. fuel%vstd!seq_lib.impl&%0.to_set. fuel%vstd!seq_lib.seq_to_set_is_finite. fuel%vstd!set.axiom_set_empty. fuel%vstd!set.axiom_set_new. fuel%vstd!set.axiom_set_insert_same. fuel%vstd!set.axiom_set_insert_different. fuel%vstd!set.axiom_set_remove_same. fuel%vstd!set.axiom_set_remove_insert. fuel%vstd!set.axiom_set_remove_different. fuel%vstd!set.axiom_set_ext_equal. fuel%vstd!set.axiom_set_ext_equal_deep. fuel%vstd!set.axiom_mk_map_domain. fuel%vstd!set.axiom_mk_map_index. fuel%vstd!set.axiom_set_empty_finite. fuel%vstd!set.axiom_set_insert_finite. fuel%vstd!set.axiom_set_remove_finite. fuel%vstd!set.axiom_set_empty_len. fuel%vstd!set.axiom_set_insert_len. fuel%vstd!set.axiom_set_remove_len. fuel%vstd!set.axiom_set_contains_len. fuel%vstd!set_lib.impl&%0.is_empty. fuel%vstd!set_lib.axiom_is_empty. fuel%vstd!view.impl&%0.view. fuel%vstd!view.impl&%2.view. fuel%vstd!view.impl&%4.view. fuel%vstd!view.impl&%6.view. fuel%vstd!view.impl&%10.view. fuel%vstd!view.impl&%12.view. fuel%vstd!view.impl&%14.view. fuel%vstd!view.impl&%20.view. fuel%vstd!view.impl&%22.view. fuel%vstd!view.impl&%24.view. fuel%vstd!view.impl&%42.view. fuel%vstd!view.impl&%44.view. fuel%lib!kv.durable.durablespec_t.impl&%0.spec_index. fuel%lib!kv.durable.durablespec_t.impl&%0.offset_index. fuel%lib!kv.durable.durablespec_t.impl&%0.len. fuel%lib!kv.durable.durablespec_t.impl&%0.empty. fuel%lib!kv.durable.durablespec_t.impl&%1.key. fuel%lib!kv.durable.durablespec_t.impl&%1.item. fuel%lib!kv.durable.durablespec_t.impl&%1.list. fuel%lib!kv.durable.durablespec_t.impl&%2.spec_index. fuel%lib!kv.durable.durablespec_t.impl&%2.contains_key. fuel%lib!kv.durable.durablespec_t.impl&%2.empty. fuel%lib!kv.durable.durablespec_t.impl&%2.len. fuel%lib!kv.durable.durablespec_t.impl&%2.create. fuel%lib!kv.durable.durablespec_t.impl&%2.valid. fuel%lib!kv.durable.durablespec_t.impl&%2.matches_volatile_index. fuel%lib!kv.volatile.volatilespec_t.impl&%0.has_free_space. fuel%lib!kv.volatile.volatilespec_t.impl&%0.append_entry. fuel%lib!kv.volatile.volatilespec_t.impl&%1.spec_index. fuel%lib!kv.volatile.volatilespec_t.impl&%1.contains_key. fuel%lib!kv.volatile.volatilespec_t.impl&%1.len. fuel%lib!kv.volatile.volatilespec_t.impl&%1.insert_item_offset. fuel%lib!kv.volatile.volatilespec_t.impl&%1.get_node_view. fuel%lib!kv.volatile.volatilespec_t.impl&%1.get_node_offset. fuel%lib!kv.volatile.volatilespec_t.impl&%1.list_len. fuel%lib!kv.volatile.volatilespec_t.impl&%1.append_to_list. fuel%lib!kv.volatile.volatilespec_t.impl&%1.trim_list. fuel%lib!kv.volatile.volatilespec_t.impl&%1.empty. fuel%lib!kv.volatile.volatilespec_t.impl&%1.keys. fuel%lib!kv.kvimpl_v.impl&%0.recover. fuel%lib!kv.kvimpl_v.impl&%0.view. fuel%lib!kv.kvimpl_v.impl&%0.valid. fuel%lib!kv.kvspec_t.impl&%2.spec_index. fuel%lib!kv.kvspec_t.impl&%2.empty. fuel%lib!kv.kvspec_t.impl&%2.construct_view_contents. fuel%lib!kv.kvspec_t.impl&%2.create. fuel%lib!kv.kvspec_t.impl&%2.read_item_and_list. fuel%lib!kv.kvspec_t.impl&%2.read_list_entry_at_index. fuel%lib!kv.kvspec_t.impl&%2.update_item. fuel%lib!kv.kvspec_t.impl&%2.delete. fuel%lib!kv.kvspec_t.impl&%2.append_to_list. fuel%lib!kv.kvspec_t.impl&%2.append_to_list_and_update_item. fuel%lib!kv.kvspec_t.impl&%2.update_list_entry_at_index. fuel%lib!kv.kvspec_t.impl&%2.update_entry_at_index_and_item. fuel%lib!kv.kvspec_t.impl&%2.trim_list. fuel%lib!kv.kvspec_t.impl&%2.trim_list_and_update_item. fuel%lib!kv.kvspec_t.impl&%2.get_keys. fuel%vstd!array.group_array_axioms. fuel%vstd!map.group_map_axioms. fuel%vstd!multiset.group_multiset_axioms. fuel%vstd!raw_ptr.group_raw_ptr_axioms. fuel%vstd!seq.group_seq_axioms. fuel%vstd!seq_lib.group_seq_lib_default. fuel%vstd!set.group_set_axioms. fuel%vstd!set_lib.group_set_lib_axioms. fuel%vstd!slice.group_slice_axioms. fuel%vstd!string.group_string_axioms. fuel%vstd!std_specs.bits.group_bits_axioms. fuel%vstd!std_specs.control_flow.group_control_flow_axioms. fuel%vstd!std_specs.range.group_range_axioms. fuel%vstd!std_specs.vec.group_vec_axioms. fuel%vstd!group_vstd_default.))
(assert (=> (fuel_bool_default fuel%vstd!map.group_map_axioms.) (and (fuel_bool_default fuel%vstd!map.axiom_map_index_decreases_finite.) (fuel_bool_default fuel%vstd!map.axiom_map_index_decreases_infinite.) (fuel_bool_default fuel%vstd!map.axiom_map_empty.) (fuel_bool_default fuel%vstd!map.axiom_map_insert_domain.) (fuel_bool_default fuel%vstd!map.axiom_map_insert_same.) (fuel_bool_default fuel%vstd!map.axiom_map_insert_different.) (fuel_bool_default fuel%vstd!map.axiom_map_remove_domain.) (fuel_bool_default fuel%vstd!map.axiom_map_remove_different.) (fuel_bool_default fuel%vstd!map.axiom_map_ext_equal.) (fuel_bool_default fuel%vstd!map.axiom_map_ext_equal_deep.))))
(assert (=> (fuel_bool_default fuel%vstd!raw_ptr.group_raw_ptr_axioms.) (fuel_bool_default fuel%vstd!raw_ptr.ptrs_mut_eq.)))
(assert (=> (fuel_bool_default fuel%vstd!seq.group_seq_axioms.) (and (fuel_bool_default fuel%vstd!seq.axiom_seq_index_decreases.) (fuel_bool_default fuel%vstd!seq.axiom_seq_subrange_decreases.) (fuel_bool_default fuel%vstd!seq.axiom_seq_empty.) (fuel_bool_default fuel%vstd!seq.axiom_seq_push_len.) (fuel_bool_default fuel%vstd!seq.axiom_seq_push_index_same.) (fuel_bool_default fuel%vstd!seq.axiom_seq_push_index_different.) (fuel_bool_default fuel%vstd!seq.axiom_seq_update_len.) (fuel_bool_default fuel%vstd!seq.axiom_seq_update_same.) (fuel_bool_default fuel%vstd!seq.axiom_seq_update_different.) (fuel_bool_default fuel%vstd!seq.axiom_seq_ext_equal.) (fuel_bool_default fuel%vstd!seq.axiom_seq_ext_equal_deep.) (fuel_bool_default fuel%vstd!seq.axiom_seq_subrange_len.) (fuel_bool_default fuel%vstd!seq.axiom_seq_subrange_index.))))
(assert (=> (fuel_bool_default fuel%vstd!seq_lib.group_seq_lib_default.) (fuel_bool_default fuel%vstd!seq_lib.seq_to_set_is_finite.)))
(assert (=> (fuel_bool_default fuel%vstd!set.group_set_axioms.) (and (fuel_bool_default fuel%vstd!set.axiom_set_empty.) (fuel_bool_default fuel%vstd!set.axiom_set_new.) (fuel_bool_default fuel%vstd!set.axiom_set_insert_same.) (fuel_bool_default fuel%vstd!set.axiom_set_insert_different.) (fuel_bool_default fuel%vstd!set.axiom_set_remove_same.) (fuel_bool_default fuel%vstd!set.axiom_set_remove_insert.) (fuel_bool_default fuel%vstd!set.axiom_set_remove_different.) (fuel_bool_default fuel%vstd!set.axiom_set_ext_equal.) (fuel_bool_default fuel%vstd!set.axiom_set_ext_equal_deep.) (fuel_bool_default fuel%vstd!set.axiom_mk_map_domain.) (fuel_bool_default fuel%vstd!set.axiom_mk_map_index.) (fuel_bool_default fuel%vstd!set.axiom_set_empty_finite.) (fuel_bool_default fuel%vstd!set.axiom_set_insert_finite.) (fuel_bool_default fuel%vstd!set.axiom_set_remove_finite.) (fuel_bool_default fuel%vstd!set.axiom_set_empty_len.) (fuel_bool_default fuel%vstd!set.axiom_set_insert_len.) (fuel_bool_default fuel%vstd!set.axiom_set_remove_len.) (fuel_bool_default fuel%vstd!set.axiom_set_contains_len.))))
(assert (=> (fuel_bool_default fuel%vstd!set_lib.group_set_lib_axioms.) (fuel_bool_default fuel%vstd!set_lib.axiom_is_empty.)))
(assert (=> (fuel_bool_default fuel%vstd!std_specs.control_flow.group_control_flow_axioms.) (fuel_bool_default fuel%vstd!std_specs.control_flow.spec_from_blanket_identity.)))
(assert (fuel_bool_default fuel%vstd!group_vstd_default.))
(assert (=> (fuel_bool_default fuel%vstd!group_vstd_default.) (and (fuel_bool_default fuel%vstd!seq.group_seq_axioms.) (fuel_bool_default fuel%vstd!seq_lib.group_seq_lib_default.) (fuel_bool_default fuel%vstd!map.group_map_axioms.) (fuel_bool_default fuel%vstd!set.group_set_axioms.) (fuel_bool_default fuel%vstd!set_lib.group_set_lib_axioms.) (fuel_bool_default fuel%vstd!std_specs.bits.group_bits_axioms.) (fuel_bool_default fuel%vstd!std_specs.control_flow.group_control_flow_axioms.) (fuel_bool_default fuel%vstd!std_specs.vec.group_vec_axioms.) (fuel_bool_default fuel%vstd!slice.group_slice_axioms.) (fuel_bool_default fuel%vstd!array.group_array_axioms.) (fuel_bool_default fuel%vstd!multiset.group_multiset_axioms.) (fuel_bool_default fuel%vstd!string.group_string_axioms.) (fuel_bool_default fuel%vstd!std_specs.range.group_range_axioms.) (fuel_bool_default fuel%vstd!raw_ptr.group_raw_ptr_axioms.))))
(set-info :comment ";; Associated-Type-Decls")
(declare-fun proj%%vstd!view.View./V (Dcr Type) Dcr)
(declare-fun proj%vstd!view.View./V (Dcr Type) Type)
(set-info :comment ";; Datatypes")
(declare-sort core!convert.Infallible. 0)
(declare-sort vstd!map.Map<int./int.>. 0)
(declare-sort vstd!map.Map<tuple%2<int./int.>./lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.>. 0)
(declare-sort vstd!raw_ptr.DynMetadata. 0)
(declare-sort vstd!raw_ptr.Provenance. 0)
(declare-sort vstd!seq.Seq<u8.>. 0)
(declare-sort vstd!seq.Seq<vstd!seq.Seq<u8.>.>. 0)
(declare-sort vstd!set.Set<int.>. 0)
(declare-sort vstd!set.Set<tuple%2<int./int.>.>. 0)
(declare-sort allocator_global%. 0)
(declare-datatypes ((core!ops.control_flow.ControlFlow. 0) (core!option.Option. 0) (core!result.Result. 0) (core!marker.PhantomData. 0) (vstd!raw_ptr.Metadata. 0) (vstd!raw_ptr.PtrData. 0) (lib!kv.durable.durablespec_t.DurableKvStoreList. 0) (lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. 0) (lib!kv.durable.durablespec_t.DurableKvStoreView. 0) (lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. 0) (lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. 0) (lib!kv.volatile.volatilespec_t.VolatileKvIndexView. 0) (lib!kv.kvimpl_t.KvError. 0) (lib!kv.kvimpl_v.UntrustedKvStoreImpl. 0) (lib!kv.kvspec_t.AbstractKvStoreState. 0) (tuple%0. 0) (tuple%2. 0) (tuple%3. 0) (tuple%5. 0)) (((core!ops.control_flow.ControlFlow./Continue (core!ops.control_flow.ControlFlow./Continue/?0 Poly)) (core!ops.control_flow.ControlFlow./Break (core!ops.control_flow.ControlFlow./Break/?0 Poly))) ((core!option.Option./None ) (core!option.Option./Some (core!option.Option./Some/?0 Poly))) ((core!result.Result./Ok (core!result.Result./Ok/?0 Poly)) (core!result.Result./Err (core!result.Result./Err/?0 Poly))) ((core!marker.PhantomData./PhantomData )) ((vstd!raw_ptr.Metadata./Thin ) (vstd!raw_ptr.Metadata./Length (vstd!raw_ptr.Metadata./Length/?0 Int)) (vstd!raw_ptr.Metadata./Dyn (vstd!raw_ptr.Metadata./Dyn/?0 vstd!raw_ptr.DynMetadata.))) ((vstd!raw_ptr.PtrData./PtrData (vstd!raw_ptr.PtrData./PtrData/?addr Int) (vstd!raw_ptr.PtrData./PtrData/?provenance vstd!raw_ptr.Provenance.) (vstd!raw_ptr.PtrData./PtrData/?metadata vstd!raw_ptr.Metadata.))) ((lib!kv.durable.durablespec_t.DurableKvStoreList./DurableKvStoreList (lib!kv.durable.durablespec_t.DurableKvStoreList./DurableKvStoreList/?list Poly) (lib!kv.durable.durablespec_t.DurableKvStoreList./DurableKvStoreList/?node_offset_map vstd!map.Map<int./int.>.))) ((lib!kv.durable.durablespec_t.DurableKvStoreViewEntry./DurableKvStoreViewEntry (lib!kv.durable.durablespec_t.DurableKvStoreViewEntry./DurableKvStoreViewEntry/?key Poly) (lib!kv.durable.durablespec_t.DurableKvStoreViewEntry./DurableKvStoreViewEntry/?item Poly) (lib!kv.durable.durablespec_t.DurableKvStoreViewEntry./DurableKvStoreViewEntry/?list lib!kv.durable.durablespec_t.DurableKvStoreList.))) ((lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/?contents Poly) (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/?index_to_key_map Poly) (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/?_phantom core!option.Option.))) ((lib!kv.volatile.volatilespec_t.ListNodeIndexEntry./ListNodeIndexEntry (lib!kv.volatile.volatilespec_t.ListNodeIndexEntry./ListNodeIndexEntry/?start_index Int) (lib!kv.volatile.volatilespec_t.ListNodeIndexEntry./ListNodeIndexEntry/?live_index Int) (lib!kv.volatile.volatilespec_t.ListNodeIndexEntry./ListNodeIndexEntry/?physical_offset Int) (lib!kv.volatile.volatilespec_t.ListNodeIndexEntry./ListNodeIndexEntry/?free_entries Int))) ((lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry (lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry/?item_offset Int) (lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry/?list_node_offsets vstd!map.Map<tuple%2<int./int.>./lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.>.) (lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry/?list_len Int))) ((lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView (lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView/?contents Poly) (lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView/?list_entries_per_node Int))) ((lib!kv.kvimpl_t.KvError./NotImplemented ) (lib!kv.kvimpl_t.KvError./InvalidParameter ) (lib!kv.kvimpl_t.KvError./InternalError ) (lib!kv.kvimpl_t.KvError./KeyNotFound ) (lib!kv.kvimpl_t.KvError./KeyAlreadyExists ) (lib!kv.kvimpl_t.KvError./InvalidKey (lib!kv.kvimpl_t.KvError./InvalidKey/?key Poly)) (lib!kv.kvimpl_t.KvError./IndexOutOfRange ) (lib!kv.kvimpl_t.KvError./RegionTooSmall (lib!kv.kvimpl_t.KvError./RegionTooSmall/?required Int) (lib!kv.kvimpl_t.KvError./RegionTooSmall/?actual Int)) (lib!kv.kvimpl_t.KvError./OutOfSpace ) (lib!kv.kvimpl_t.KvError./InvalidPersistentMemoryRegionProvided ) (lib!kv.kvimpl_t.KvError./SerializationError (lib!kv.kvimpl_t.KvError./SerializationError/?error Poly)) (lib!kv.kvimpl_t.KvError./DeserializationError (lib!kv.kvimpl_t.KvError./DeserializationError/?error Poly))) ((lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl (lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/?id Int) (lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/?durable_store Poly) (lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/?volatile_index Poly) (lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/?entries_per_list_node Int) (lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/?_phantom core!marker.PhantomData.))) ((lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/?id Int) (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/?contents Poly) (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/?_phantom core!option.Option.))) ((tuple%0./tuple%0 )) ((tuple%2./tuple%2 (tuple%2./tuple%2/?0 Poly) (tuple%2./tuple%2/?1 Poly))) ((tuple%3./tuple%3 (tuple%3./tuple%3/?0 Poly) (tuple%3./tuple%3/?1 Poly) (tuple%3./tuple%3/?2 Poly))) ((tuple%5./tuple%5 (tuple%5./tuple%5/?0 Poly) (tuple%5./tuple%5/?1 Poly) (tuple%5./tuple%5/?2 Poly) (tuple%5./tuple%5/?3 Poly) (tuple%5./tuple%5/?4 Poly)))))
(declare-fun core!ops.control_flow.ControlFlow./Continue/0 (core!ops.control_flow.ControlFlow.) Poly)
(declare-fun core!ops.control_flow.ControlFlow./Break/0 (core!ops.control_flow.ControlFlow.) Poly)
(declare-fun core!option.Option./Some/0 (core!option.Option.) Poly)
(declare-fun core!result.Result./Ok/0 (core!result.Result.) Poly)
(declare-fun core!result.Result./Err/0 (core!result.Result.) Poly)
(declare-fun vstd!raw_ptr.Metadata./Length/0 (vstd!raw_ptr.Metadata.) Int)
(declare-fun vstd!raw_ptr.Metadata./Dyn/0 (vstd!raw_ptr.Metadata.) vstd!raw_ptr.DynMetadata.)
(declare-fun vstd!raw_ptr.PtrData./PtrData/addr (vstd!raw_ptr.PtrData.) Int)
(declare-fun vstd!raw_ptr.PtrData./PtrData/provenance (vstd!raw_ptr.PtrData.) vstd!raw_ptr.Provenance.)
(declare-fun vstd!raw_ptr.PtrData./PtrData/metadata (vstd!raw_ptr.PtrData.) vstd!raw_ptr.Metadata.)
(declare-fun lib!kv.durable.durablespec_t.DurableKvStoreList./DurableKvStoreList/list (lib!kv.durable.durablespec_t.DurableKvStoreList.) Poly)
(declare-fun lib!kv.durable.durablespec_t.DurableKvStoreList./DurableKvStoreList/node_offset_map (lib!kv.durable.durablespec_t.DurableKvStoreList.) vstd!map.Map<int./int.>.)
(declare-fun lib!kv.durable.durablespec_t.DurableKvStoreViewEntry./DurableKvStoreViewEntry/key (lib!kv.durable.durablespec_t.DurableKvStoreViewEntry.) Poly)
(declare-fun lib!kv.durable.durablespec_t.DurableKvStoreViewEntry./DurableKvStoreViewEntry/item (lib!kv.durable.durablespec_t.DurableKvStoreViewEntry.) Poly)
(declare-fun lib!kv.durable.durablespec_t.DurableKvStoreViewEntry./DurableKvStoreViewEntry/list (lib!kv.durable.durablespec_t.DurableKvStoreViewEntry.) lib!kv.durable.durablespec_t.DurableKvStoreList.)
(declare-fun lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/contents (lib!kv.durable.durablespec_t.DurableKvStoreView.) Poly)
(declare-fun lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/index_to_key_map (lib!kv.durable.durablespec_t.DurableKvStoreView.) Poly)
(declare-fun lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/_phantom (lib!kv.durable.durablespec_t.DurableKvStoreView.) core!option.Option.)
(declare-fun lib!kv.volatile.volatilespec_t.ListNodeIndexEntry./ListNodeIndexEntry/start_index (lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.) Int)
(declare-fun lib!kv.volatile.volatilespec_t.ListNodeIndexEntry./ListNodeIndexEntry/live_index (lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.) Int)
(declare-fun lib!kv.volatile.volatilespec_t.ListNodeIndexEntry./ListNodeIndexEntry/physical_offset (lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.) Int)
(declare-fun lib!kv.volatile.volatilespec_t.ListNodeIndexEntry./ListNodeIndexEntry/free_entries (lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.) Int)
(declare-fun lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry/item_offset (lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry.) Int)
(declare-fun lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry/list_node_offsets (lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry.) vstd!map.Map<tuple%2<int./int.>./lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.>.)
(declare-fun lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry/list_len (lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry.) Int)
(declare-fun lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView/contents (lib!kv.volatile.volatilespec_t.VolatileKvIndexView.) Poly)
(declare-fun lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView/list_entries_per_node (lib!kv.volatile.volatilespec_t.VolatileKvIndexView.) Int)
(declare-fun lib!kv.kvimpl_t.KvError./InvalidKey/key (lib!kv.kvimpl_t.KvError.) Poly)
(declare-fun lib!kv.kvimpl_t.KvError./RegionTooSmall/required (lib!kv.kvimpl_t.KvError.) Int)
(declare-fun lib!kv.kvimpl_t.KvError./RegionTooSmall/actual (lib!kv.kvimpl_t.KvError.) Int)
(declare-fun lib!kv.kvimpl_t.KvError./SerializationError/error (lib!kv.kvimpl_t.KvError.) Poly)
(declare-fun lib!kv.kvimpl_t.KvError./DeserializationError/error (lib!kv.kvimpl_t.KvError.) Poly)
(declare-fun lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/id (lib!kv.kvimpl_v.UntrustedKvStoreImpl.) Int)
(declare-fun lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/durable_store (lib!kv.kvimpl_v.UntrustedKvStoreImpl.) Poly)
(declare-fun lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/volatile_index (lib!kv.kvimpl_v.UntrustedKvStoreImpl.) Poly)
(declare-fun lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/entries_per_list_node (lib!kv.kvimpl_v.UntrustedKvStoreImpl.) Int)
(declare-fun lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/_phantom (lib!kv.kvimpl_v.UntrustedKvStoreImpl.) core!marker.PhantomData.)
(declare-fun lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/id (lib!kv.kvspec_t.AbstractKvStoreState.) Int)
(declare-fun lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/contents (lib!kv.kvspec_t.AbstractKvStoreState.) Poly)
(declare-fun lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/_phantom (lib!kv.kvspec_t.AbstractKvStoreState.) core!option.Option.)
(declare-fun tuple%2./tuple%2/0 (tuple%2.) Poly)
(declare-fun tuple%2./tuple%2/1 (tuple%2.) Poly)
(declare-fun tuple%3./tuple%3/0 (tuple%3.) Poly)
(declare-fun tuple%3./tuple%3/1 (tuple%3.) Poly)
(declare-fun tuple%3./tuple%3/2 (tuple%3.) Poly)
(declare-fun tuple%5./tuple%5/0 (tuple%5.) Poly)
(declare-fun tuple%5./tuple%5/1 (tuple%5.) Poly)
(declare-fun tuple%5./tuple%5/2 (tuple%5.) Poly)
(declare-fun tuple%5./tuple%5/3 (tuple%5.) Poly)
(declare-fun tuple%5./tuple%5/4 (tuple%5.) Poly)
(declare-fun TYPE%fun%1. (Dcr Type Dcr Type) Type)
(declare-fun TYPE%core!ops.control_flow.ControlFlow. (Dcr Type Dcr Type) Type)
(declare-const TYPE%core!convert.Infallible. Type)
(declare-fun TYPE%core!option.Option. (Dcr Type) Type)
(declare-fun TYPE%core!result.Result. (Dcr Type Dcr Type) Type)
(declare-fun TYPE%core!marker.PhantomData. (Dcr Type) Type)
(declare-fun TYPE%alloc!vec.Vec. (Dcr Type Dcr Type) Type)
(declare-fun TYPE%vstd!map.Map. (Dcr Type Dcr Type) Type)
(declare-const TYPE%vstd!raw_ptr.Provenance. Type)
(declare-const TYPE%vstd!raw_ptr.Metadata. Type)
(declare-const TYPE%vstd!raw_ptr.DynMetadata. Type)
(declare-const TYPE%vstd!raw_ptr.PtrData. Type)
(declare-fun TYPE%vstd!seq.Seq. (Dcr Type) Type)
(declare-fun TYPE%vstd!set.Set. (Dcr Type) Type)
(declare-fun TYPE%lib!kv.durable.durablespec_t.DurableKvStoreList. (Dcr Type) Type)
(declare-fun TYPE%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. (Dcr Type Dcr Type Dcr Type) Type)
(declare-fun TYPE%lib!kv.durable.durablespec_t.DurableKvStoreView. (Dcr Type Dcr Type Dcr Type Dcr Type) Type)
(declare-const TYPE%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. Type)
(declare-const TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. Type)
(declare-fun TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. (Dcr Type) Type)
(declare-fun TYPE%lib!kv.kvimpl_t.KvError. (Dcr Type Dcr Type) Type)
(declare-fun TYPE%lib!kv.kvimpl_v.UntrustedKvStoreImpl. (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type) Type)
(declare-fun TYPE%lib!kv.kvspec_t.TrustedKvPermission. (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type) Type)
(declare-fun TYPE%lib!kv.kvspec_t.AbstractKvStoreState. (Dcr Type Dcr Type Dcr Type Dcr Type) Type)
(declare-const TYPE%tuple%0. Type)
(declare-fun TYPE%tuple%2. (Dcr Type Dcr Type) Type)
(declare-fun TYPE%tuple%3. (Dcr Type Dcr Type Dcr Type) Type)
(declare-fun TYPE%tuple%5. (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type) Type)
(declare-fun Poly%fun%1. (%%Function%%) Poly)
(declare-fun %Poly%fun%1. (Poly) %%Function%%)
(declare-fun Poly%core!convert.Infallible. (core!convert.Infallible.) Poly)
(declare-fun %Poly%core!convert.Infallible. (Poly) core!convert.Infallible.)
(declare-fun Poly%vstd!map.Map<int./int.>. (vstd!map.Map<int./int.>.) Poly)
(declare-fun %Poly%vstd!map.Map<int./int.>. (Poly) vstd!map.Map<int./int.>.)
(declare-fun Poly%vstd!map.Map<tuple%2<int./int.>./lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.>. (vstd!map.Map<tuple%2<int./int.>./lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.>.) Poly)
(declare-fun %Poly%vstd!map.Map<tuple%2<int./int.>./lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.>. (Poly) vstd!map.Map<tuple%2<int./int.>./lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.>.)
(declare-fun Poly%vstd!raw_ptr.DynMetadata. (vstd!raw_ptr.DynMetadata.) Poly)
(declare-fun %Poly%vstd!raw_ptr.DynMetadata. (Poly) vstd!raw_ptr.DynMetadata.)
(declare-fun Poly%vstd!raw_ptr.Provenance. (vstd!raw_ptr.Provenance.) Poly)
(declare-fun %Poly%vstd!raw_ptr.Provenance. (Poly) vstd!raw_ptr.Provenance.)
(declare-fun Poly%vstd!seq.Seq<u8.>. (vstd!seq.Seq<u8.>.) Poly)
(declare-fun %Poly%vstd!seq.Seq<u8.>. (Poly) vstd!seq.Seq<u8.>.)
(declare-fun Poly%vstd!seq.Seq<vstd!seq.Seq<u8.>.>. (vstd!seq.Seq<vstd!seq.Seq<u8.>.>.) Poly)
(declare-fun %Poly%vstd!seq.Seq<vstd!seq.Seq<u8.>.>. (Poly) vstd!seq.Seq<vstd!seq.Seq<u8.>.>.)
(declare-fun Poly%vstd!set.Set<int.>. (vstd!set.Set<int.>.) Poly)
(declare-fun %Poly%vstd!set.Set<int.>. (Poly) vstd!set.Set<int.>.)
(declare-fun Poly%vstd!set.Set<tuple%2<int./int.>.>. (vstd!set.Set<tuple%2<int./int.>.>.) Poly)
(declare-fun %Poly%vstd!set.Set<tuple%2<int./int.>.>. (Poly) vstd!set.Set<tuple%2<int./int.>.>.)
(declare-fun Poly%allocator_global%. (allocator_global%.) Poly)
(declare-fun %Poly%allocator_global%. (Poly) allocator_global%.)
(declare-fun Poly%core!ops.control_flow.ControlFlow. (core!ops.control_flow.ControlFlow.) Poly)
(declare-fun %Poly%core!ops.control_flow.ControlFlow. (Poly) core!ops.control_flow.ControlFlow.)
(declare-fun Poly%core!option.Option. (core!option.Option.) Poly)
(declare-fun %Poly%core!option.Option. (Poly) core!option.Option.)
(declare-fun Poly%core!result.Result. (core!result.Result.) Poly)
(declare-fun %Poly%core!result.Result. (Poly) core!result.Result.)
(declare-fun Poly%core!marker.PhantomData. (core!marker.PhantomData.) Poly)
(declare-fun %Poly%core!marker.PhantomData. (Poly) core!marker.PhantomData.)
(declare-fun Poly%vstd!raw_ptr.Metadata. (vstd!raw_ptr.Metadata.) Poly)
(declare-fun %Poly%vstd!raw_ptr.Metadata. (Poly) vstd!raw_ptr.Metadata.)
(declare-fun Poly%vstd!raw_ptr.PtrData. (vstd!raw_ptr.PtrData.) Poly)
(declare-fun %Poly%vstd!raw_ptr.PtrData. (Poly) vstd!raw_ptr.PtrData.)
(declare-fun Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (lib!kv.durable.durablespec_t.DurableKvStoreList.) Poly)
(declare-fun %Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (Poly) lib!kv.durable.durablespec_t.DurableKvStoreList.)
(declare-fun Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. (lib!kv.durable.durablespec_t.DurableKvStoreViewEntry.) Poly)
(declare-fun %Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. (Poly) lib!kv.durable.durablespec_t.DurableKvStoreViewEntry.)
(declare-fun Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. (lib!kv.durable.durablespec_t.DurableKvStoreView.) Poly)
(declare-fun %Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. (Poly) lib!kv.durable.durablespec_t.DurableKvStoreView.)
(declare-fun Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. (lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.) Poly)
(declare-fun %Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. (Poly) lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.)
(declare-fun Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry.) Poly)
(declare-fun %Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (Poly) lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry.)
(declare-fun Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. (lib!kv.volatile.volatilespec_t.VolatileKvIndexView.) Poly)
(declare-fun %Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. (Poly) lib!kv.volatile.volatilespec_t.VolatileKvIndexView.)
(declare-fun Poly%lib!kv.kvimpl_t.KvError. (lib!kv.kvimpl_t.KvError.) Poly)
(declare-fun %Poly%lib!kv.kvimpl_t.KvError. (Poly) lib!kv.kvimpl_t.KvError.)
(declare-fun Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. (lib!kv.kvimpl_v.UntrustedKvStoreImpl.) Poly)
(declare-fun %Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. (Poly) lib!kv.kvimpl_v.UntrustedKvStoreImpl.)
(declare-fun Poly%lib!kv.kvspec_t.AbstractKvStoreState. (lib!kv.kvspec_t.AbstractKvStoreState.) Poly)
(declare-fun %Poly%lib!kv.kvspec_t.AbstractKvStoreState. (Poly) lib!kv.kvspec_t.AbstractKvStoreState.)
(declare-fun Poly%tuple%0. (tuple%0.) Poly)
(declare-fun %Poly%tuple%0. (Poly) tuple%0.)
(declare-fun Poly%tuple%2. (tuple%2.) Poly)
(declare-fun %Poly%tuple%2. (Poly) tuple%2.)
(declare-fun Poly%tuple%3. (tuple%3.) Poly)
(declare-fun %Poly%tuple%3. (Poly) tuple%3.)
(declare-fun Poly%tuple%5. (tuple%5.) Poly)
(declare-fun %Poly%tuple%5. (Poly) tuple%5.)
(assert (forall ((x %%Function%%)) (! (= x (%Poly%fun%1. (Poly%fun%1. x))) :pattern ((Poly%fun%1. x)) )))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (x Poly)) (! (=> (has_type x (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)) (= x (Poly%fun%1. (%Poly%fun%1. x)))) :pattern ((has_type x (TYPE%fun%1. T%0&. T%0& T%1&. T%1&))) )))
(declare-fun %%apply%%0 (%%Function%% Poly) Poly)
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (x %%Function%%)) (! (=> (forall ((T%0 Poly)) (! (=> (has_type T%0 T%0&) (has_type (%%apply%%0 x T%0) T%1&)) :pattern ((has_type (%%apply%%0 x T%0) T%1&)) )) (has_type (Poly%fun%1. (mk_fun x)) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&))) :pattern ((has_type (Poly%fun%1. (mk_fun x)) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&))) )))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (T%0 Poly) (x %%Function%%)) (! (=> (and (has_type (Poly%fun%1. x) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)) (has_type T%0 T%0&)) (has_type (%%apply%%0 x T%0) T%1&)) :pattern ((%%apply%%0 x T%0) (has_type (Poly%fun%1. x) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&))) )))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (T%0 Poly) (x %%Function%%)) (! (=> (and (has_type (Poly%fun%1. x) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)) (has_type T%0 T%0&)) (height_lt (height (%%apply%%0 x T%0)) (height (fun_from_recursive_field (Poly%fun%1. (mk_fun x)))))) :pattern ((height (%%apply%%0 x T%0)) (has_type (Poly%fun%1. x) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&))) )))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (deep Bool) (x Poly) (y Poly)) (! (=> (and (has_type x (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)) (has_type y (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)) (forall ((T%0 Poly)) (! (=> (has_type T%0 T%0&) (ext_eq deep T%1& (%%apply%%0 (%Poly%fun%1. x) T%0) (%%apply%%0 (%Poly%fun%1. y) T%0))) :pattern ((ext_eq deep T%1& (%%apply%%0 (%Poly%fun%1. x) T%0) (%%apply%%0 (%Poly%fun%1. y) T%0))) ))) (ext_eq deep (TYPE%fun%1. T%0&. T%0& T%1&. T%1&) x y)) :pattern ((ext_eq deep (TYPE%fun%1. T%0&. T%0& T%1&. T%1&) x y)) )))
(assert (forall ((x core!convert.Infallible.)) (! (= x (%Poly%core!convert.Infallible. (Poly%core!convert.Infallible. x))) :pattern ((Poly%core!convert.Infallible. x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%core!convert.Infallible.) (= x (Poly%core!convert.Infallible. (%Poly%core!convert.Infallible. x)))) :pattern ((has_type x TYPE%core!convert.Infallible.)) )))
(assert (forall ((x core!convert.Infallible.)) (! (has_type (Poly%core!convert.Infallible. x) TYPE%core!convert.Infallible.) :pattern ((has_type (Poly%core!convert.Infallible. x) TYPE%core!convert.Infallible.)) )))
(assert (forall ((x vstd!map.Map<int./int.>.)) (! (= x (%Poly%vstd!map.Map<int./int.>. (Poly%vstd!map.Map<int./int.>. x))) :pattern ((Poly%vstd!map.Map<int./int.>. x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x (TYPE%vstd!map.Map. $ INT $ INT)) (= x (Poly%vstd!map.Map<int./int.>. (%Poly%vstd!map.Map<int./int.>. x)))) :pattern ((has_type x (TYPE%vstd!map.Map. $ INT $ INT))) )))
(assert (forall ((x vstd!map.Map<int./int.>.)) (! (has_type (Poly%vstd!map.Map<int./int.>. x) (TYPE%vstd!map.Map. $ INT $ INT)) :pattern ((has_type (Poly%vstd!map.Map<int./int.>. x) (TYPE%vstd!map.Map. $ INT $ INT))) )))
(assert (forall ((x vstd!map.Map<tuple%2<int./int.>./lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.>.)) (! (= x (%Poly%vstd!map.Map<tuple%2<int./int.>./lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.>. (Poly%vstd!map.Map<tuple%2<int./int.>./lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.>. x))) :pattern ((Poly%vstd!map.Map<tuple%2<int./int.>./lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.>. x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x (TYPE%vstd!map.Map. $ (TYPE%tuple%2. $ INT $ INT) $ TYPE%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.)) (= x (Poly%vstd!map.Map<tuple%2<int./int.>./lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.>. (%Poly%vstd!map.Map<tuple%2<int./int.>./lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.>. x)))) :pattern ((has_type x (TYPE%vstd!map.Map. $ (TYPE%tuple%2. $ INT $ INT) $ TYPE%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.))) )))
(assert (forall ((x vstd!map.Map<tuple%2<int./int.>./lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.>.)) (! (has_type (Poly%vstd!map.Map<tuple%2<int./int.>./lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.>. x) (TYPE%vstd!map.Map. $ (TYPE%tuple%2. $ INT $ INT) $ TYPE%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.)) :pattern ((has_type (Poly%vstd!map.Map<tuple%2<int./int.>./lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.>. x) (TYPE%vstd!map.Map. $ (TYPE%tuple%2. $ INT $ INT) $ TYPE%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.))) )))
(assert (forall ((x vstd!raw_ptr.DynMetadata.)) (! (= x (%Poly%vstd!raw_ptr.DynMetadata. (Poly%vstd!raw_ptr.DynMetadata. x))) :pattern ((Poly%vstd!raw_ptr.DynMetadata. x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%vstd!raw_ptr.DynMetadata.) (= x (Poly%vstd!raw_ptr.DynMetadata. (%Poly%vstd!raw_ptr.DynMetadata. x)))) :pattern ((has_type x TYPE%vstd!raw_ptr.DynMetadata.)) )))
(assert (forall ((x vstd!raw_ptr.DynMetadata.)) (! (has_type (Poly%vstd!raw_ptr.DynMetadata. x) TYPE%vstd!raw_ptr.DynMetadata.) :pattern ((has_type (Poly%vstd!raw_ptr.DynMetadata. x) TYPE%vstd!raw_ptr.DynMetadata.)) )))
(assert (forall ((x vstd!raw_ptr.Provenance.)) (! (= x (%Poly%vstd!raw_ptr.Provenance. (Poly%vstd!raw_ptr.Provenance. x))) :pattern ((Poly%vstd!raw_ptr.Provenance. x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%vstd!raw_ptr.Provenance.) (= x (Poly%vstd!raw_ptr.Provenance. (%Poly%vstd!raw_ptr.Provenance. x)))) :pattern ((has_type x TYPE%vstd!raw_ptr.Provenance.)) )))
(assert (forall ((x vstd!raw_ptr.Provenance.)) (! (has_type (Poly%vstd!raw_ptr.Provenance. x) TYPE%vstd!raw_ptr.Provenance.) :pattern ((has_type (Poly%vstd!raw_ptr.Provenance. x) TYPE%vstd!raw_ptr.Provenance.)) )))
(assert (forall ((x vstd!seq.Seq<u8.>.)) (! (= x (%Poly%vstd!seq.Seq<u8.>. (Poly%vstd!seq.Seq<u8.>. x))) :pattern ((Poly%vstd!seq.Seq<u8.>. x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x (TYPE%vstd!seq.Seq. $ (UINT 8))) (= x (Poly%vstd!seq.Seq<u8.>. (%Poly%vstd!seq.Seq<u8.>. x)))) :pattern ((has_type x (TYPE%vstd!seq.Seq. $ (UINT 8)))) )))
(assert (forall ((x vstd!seq.Seq<u8.>.)) (! (has_type (Poly%vstd!seq.Seq<u8.>. x) (TYPE%vstd!seq.Seq. $ (UINT 8))) :pattern ((has_type (Poly%vstd!seq.Seq<u8.>. x) (TYPE%vstd!seq.Seq. $ (UINT 8)))) )))
(assert (forall ((x vstd!seq.Seq<vstd!seq.Seq<u8.>.>.)) (! (= x (%Poly%vstd!seq.Seq<vstd!seq.Seq<u8.>.>. (Poly%vstd!seq.Seq<vstd!seq.Seq<u8.>.>. x))) :pattern ((Poly%vstd!seq.Seq<vstd!seq.Seq<u8.>.>. x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ (UINT 8)))) (= x (Poly%vstd!seq.Seq<vstd!seq.Seq<u8.>.>. (%Poly%vstd!seq.Seq<vstd!seq.Seq<u8.>.>. x)))) :pattern ((has_type x (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ (UINT 8))))) )))
(assert (forall ((x vstd!seq.Seq<vstd!seq.Seq<u8.>.>.)) (! (has_type (Poly%vstd!seq.Seq<vstd!seq.Seq<u8.>.>. x) (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ (UINT 8)))) :pattern ((has_type (Poly%vstd!seq.Seq<vstd!seq.Seq<u8.>.>. x) (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ (UINT 8))))) )))
(assert (forall ((x vstd!set.Set<int.>.)) (! (= x (%Poly%vstd!set.Set<int.>. (Poly%vstd!set.Set<int.>. x))) :pattern ((Poly%vstd!set.Set<int.>. x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x (TYPE%vstd!set.Set. $ INT)) (= x (Poly%vstd!set.Set<int.>. (%Poly%vstd!set.Set<int.>. x)))) :pattern ((has_type x (TYPE%vstd!set.Set. $ INT))) )))
(assert (forall ((x vstd!set.Set<int.>.)) (! (has_type (Poly%vstd!set.Set<int.>. x) (TYPE%vstd!set.Set. $ INT)) :pattern ((has_type (Poly%vstd!set.Set<int.>. x) (TYPE%vstd!set.Set. $ INT))) )))
(assert (forall ((x vstd!set.Set<tuple%2<int./int.>.>.)) (! (= x (%Poly%vstd!set.Set<tuple%2<int./int.>.>. (Poly%vstd!set.Set<tuple%2<int./int.>.>. x))) :pattern ((Poly%vstd!set.Set<tuple%2<int./int.>.>. x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x (TYPE%vstd!set.Set. $ (TYPE%tuple%2. $ INT $ INT))) (= x (Poly%vstd!set.Set<tuple%2<int./int.>.>. (%Poly%vstd!set.Set<tuple%2<int./int.>.>. x)))) :pattern ((has_type x (TYPE%vstd!set.Set. $ (TYPE%tuple%2. $ INT $ INT)))) )))
(assert (forall ((x vstd!set.Set<tuple%2<int./int.>.>.)) (! (has_type (Poly%vstd!set.Set<tuple%2<int./int.>.>. x) (TYPE%vstd!set.Set. $ (TYPE%tuple%2. $ INT $ INT))) :pattern ((has_type (Poly%vstd!set.Set<tuple%2<int./int.>.>. x) (TYPE%vstd!set.Set. $ (TYPE%tuple%2. $ INT $ INT)))) )))
(assert (forall ((x allocator_global%.)) (! (= x (%Poly%allocator_global%. (Poly%allocator_global%. x))) :pattern ((Poly%allocator_global%. x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x ALLOCATOR_GLOBAL) (= x (Poly%allocator_global%. (%Poly%allocator_global%. x)))) :pattern ((has_type x ALLOCATOR_GLOBAL)) )))
(assert (forall ((x allocator_global%.)) (! (has_type (Poly%allocator_global%. x) ALLOCATOR_GLOBAL) :pattern ((has_type (Poly%allocator_global%. x) ALLOCATOR_GLOBAL)) )))
(assert (forall ((x core!ops.control_flow.ControlFlow.)) (! (= x (%Poly%core!ops.control_flow.ControlFlow. (Poly%core!ops.control_flow.ControlFlow. x))) :pattern ((Poly%core!ops.control_flow.ControlFlow. x)) )))
(assert (forall ((B&. Dcr) (B& Type) (C&. Dcr) (C& Type) (x Poly)) (! (=> (has_type x (TYPE%core!ops.control_flow.ControlFlow. B&. B& C&. C&)) (= x (Poly%core!ops.control_flow.ControlFlow. (%Poly%core!ops.control_flow.ControlFlow. x)))) :pattern ((has_type x (TYPE%core!ops.control_flow.ControlFlow. B&. B& C&. C&))) )))
(assert (forall ((B&. Dcr) (B& Type) (C&. Dcr) (C& Type) (_0! Poly)) (! (=> (has_type _0! C&) (has_type (Poly%core!ops.control_flow.ControlFlow. (core!ops.control_flow.ControlFlow./Continue _0!)) (TYPE%core!ops.control_flow.ControlFlow. B&. B& C&. C&))) :pattern ((has_type (Poly%core!ops.control_flow.ControlFlow. (core!ops.control_flow.ControlFlow./Continue _0!)) (TYPE%core!ops.control_flow.ControlFlow. B&. B& C&. C&))) )))
(assert (forall ((x core!ops.control_flow.ControlFlow.)) (! (= (core!ops.control_flow.ControlFlow./Continue/0 x) (core!ops.control_flow.ControlFlow./Continue/?0 x)) :pattern ((core!ops.control_flow.ControlFlow./Continue/0 x)) )))
(assert (forall ((B&. Dcr) (B& Type) (C&. Dcr) (C& Type) (x Poly)) (! (=> (has_type x (TYPE%core!ops.control_flow.ControlFlow. B&. B& C&. C&)) (has_type (core!ops.control_flow.ControlFlow./Continue/0 (%Poly%core!ops.control_flow.ControlFlow. x)) C&)) :pattern ((core!ops.control_flow.ControlFlow./Continue/0 (%Poly%core!ops.control_flow.ControlFlow. x)) (has_type x (TYPE%core!ops.control_flow.ControlFlow. B&. B& C&. C&))) )))
(assert (forall ((B&. Dcr) (B& Type) (C&. Dcr) (C& Type) (_0! Poly)) (! (=> (has_type _0! B&) (has_type (Poly%core!ops.control_flow.ControlFlow. (core!ops.control_flow.ControlFlow./Break _0!)) (TYPE%core!ops.control_flow.ControlFlow. B&. B& C&. C&))) :pattern ((has_type (Poly%core!ops.control_flow.ControlFlow. (core!ops.control_flow.ControlFlow./Break _0!)) (TYPE%core!ops.control_flow.ControlFlow. B&. B& C&. C&))) )))
(assert (forall ((x core!ops.control_flow.ControlFlow.)) (! (= (core!ops.control_flow.ControlFlow./Break/0 x) (core!ops.control_flow.ControlFlow./Break/?0 x)) :pattern ((core!ops.control_flow.ControlFlow./Break/0 x)) )))
(assert (forall ((B&. Dcr) (B& Type) (C&. Dcr) (C& Type) (x Poly)) (! (=> (has_type x (TYPE%core!ops.control_flow.ControlFlow. B&. B& C&. C&)) (has_type (core!ops.control_flow.ControlFlow./Break/0 (%Poly%core!ops.control_flow.ControlFlow. x)) B&)) :pattern ((core!ops.control_flow.ControlFlow./Break/0 (%Poly%core!ops.control_flow.ControlFlow. x)) (has_type x (TYPE%core!ops.control_flow.ControlFlow. B&. B& C&. C&))) )))
(define-fun is-core!ops.control_flow.ControlFlow./Continue_ ((c core!ops.control_flow.ControlFlow.)) Bool ((_ is core!ops.control_flow.ControlFlow./Continue) c))
(assert (forall ((x core!ops.control_flow.ControlFlow.)) (! (=> (is-core!ops.control_flow.ControlFlow./Continue_ x) (height_lt (height (core!ops.control_flow.ControlFlow./Continue/0 x)) (height (Poly%core!ops.control_flow.ControlFlow. x)))) :pattern ((height (core!ops.control_flow.ControlFlow./Continue/0 x))) )))
(define-fun is-core!ops.control_flow.ControlFlow./Break_ ((c core!ops.control_flow.ControlFlow.)) Bool ((_ is core!ops.control_flow.ControlFlow./Break) c))
(assert (forall ((x core!ops.control_flow.ControlFlow.)) (! (=> (is-core!ops.control_flow.ControlFlow./Break_ x) (height_lt (height (core!ops.control_flow.ControlFlow./Break/0 x)) (height (Poly%core!ops.control_flow.ControlFlow. x)))) :pattern ((height (core!ops.control_flow.ControlFlow./Break/0 x))) )))
(assert (forall ((x core!option.Option.)) (! (= x (%Poly%core!option.Option. (Poly%core!option.Option. x))) :pattern ((Poly%core!option.Option. x)) )))
(assert (forall ((V&. Dcr) (V& Type) (x Poly)) (! (=> (has_type x (TYPE%core!option.Option. V&. V&)) (= x (Poly%core!option.Option. (%Poly%core!option.Option. x)))) :pattern ((has_type x (TYPE%core!option.Option. V&. V&))) )))
(assert (forall ((V&. Dcr) (V& Type)) (! (has_type (Poly%core!option.Option. core!option.Option./None) (TYPE%core!option.Option. V&. V&)) :pattern ((has_type (Poly%core!option.Option. core!option.Option./None) (TYPE%core!option.Option. V&. V&))) )))
(assert (forall ((V&. Dcr) (V& Type) (_0! Poly)) (! (=> (has_type _0! V&) (has_type (Poly%core!option.Option. (core!option.Option./Some _0!)) (TYPE%core!option.Option. V&. V&))) :pattern ((has_type (Poly%core!option.Option. (core!option.Option./Some _0!)) (TYPE%core!option.Option. V&. V&))) )))
(assert (forall ((x core!option.Option.)) (! (= (core!option.Option./Some/0 x) (core!option.Option./Some/?0 x)) :pattern ((core!option.Option./Some/0 x)) )))
(assert (forall ((V&. Dcr) (V& Type) (x Poly)) (! (=> (has_type x (TYPE%core!option.Option. V&. V&)) (has_type (core!option.Option./Some/0 (%Poly%core!option.Option. x)) V&)) :pattern ((core!option.Option./Some/0 (%Poly%core!option.Option. x)) (has_type x (TYPE%core!option.Option. V&. V&))) )))
(define-fun is-core!option.Option./Some_ ((c core!option.Option.)) Bool ((_ is core!option.Option./Some) c))
(assert (forall ((x core!option.Option.)) (! (=> (is-core!option.Option./Some_ x) (height_lt (height (core!option.Option./Some/0 x)) (height (Poly%core!option.Option. x)))) :pattern ((height (core!option.Option./Some/0 x))) )))
(define-fun is-core!option.Option./None_ ((c core!option.Option.)) Bool ((_ is core!option.Option./None) c))
(assert (forall ((V&. Dcr) (V& Type) (deep Bool) (x Poly) (y Poly)) (! (=> (and (has_type x (TYPE%core!option.Option. V&. V&)) (has_type y (TYPE%core!option.Option. V&. V&)) (is-core!option.Option./None_ (%Poly%core!option.Option. x)) (is-core!option.Option./None_ (%Poly%core!option.Option. y))) (ext_eq deep (TYPE%core!option.Option. V&. V&) x y)) :pattern ((ext_eq deep (TYPE%core!option.Option. V&. V&) x y)) )))
(assert (forall ((V&. Dcr) (V& Type) (deep Bool) (x Poly) (y Poly)) (! (=> (and (has_type x (TYPE%core!option.Option. V&. V&)) (has_type y (TYPE%core!option.Option. V&. V&)) (is-core!option.Option./Some_ (%Poly%core!option.Option. x)) (is-core!option.Option./Some_ (%Poly%core!option.Option. y)) (ext_eq deep V& (core!option.Option./Some/0 (%Poly%core!option.Option. x)) (core!option.Option./Some/0 (%Poly%core!option.Option. y)))) (ext_eq deep (TYPE%core!option.Option. V&. V&) x y)) :pattern ((ext_eq deep (TYPE%core!option.Option. V&. V&) x y)) )))
(assert (forall ((x core!result.Result.)) (! (= x (%Poly%core!result.Result. (Poly%core!result.Result. x))) :pattern ((Poly%core!result.Result. x)) )))
(assert (forall ((T&. Dcr) (T& Type) (E&. Dcr) (E& Type) (x Poly)) (! (=> (has_type x (TYPE%core!result.Result. T&. T& E&. E&)) (= x (Poly%core!result.Result. (%Poly%core!result.Result. x)))) :pattern ((has_type x (TYPE%core!result.Result. T&. T& E&. E&))) )))
(assert (forall ((T&. Dcr) (T& Type) (E&. Dcr) (E& Type) (_0! Poly)) (! (=> (has_type _0! T&) (has_type (Poly%core!result.Result. (core!result.Result./Ok _0!)) (TYPE%core!result.Result. T&. T& E&. E&))) :pattern ((has_type (Poly%core!result.Result. (core!result.Result./Ok _0!)) (TYPE%core!result.Result. T&. T& E&. E&))) )))
(assert (forall ((x core!result.Result.)) (! (= (core!result.Result./Ok/0 x) (core!result.Result./Ok/?0 x)) :pattern ((core!result.Result./Ok/0 x)) )))
(assert (forall ((T&. Dcr) (T& Type) (E&. Dcr) (E& Type) (x Poly)) (! (=> (has_type x (TYPE%core!result.Result. T&. T& E&. E&)) (has_type (core!result.Result./Ok/0 (%Poly%core!result.Result. x)) T&)) :pattern ((core!result.Result./Ok/0 (%Poly%core!result.Result. x)) (has_type x (TYPE%core!result.Result. T&. T& E&. E&))) )))
(assert (forall ((T&. Dcr) (T& Type) (E&. Dcr) (E& Type) (_0! Poly)) (! (=> (has_type _0! E&) (has_type (Poly%core!result.Result. (core!result.Result./Err _0!)) (TYPE%core!result.Result. T&. T& E&. E&))) :pattern ((has_type (Poly%core!result.Result. (core!result.Result./Err _0!)) (TYPE%core!result.Result. T&. T& E&. E&))) )))
(assert (forall ((x core!result.Result.)) (! (= (core!result.Result./Err/0 x) (core!result.Result./Err/?0 x)) :pattern ((core!result.Result./Err/0 x)) )))
(assert (forall ((T&. Dcr) (T& Type) (E&. Dcr) (E& Type) (x Poly)) (! (=> (has_type x (TYPE%core!result.Result. T&. T& E&. E&)) (has_type (core!result.Result./Err/0 (%Poly%core!result.Result. x)) E&)) :pattern ((core!result.Result./Err/0 (%Poly%core!result.Result. x)) (has_type x (TYPE%core!result.Result. T&. T& E&. E&))) )))
(define-fun is-core!result.Result./Ok_ ((c core!result.Result.)) Bool ((_ is core!result.Result./Ok) c))
(assert (forall ((x core!result.Result.)) (! (=> (is-core!result.Result./Ok_ x) (height_lt (height (core!result.Result./Ok/0 x)) (height (Poly%core!result.Result. x)))) :pattern ((height (core!result.Result./Ok/0 x))) )))
(define-fun is-core!result.Result./Err_ ((c core!result.Result.)) Bool ((_ is core!result.Result./Err) c))
(assert (forall ((x core!result.Result.)) (! (=> (is-core!result.Result./Err_ x) (height_lt (height (core!result.Result./Err/0 x)) (height (Poly%core!result.Result. x)))) :pattern ((height (core!result.Result./Err/0 x))) )))
(assert (forall ((x core!marker.PhantomData.)) (! (= x (%Poly%core!marker.PhantomData. (Poly%core!marker.PhantomData. x))) :pattern ((Poly%core!marker.PhantomData. x)) )))
(assert (forall ((V&. Dcr) (V& Type) (x Poly)) (! (=> (has_type x (TYPE%core!marker.PhantomData. V&. V&)) (= x (Poly%core!marker.PhantomData. (%Poly%core!marker.PhantomData. x)))) :pattern ((has_type x (TYPE%core!marker.PhantomData. V&. V&))) )))
(assert (forall ((V&. Dcr) (V& Type) (x core!marker.PhantomData.)) (! (has_type (Poly%core!marker.PhantomData. x) (TYPE%core!marker.PhantomData. V&. V&)) :pattern ((has_type (Poly%core!marker.PhantomData. x) (TYPE%core!marker.PhantomData. V&. V&))) )))
(assert (forall ((x vstd!raw_ptr.Metadata.)) (! (= x (%Poly%vstd!raw_ptr.Metadata. (Poly%vstd!raw_ptr.Metadata. x))) :pattern ((Poly%vstd!raw_ptr.Metadata. x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%vstd!raw_ptr.Metadata.) (= x (Poly%vstd!raw_ptr.Metadata. (%Poly%vstd!raw_ptr.Metadata. x)))) :pattern ((has_type x TYPE%vstd!raw_ptr.Metadata.)) )))
(assert (has_type (Poly%vstd!raw_ptr.Metadata. vstd!raw_ptr.Metadata./Thin) TYPE%vstd!raw_ptr.Metadata.))
(assert (forall ((_0! Int)) (! (=> (uInv SZ _0!) (has_type (Poly%vstd!raw_ptr.Metadata. (vstd!raw_ptr.Metadata./Length _0!)) TYPE%vstd!raw_ptr.Metadata.)) :pattern ((has_type (Poly%vstd!raw_ptr.Metadata. (vstd!raw_ptr.Metadata./Length _0!)) TYPE%vstd!raw_ptr.Metadata.)) )))
(assert (forall ((x vstd!raw_ptr.Metadata.)) (! (= (vstd!raw_ptr.Metadata./Length/0 x) (vstd!raw_ptr.Metadata./Length/?0 x)) :pattern ((vstd!raw_ptr.Metadata./Length/0 x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%vstd!raw_ptr.Metadata.) (uInv SZ (vstd!raw_ptr.Metadata./Length/0 (%Poly%vstd!raw_ptr.Metadata. x)))) :pattern ((vstd!raw_ptr.Metadata./Length/0 (%Poly%vstd!raw_ptr.Metadata. x)) (has_type x TYPE%vstd!raw_ptr.Metadata.)) )))
(assert (forall ((_0! vstd!raw_ptr.DynMetadata.)) (! (has_type (Poly%vstd!raw_ptr.Metadata. (vstd!raw_ptr.Metadata./Dyn _0!)) TYPE%vstd!raw_ptr.Metadata.) :pattern ((has_type (Poly%vstd!raw_ptr.Metadata. (vstd!raw_ptr.Metadata./Dyn _0!)) TYPE%vstd!raw_ptr.Metadata.)) )))
(assert (forall ((x vstd!raw_ptr.Metadata.)) (! (= (vstd!raw_ptr.Metadata./Dyn/0 x) (vstd!raw_ptr.Metadata./Dyn/?0 x)) :pattern ((vstd!raw_ptr.Metadata./Dyn/0 x)) )))
(assert (forall ((x vstd!raw_ptr.PtrData.)) (! (= x (%Poly%vstd!raw_ptr.PtrData. (Poly%vstd!raw_ptr.PtrData. x))) :pattern ((Poly%vstd!raw_ptr.PtrData. x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%vstd!raw_ptr.PtrData.) (= x (Poly%vstd!raw_ptr.PtrData. (%Poly%vstd!raw_ptr.PtrData. x)))) :pattern ((has_type x TYPE%vstd!raw_ptr.PtrData.)) )))
(assert (forall ((_addr! Int) (_provenance! vstd!raw_ptr.Provenance.) (_metadata! vstd!raw_ptr.Metadata.)) (! (=> (and (uInv SZ _addr!) (has_type (Poly%vstd!raw_ptr.Metadata. _metadata!) TYPE%vstd!raw_ptr.Metadata.)) (has_type (Poly%vstd!raw_ptr.PtrData. (vstd!raw_ptr.PtrData./PtrData _addr! _provenance! _metadata!)) TYPE%vstd!raw_ptr.PtrData.)) :pattern ((has_type (Poly%vstd!raw_ptr.PtrData. (vstd!raw_ptr.PtrData./PtrData _addr! _provenance! _metadata!)) TYPE%vstd!raw_ptr.PtrData.)) )))
(assert (forall ((x vstd!raw_ptr.PtrData.)) (! (= (vstd!raw_ptr.PtrData./PtrData/addr x) (vstd!raw_ptr.PtrData./PtrData/?addr x)) :pattern ((vstd!raw_ptr.PtrData./PtrData/addr x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%vstd!raw_ptr.PtrData.) (uInv SZ (vstd!raw_ptr.PtrData./PtrData/addr (%Poly%vstd!raw_ptr.PtrData. x)))) :pattern ((vstd!raw_ptr.PtrData./PtrData/addr (%Poly%vstd!raw_ptr.PtrData. x)) (has_type x TYPE%vstd!raw_ptr.PtrData.)) )))
(assert (forall ((x vstd!raw_ptr.PtrData.)) (! (= (vstd!raw_ptr.PtrData./PtrData/provenance x) (vstd!raw_ptr.PtrData./PtrData/?provenance x)) :pattern ((vstd!raw_ptr.PtrData./PtrData/provenance x)) )))
(assert (forall ((x vstd!raw_ptr.PtrData.)) (! (= (vstd!raw_ptr.PtrData./PtrData/metadata x) (vstd!raw_ptr.PtrData./PtrData/?metadata x)) :pattern ((vstd!raw_ptr.PtrData./PtrData/metadata x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%vstd!raw_ptr.PtrData.) (has_type (Poly%vstd!raw_ptr.Metadata. (vstd!raw_ptr.PtrData./PtrData/metadata (%Poly%vstd!raw_ptr.PtrData. x))) TYPE%vstd!raw_ptr.Metadata.)) :pattern ((vstd!raw_ptr.PtrData./PtrData/metadata (%Poly%vstd!raw_ptr.PtrData. x)) (has_type x TYPE%vstd!raw_ptr.PtrData.)) )))
(assert (forall ((x lib!kv.durable.durablespec_t.DurableKvStoreList.)) (! (= x (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. x))) :pattern ((Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. x)) )))
(assert (forall ((L&. Dcr) (L& Type) (x Poly)) (! (=> (has_type x (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreList. L&. L&)) (= x (Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. x)))) :pattern ((has_type x (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreList. L&. L&))) )))
(assert (forall ((L&. Dcr) (L& Type) (_list! Poly) (_node_offset_map! vstd!map.Map<int./int.>.)) (! (=> (has_type _list! (TYPE%vstd!seq.Seq. L&. L&)) (has_type (Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (lib!kv.durable.durablespec_t.DurableKvStoreList./DurableKvStoreList _list! _node_offset_map!)) (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreList. L&. L&))) :pattern ((has_type (Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (lib!kv.durable.durablespec_t.DurableKvStoreList./DurableKvStoreList _list! _node_offset_map!)) (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreList. L&. L&))) )))
(assert (forall ((x lib!kv.durable.durablespec_t.DurableKvStoreList.)) (! (= (lib!kv.durable.durablespec_t.DurableKvStoreList./DurableKvStoreList/list x) (lib!kv.durable.durablespec_t.DurableKvStoreList./DurableKvStoreList/?list x)) :pattern ((lib!kv.durable.durablespec_t.DurableKvStoreList./DurableKvStoreList/list x)) )))
(assert (forall ((L&. Dcr) (L& Type) (x Poly)) (! (=> (has_type x (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreList. L&. L&)) (has_type (lib!kv.durable.durablespec_t.DurableKvStoreList./DurableKvStoreList/list (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. x)) (TYPE%vstd!seq.Seq. L&. L&))) :pattern ((lib!kv.durable.durablespec_t.DurableKvStoreList./DurableKvStoreList/list (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. x)) (has_type x (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreList. L&. L&))) )))
(assert (forall ((x lib!kv.durable.durablespec_t.DurableKvStoreList.)) (! (= (lib!kv.durable.durablespec_t.DurableKvStoreList./DurableKvStoreList/node_offset_map x) (lib!kv.durable.durablespec_t.DurableKvStoreList./DurableKvStoreList/?node_offset_map x)) :pattern ((lib!kv.durable.durablespec_t.DurableKvStoreList./DurableKvStoreList/node_offset_map x)) )))
(define-fun is-lib!kv.durable.durablespec_t.DurableKvStoreList./DurableKvStoreList_ ((c lib!kv.durable.durablespec_t.DurableKvStoreList.)) Bool ((_ is lib!kv.durable.durablespec_t.DurableKvStoreList./DurableKvStoreList) c))
(assert (forall ((x lib!kv.durable.durablespec_t.DurableKvStoreList.)) (! (=> (is-lib!kv.durable.durablespec_t.DurableKvStoreList./DurableKvStoreList_ x) (height_lt (height (lib!kv.durable.durablespec_t.DurableKvStoreList./DurableKvStoreList/list x)) (height (Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. x)))) :pattern ((height (lib!kv.durable.durablespec_t.DurableKvStoreList./DurableKvStoreList/list x))) )))
(assert (forall ((x lib!kv.durable.durablespec_t.DurableKvStoreViewEntry.)) (! (= x (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. x))) :pattern ((Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. x)) )))
(assert (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (x Poly)) (! (=> (has_type x (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. K&. K& I&. I& L&. L&)) (= x (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. x)))) :pattern ((has_type x (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. K&. K& I&. I& L&. L&))) )))
(assert (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (_key! Poly) (_item! Poly) (_list! lib!kv.durable.durablespec_t.DurableKvStoreList.)) (! (=> (and (has_type _key! K&) (has_type _item! I&) (has_type (Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. _list!) (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreList. L&. L&))) (has_type (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. (lib!kv.durable.durablespec_t.DurableKvStoreViewEntry./DurableKvStoreViewEntry _key! _item! _list!)) (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. K&. K& I&. I& L&. L&))) :pattern ((has_type (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. (lib!kv.durable.durablespec_t.DurableKvStoreViewEntry./DurableKvStoreViewEntry _key! _item! _list!)) (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. K&. K& I&. I& L&. L&))) )))
(assert (forall ((x lib!kv.durable.durablespec_t.DurableKvStoreViewEntry.)) (! (= (lib!kv.durable.durablespec_t.DurableKvStoreViewEntry./DurableKvStoreViewEntry/key x) (lib!kv.durable.durablespec_t.DurableKvStoreViewEntry./DurableKvStoreViewEntry/?key x)) :pattern ((lib!kv.durable.durablespec_t.DurableKvStoreViewEntry./DurableKvStoreViewEntry/key x)) )))
(assert (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (x Poly)) (! (=> (has_type x (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. K&. K& I&. I& L&. L&)) (has_type (lib!kv.durable.durablespec_t.DurableKvStoreViewEntry./DurableKvStoreViewEntry/key (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. x)) K&)) :pattern ((lib!kv.durable.durablespec_t.DurableKvStoreViewEntry./DurableKvStoreViewEntry/key (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. x)) (has_type x (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. K&. K& I&. I& L&. L&))) )))
(assert (forall ((x lib!kv.durable.durablespec_t.DurableKvStoreViewEntry.)) (! (= (lib!kv.durable.durablespec_t.DurableKvStoreViewEntry./DurableKvStoreViewEntry/item x) (lib!kv.durable.durablespec_t.DurableKvStoreViewEntry./DurableKvStoreViewEntry/?item x)) :pattern ((lib!kv.durable.durablespec_t.DurableKvStoreViewEntry./DurableKvStoreViewEntry/item x)) )))
(assert (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (x Poly)) (! (=> (has_type x (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. K&. K& I&. I& L&. L&)) (has_type (lib!kv.durable.durablespec_t.DurableKvStoreViewEntry./DurableKvStoreViewEntry/item (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. x)) I&)) :pattern ((lib!kv.durable.durablespec_t.DurableKvStoreViewEntry./DurableKvStoreViewEntry/item (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. x)) (has_type x (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. K&. K& I&. I& L&. L&))) )))
(assert (forall ((x lib!kv.durable.durablespec_t.DurableKvStoreViewEntry.)) (! (= (lib!kv.durable.durablespec_t.DurableKvStoreViewEntry./DurableKvStoreViewEntry/list x) (lib!kv.durable.durablespec_t.DurableKvStoreViewEntry./DurableKvStoreViewEntry/?list x)) :pattern ((lib!kv.durable.durablespec_t.DurableKvStoreViewEntry./DurableKvStoreViewEntry/list x)) )))
(assert (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (x Poly)) (! (=> (has_type x (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. K&. K& I&. I& L&. L&)) (has_type (Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (lib!kv.durable.durablespec_t.DurableKvStoreViewEntry./DurableKvStoreViewEntry/list (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. x))) (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreList. L&. L&))) :pattern ((lib!kv.durable.durablespec_t.DurableKvStoreViewEntry./DurableKvStoreViewEntry/list (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. x)) (has_type x (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. K&. K& I&. I& L&. L&))) )))
(define-fun is-lib!kv.durable.durablespec_t.DurableKvStoreViewEntry./DurableKvStoreViewEntry_ ((c lib!kv.durable.durablespec_t.DurableKvStoreViewEntry.)) Bool ((_ is lib!kv.durable.durablespec_t.DurableKvStoreViewEntry./DurableKvStoreViewEntry) c))
(assert (forall ((x lib!kv.durable.durablespec_t.DurableKvStoreViewEntry.)) (! (=> (is-lib!kv.durable.durablespec_t.DurableKvStoreViewEntry./DurableKvStoreViewEntry_ x) (height_lt (height (lib!kv.durable.durablespec_t.DurableKvStoreViewEntry./DurableKvStoreViewEntry/key x)) (height (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. x)))) :pattern ((height (lib!kv.durable.durablespec_t.DurableKvStoreViewEntry./DurableKvStoreViewEntry/key x))) )))
(assert (forall ((x lib!kv.durable.durablespec_t.DurableKvStoreViewEntry.)) (! (=> (is-lib!kv.durable.durablespec_t.DurableKvStoreViewEntry./DurableKvStoreViewEntry_ x) (height_lt (height (lib!kv.durable.durablespec_t.DurableKvStoreViewEntry./DurableKvStoreViewEntry/item x)) (height (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. x)))) :pattern ((height (lib!kv.durable.durablespec_t.DurableKvStoreViewEntry./DurableKvStoreViewEntry/item x))) )))
(assert (forall ((x lib!kv.durable.durablespec_t.DurableKvStoreViewEntry.)) (! (=> (is-lib!kv.durable.durablespec_t.DurableKvStoreViewEntry./DurableKvStoreViewEntry_ x) (height_lt (height (Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (lib!kv.durable.durablespec_t.DurableKvStoreViewEntry./DurableKvStoreViewEntry/list x))) (height (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. x)))) :pattern ((height (Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (lib!kv.durable.durablespec_t.DurableKvStoreViewEntry./DurableKvStoreViewEntry/list x)))) )))
(assert (forall ((x lib!kv.durable.durablespec_t.DurableKvStoreView.)) (! (= x (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. (Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. x))) :pattern ((Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. x)) )))
(assert (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (x Poly)) (! (=> (has_type x (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreView. K&. K& I&. I& L&. L& E&. E&)) (= x (Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. x)))) :pattern ((has_type x (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreView. K&. K& I&. I& L&. L& E&. E&))) )))
(assert (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (_contents! Poly) (_index_to_key_map! Poly) (__phantom! core!option.Option.)) (! (=> (and (has_type _contents! (TYPE%vstd!map.Map. $ INT $ (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. K&. K& I&. I& L&. L&))) (has_type _index_to_key_map! (TYPE%vstd!map.Map. $ INT K&. K&)) (has_type (Poly%core!option.Option. __phantom!) (TYPE%core!option.Option. E&. E&))) (has_type (Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView _contents! _index_to_key_map! __phantom!)) (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreView. K&. K& I&. I& L&. L& E&. E&))) :pattern ((has_type (Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView _contents! _index_to_key_map! __phantom!)) (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreView. K&. K& I&. I& L&. L& E&. E&))) )))
(assert (forall ((x lib!kv.durable.durablespec_t.DurableKvStoreView.)) (! (= (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/contents x) (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/?contents x)) :pattern ((lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/contents x)) )))
(assert (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (x Poly)) (! (=> (has_type x (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreView. K&. K& I&. I& L&. L& E&. E&)) (has_type (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/contents (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. x)) (TYPE%vstd!map.Map. $ INT $ (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. K&. K& I&. I& L&. L&)))) :pattern ((lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/contents (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. x)) (has_type x (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreView. K&. K& I&. I& L&. L& E&. E&))) )))
(assert (forall ((x lib!kv.durable.durablespec_t.DurableKvStoreView.)) (! (= (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/index_to_key_map x) (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/?index_to_key_map x)) :pattern ((lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/index_to_key_map x)) )))
(assert (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (x Poly)) (! (=> (has_type x (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreView. K&. K& I&. I& L&. L& E&. E&)) (has_type (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/index_to_key_map (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. x)) (TYPE%vstd!map.Map. $ INT K&. K&))) :pattern ((lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/index_to_key_map (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. x)) (has_type x (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreView. K&. K& I&. I& L&. L& E&. E&))) )))
(assert (forall ((x lib!kv.durable.durablespec_t.DurableKvStoreView.)) (! (= (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/_phantom x) (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/?_phantom x)) :pattern ((lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/_phantom x)) )))
(assert (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (x Poly)) (! (=> (has_type x (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreView. K&. K& I&. I& L&. L& E&. E&)) (has_type (Poly%core!option.Option. (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/_phantom (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. x))) (TYPE%core!option.Option. E&. E&))) :pattern ((lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/_phantom (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. x)) (has_type x (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreView. K&. K& I&. I& L&. L& E&. E&))) )))
(define-fun is-lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView_ ((c lib!kv.durable.durablespec_t.DurableKvStoreView.)) Bool ((_ is lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView) c))
(assert (forall ((x lib!kv.durable.durablespec_t.DurableKvStoreView.)) (! (=> (is-lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView_ x) (height_lt (height (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/contents x)) (height (Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. x)))) :pattern ((height (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/contents x))) )))
(assert (forall ((x lib!kv.durable.durablespec_t.DurableKvStoreView.)) (! (=> (is-lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView_ x) (height_lt (height (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/index_to_key_map x)) (height (Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. x)))) :pattern ((height (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/index_to_key_map x))) )))
(assert (forall ((x lib!kv.durable.durablespec_t.DurableKvStoreView.)) (! (=> (is-lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView_ x) (height_lt (height (Poly%core!option.Option. (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/_phantom x))) (height (Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. x)))) :pattern ((height (Poly%core!option.Option. (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/_phantom x)))) )))
(assert (forall ((x lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.)) (! (= x (%Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. (Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. x))) :pattern ((Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.) (= x (Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. (%Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. x)))) :pattern ((has_type x TYPE%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.)) )))
(assert (forall ((x lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.)) (! (= (lib!kv.volatile.volatilespec_t.ListNodeIndexEntry./ListNodeIndexEntry/start_index x) (lib!kv.volatile.volatilespec_t.ListNodeIndexEntry./ListNodeIndexEntry/?start_index x)) :pattern ((lib!kv.volatile.volatilespec_t.ListNodeIndexEntry./ListNodeIndexEntry/start_index x)) )))
(assert (forall ((x lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.)) (! (= (lib!kv.volatile.volatilespec_t.ListNodeIndexEntry./ListNodeIndexEntry/live_index x) (lib!kv.volatile.volatilespec_t.ListNodeIndexEntry./ListNodeIndexEntry/?live_index x)) :pattern ((lib!kv.volatile.volatilespec_t.ListNodeIndexEntry./ListNodeIndexEntry/live_index x)) )))
(assert (forall ((x lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.)) (! (= (lib!kv.volatile.volatilespec_t.ListNodeIndexEntry./ListNodeIndexEntry/physical_offset x) (lib!kv.volatile.volatilespec_t.ListNodeIndexEntry./ListNodeIndexEntry/?physical_offset x)) :pattern ((lib!kv.volatile.volatilespec_t.ListNodeIndexEntry./ListNodeIndexEntry/physical_offset x)) )))
(assert (forall ((x lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.)) (! (= (lib!kv.volatile.volatilespec_t.ListNodeIndexEntry./ListNodeIndexEntry/free_entries x) (lib!kv.volatile.volatilespec_t.ListNodeIndexEntry./ListNodeIndexEntry/?free_entries x)) :pattern ((lib!kv.volatile.volatilespec_t.ListNodeIndexEntry./ListNodeIndexEntry/free_entries x)) )))
(assert (forall ((x lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.)) (! (has_type (Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. x) TYPE%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.) :pattern ((has_type (Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. x) TYPE%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.)) )))
(assert (forall ((x lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry.)) (! (= x (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. x))) :pattern ((Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry.) (= x (Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. x)))) :pattern ((has_type x TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry.)) )))
(assert (forall ((x lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry.)) (! (= (lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry/item_offset x) (lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry/?item_offset x)) :pattern ((lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry/item_offset x)) )))
(assert (forall ((x lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry.)) (! (= (lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry/list_node_offsets x) (lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry/?list_node_offsets x)) :pattern ((lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry/list_node_offsets x)) )))
(assert (forall ((x lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry.)) (! (= (lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry/list_len x) (lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry/?list_len x)) :pattern ((lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry/list_len x)) )))
(assert (forall ((x lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry.)) (! (has_type (Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. x) TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry.) :pattern ((has_type (Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. x) TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry.)) )))
(assert (forall ((x lib!kv.volatile.volatilespec_t.VolatileKvIndexView.)) (! (= x (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. (Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. x))) :pattern ((Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. x)) )))
(assert (forall ((K&. Dcr) (K& Type) (x Poly)) (! (=> (has_type x (TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. K&. K&)) (= x (Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. x)))) :pattern ((has_type x (TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. K&. K&))) )))
(assert (forall ((K&. Dcr) (K& Type) (_contents! Poly) (_list_entries_per_node! Int)) (! (=> (has_type _contents! (TYPE%vstd!map.Map. K&. K& $ TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry.)) (has_type (Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. (lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView _contents! _list_entries_per_node!)) (TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. K&. K&))) :pattern ((has_type (Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. (lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView _contents! _list_entries_per_node!)) (TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. K&. K&))) )))
(assert (forall ((x lib!kv.volatile.volatilespec_t.VolatileKvIndexView.)) (! (= (lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView/contents x) (lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView/?contents x)) :pattern ((lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView/contents x)) )))
(assert (forall ((K&. Dcr) (K& Type) (x Poly)) (! (=> (has_type x (TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. K&. K&)) (has_type (lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView/contents (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. x)) (TYPE%vstd!map.Map. K&. K& $ TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry.))) :pattern ((lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView/contents (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. x)) (has_type x (TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. K&. K&))) )))
(assert (forall ((x lib!kv.volatile.volatilespec_t.VolatileKvIndexView.)) (! (= (lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView/list_entries_per_node x) (lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView/?list_entries_per_node x)) :pattern ((lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView/list_entries_per_node x)) )))
(define-fun is-lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView_ ((c lib!kv.volatile.volatilespec_t.VolatileKvIndexView.)) Bool ((_ is lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView) c))
(assert (forall ((x lib!kv.volatile.volatilespec_t.VolatileKvIndexView.)) (! (=> (is-lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView_ x) (height_lt (height (lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView/contents x)) (height (Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. x)))) :pattern ((height (lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView/contents x))) )))
(assert (forall ((x lib!kv.volatile.volatilespec_t.VolatileKvIndexView.)) (! (=> (is-lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView_ x) (height_lt (height (fun_from_recursive_field (lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView/contents x))) (height (Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. x)))) :pattern ((height (fun_from_recursive_field (lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView/contents x)))) )))
(assert (forall ((x lib!kv.kvimpl_t.KvError.)) (! (= x (%Poly%lib!kv.kvimpl_t.KvError. (Poly%lib!kv.kvimpl_t.KvError. x))) :pattern ((Poly%lib!kv.kvimpl_t.KvError. x)) )))
(assert (forall ((K&. Dcr) (K& Type) (E&. Dcr) (E& Type) (x Poly)) (! (=> (has_type x (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&)) (= x (Poly%lib!kv.kvimpl_t.KvError. (%Poly%lib!kv.kvimpl_t.KvError. x)))) :pattern ((has_type x (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) )))
(assert (forall ((K&. Dcr) (K& Type) (E&. Dcr) (E& Type)) (! (has_type (Poly%lib!kv.kvimpl_t.KvError. lib!kv.kvimpl_t.KvError./NotImplemented) (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&)) :pattern ((has_type (Poly%lib!kv.kvimpl_t.KvError. lib!kv.kvimpl_t.KvError./NotImplemented) (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) )))
(assert (forall ((K&. Dcr) (K& Type) (E&. Dcr) (E& Type)) (! (has_type (Poly%lib!kv.kvimpl_t.KvError. lib!kv.kvimpl_t.KvError./InvalidParameter) (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&)) :pattern ((has_type (Poly%lib!kv.kvimpl_t.KvError. lib!kv.kvimpl_t.KvError./InvalidParameter) (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) )))
(assert (forall ((K&. Dcr) (K& Type) (E&. Dcr) (E& Type)) (! (has_type (Poly%lib!kv.kvimpl_t.KvError. lib!kv.kvimpl_t.KvError./InternalError) (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&)) :pattern ((has_type (Poly%lib!kv.kvimpl_t.KvError. lib!kv.kvimpl_t.KvError./InternalError) (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) )))
(assert (forall ((K&. Dcr) (K& Type) (E&. Dcr) (E& Type)) (! (has_type (Poly%lib!kv.kvimpl_t.KvError. lib!kv.kvimpl_t.KvError./KeyNotFound) (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&)) :pattern ((has_type (Poly%lib!kv.kvimpl_t.KvError. lib!kv.kvimpl_t.KvError./KeyNotFound) (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) )))
(assert (forall ((K&. Dcr) (K& Type) (E&. Dcr) (E& Type)) (! (has_type (Poly%lib!kv.kvimpl_t.KvError. lib!kv.kvimpl_t.KvError./KeyAlreadyExists) (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&)) :pattern ((has_type (Poly%lib!kv.kvimpl_t.KvError. lib!kv.kvimpl_t.KvError./KeyAlreadyExists) (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) )))
(assert (forall ((K&. Dcr) (K& Type) (E&. Dcr) (E& Type) (_key! Poly)) (! (=> (has_type _key! K&) (has_type (Poly%lib!kv.kvimpl_t.KvError. (lib!kv.kvimpl_t.KvError./InvalidKey _key!)) (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) :pattern ((has_type (Poly%lib!kv.kvimpl_t.KvError. (lib!kv.kvimpl_t.KvError./InvalidKey _key!)) (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) )))
(assert (forall ((x lib!kv.kvimpl_t.KvError.)) (! (= (lib!kv.kvimpl_t.KvError./InvalidKey/key x) (lib!kv.kvimpl_t.KvError./InvalidKey/?key x)) :pattern ((lib!kv.kvimpl_t.KvError./InvalidKey/key x)) )))
(assert (forall ((K&. Dcr) (K& Type) (E&. Dcr) (E& Type) (x Poly)) (! (=> (has_type x (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&)) (has_type (lib!kv.kvimpl_t.KvError./InvalidKey/key (%Poly%lib!kv.kvimpl_t.KvError. x)) K&)) :pattern ((lib!kv.kvimpl_t.KvError./InvalidKey/key (%Poly%lib!kv.kvimpl_t.KvError. x)) (has_type x (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) )))
(assert (forall ((K&. Dcr) (K& Type) (E&. Dcr) (E& Type)) (! (has_type (Poly%lib!kv.kvimpl_t.KvError. lib!kv.kvimpl_t.KvError./IndexOutOfRange) (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&)) :pattern ((has_type (Poly%lib!kv.kvimpl_t.KvError. lib!kv.kvimpl_t.KvError./IndexOutOfRange) (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) )))
(assert (forall ((K&. Dcr) (K& Type) (E&. Dcr) (E& Type) (_required! Int) (_actual! Int)) (! (=> (and (uInv SZ _required!) (uInv SZ _actual!)) (has_type (Poly%lib!kv.kvimpl_t.KvError. (lib!kv.kvimpl_t.KvError./RegionTooSmall _required! _actual!)) (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) :pattern ((has_type (Poly%lib!kv.kvimpl_t.KvError. (lib!kv.kvimpl_t.KvError./RegionTooSmall _required! _actual!)) (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) )))
(assert (forall ((x lib!kv.kvimpl_t.KvError.)) (! (= (lib!kv.kvimpl_t.KvError./RegionTooSmall/required x) (lib!kv.kvimpl_t.KvError./RegionTooSmall/?required x)) :pattern ((lib!kv.kvimpl_t.KvError./RegionTooSmall/required x)) )))
(assert (forall ((K&. Dcr) (K& Type) (E&. Dcr) (E& Type) (x Poly)) (! (=> (has_type x (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&)) (uInv SZ (lib!kv.kvimpl_t.KvError./RegionTooSmall/required (%Poly%lib!kv.kvimpl_t.KvError. x)))) :pattern ((lib!kv.kvimpl_t.KvError./RegionTooSmall/required (%Poly%lib!kv.kvimpl_t.KvError. x)) (has_type x (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) )))
(assert (forall ((x lib!kv.kvimpl_t.KvError.)) (! (= (lib!kv.kvimpl_t.KvError./RegionTooSmall/actual x) (lib!kv.kvimpl_t.KvError./RegionTooSmall/?actual x)) :pattern ((lib!kv.kvimpl_t.KvError./RegionTooSmall/actual x)) )))
(assert (forall ((K&. Dcr) (K& Type) (E&. Dcr) (E& Type) (x Poly)) (! (=> (has_type x (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&)) (uInv SZ (lib!kv.kvimpl_t.KvError./RegionTooSmall/actual (%Poly%lib!kv.kvimpl_t.KvError. x)))) :pattern ((lib!kv.kvimpl_t.KvError./RegionTooSmall/actual (%Poly%lib!kv.kvimpl_t.KvError. x)) (has_type x (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) )))
(assert (forall ((K&. Dcr) (K& Type) (E&. Dcr) (E& Type)) (! (has_type (Poly%lib!kv.kvimpl_t.KvError. lib!kv.kvimpl_t.KvError./OutOfSpace) (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&)) :pattern ((has_type (Poly%lib!kv.kvimpl_t.KvError. lib!kv.kvimpl_t.KvError./OutOfSpace) (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) )))
(assert (forall ((K&. Dcr) (K& Type) (E&. Dcr) (E& Type)) (! (has_type (Poly%lib!kv.kvimpl_t.KvError. lib!kv.kvimpl_t.KvError./InvalidPersistentMemoryRegionProvided) (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&)) :pattern ((has_type (Poly%lib!kv.kvimpl_t.KvError. lib!kv.kvimpl_t.KvError./InvalidPersistentMemoryRegionProvided) (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) )))
(assert (forall ((K&. Dcr) (K& Type) (E&. Dcr) (E& Type) (_error! Poly)) (! (=> (has_type _error! E&) (has_type (Poly%lib!kv.kvimpl_t.KvError. (lib!kv.kvimpl_t.KvError./SerializationError _error!)) (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) :pattern ((has_type (Poly%lib!kv.kvimpl_t.KvError. (lib!kv.kvimpl_t.KvError./SerializationError _error!)) (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) )))
(assert (forall ((x lib!kv.kvimpl_t.KvError.)) (! (= (lib!kv.kvimpl_t.KvError./SerializationError/error x) (lib!kv.kvimpl_t.KvError./SerializationError/?error x)) :pattern ((lib!kv.kvimpl_t.KvError./SerializationError/error x)) )))
(assert (forall ((K&. Dcr) (K& Type) (E&. Dcr) (E& Type) (x Poly)) (! (=> (has_type x (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&)) (has_type (lib!kv.kvimpl_t.KvError./SerializationError/error (%Poly%lib!kv.kvimpl_t.KvError. x)) E&)) :pattern ((lib!kv.kvimpl_t.KvError./SerializationError/error (%Poly%lib!kv.kvimpl_t.KvError. x)) (has_type x (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) )))
(assert (forall ((K&. Dcr) (K& Type) (E&. Dcr) (E& Type) (_error! Poly)) (! (=> (has_type _error! E&) (has_type (Poly%lib!kv.kvimpl_t.KvError. (lib!kv.kvimpl_t.KvError./DeserializationError _error!)) (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) :pattern ((has_type (Poly%lib!kv.kvimpl_t.KvError. (lib!kv.kvimpl_t.KvError./DeserializationError _error!)) (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) )))
(assert (forall ((x lib!kv.kvimpl_t.KvError.)) (! (= (lib!kv.kvimpl_t.KvError./DeserializationError/error x) (lib!kv.kvimpl_t.KvError./DeserializationError/?error x)) :pattern ((lib!kv.kvimpl_t.KvError./DeserializationError/error x)) )))
(assert (forall ((K&. Dcr) (K& Type) (E&. Dcr) (E& Type) (x Poly)) (! (=> (has_type x (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&)) (has_type (lib!kv.kvimpl_t.KvError./DeserializationError/error (%Poly%lib!kv.kvimpl_t.KvError. x)) E&)) :pattern ((lib!kv.kvimpl_t.KvError./DeserializationError/error (%Poly%lib!kv.kvimpl_t.KvError. x)) (has_type x (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) )))
(define-fun is-lib!kv.kvimpl_t.KvError./InvalidKey_ ((c lib!kv.kvimpl_t.KvError.)) Bool ((_ is lib!kv.kvimpl_t.KvError./InvalidKey) c))
(assert (forall ((x lib!kv.kvimpl_t.KvError.)) (! (=> (is-lib!kv.kvimpl_t.KvError./InvalidKey_ x) (height_lt (height (lib!kv.kvimpl_t.KvError./InvalidKey/key x)) (height (Poly%lib!kv.kvimpl_t.KvError. x)))) :pattern ((height (lib!kv.kvimpl_t.KvError./InvalidKey/key x))) )))
(define-fun is-lib!kv.kvimpl_t.KvError./SerializationError_ ((c lib!kv.kvimpl_t.KvError.)) Bool ((_ is lib!kv.kvimpl_t.KvError./SerializationError) c))
(assert (forall ((x lib!kv.kvimpl_t.KvError.)) (! (=> (is-lib!kv.kvimpl_t.KvError./SerializationError_ x) (height_lt (height (lib!kv.kvimpl_t.KvError./SerializationError/error x)) (height (Poly%lib!kv.kvimpl_t.KvError. x)))) :pattern ((height (lib!kv.kvimpl_t.KvError./SerializationError/error x))) )))
(define-fun is-lib!kv.kvimpl_t.KvError./DeserializationError_ ((c lib!kv.kvimpl_t.KvError.)) Bool ((_ is lib!kv.kvimpl_t.KvError./DeserializationError) c))
(assert (forall ((x lib!kv.kvimpl_t.KvError.)) (! (=> (is-lib!kv.kvimpl_t.KvError./DeserializationError_ x) (height_lt (height (lib!kv.kvimpl_t.KvError./DeserializationError/error x)) (height (Poly%lib!kv.kvimpl_t.KvError. x)))) :pattern ((height (lib!kv.kvimpl_t.KvError./DeserializationError/error x))) )))
(assert (forall ((x lib!kv.kvimpl_v.UntrustedKvStoreImpl.)) (! (= x (%Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. (Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. x))) :pattern ((Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. x)) )))
(assert (forall ((PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (D&. Dcr) (D& Type) (V&. Dcr) (V& Type) (E&. Dcr) (E& Type) (x Poly)) (! (=> (has_type x (TYPE%lib!kv.kvimpl_v.UntrustedKvStoreImpl. PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E&)) (= x (Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. (%Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. x)))) :pattern ((has_type x (TYPE%lib!kv.kvimpl_v.UntrustedKvStoreImpl. PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E&))) )))
(assert (forall ((PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (D&. Dcr) (D& Type) (V&. Dcr) (V& Type) (E&. Dcr) (E& Type) (_id! Int) (_durable_store! Poly) (_volatile_index! Poly) (_entries_per_list_node! Int) (__phantom! core!marker.PhantomData.)) (! (=> (and (uInv 128 _id!) (has_type _durable_store! D&) (has_type _volatile_index! V&) (uInv SZ _entries_per_list_node!)) (has_type (Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. (lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl _id! _durable_store! _volatile_index! _entries_per_list_node! __phantom!)) (TYPE%lib!kv.kvimpl_v.UntrustedKvStoreImpl. PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E&))) :pattern ((has_type (Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. (lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl _id! _durable_store! _volatile_index! _entries_per_list_node! __phantom!)) (TYPE%lib!kv.kvimpl_v.UntrustedKvStoreImpl. PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E&))) )))
(assert (forall ((x lib!kv.kvimpl_v.UntrustedKvStoreImpl.)) (! (= (lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/id x) (lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/?id x)) :pattern ((lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/id x)) )))
(assert (forall ((PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (D&. Dcr) (D& Type) (V&. Dcr) (V& Type) (E&. Dcr) (E& Type) (x Poly)) (! (=> (has_type x (TYPE%lib!kv.kvimpl_v.UntrustedKvStoreImpl. PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E&)) (uInv 128 (lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/id (%Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. x)))) :pattern ((lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/id (%Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. x)) (has_type x (TYPE%lib!kv.kvimpl_v.UntrustedKvStoreImpl. PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E&))) )))
(assert (forall ((x lib!kv.kvimpl_v.UntrustedKvStoreImpl.)) (! (= (lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/durable_store x) (lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/?durable_store x)) :pattern ((lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/durable_store x)) )))
(assert (forall ((PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (D&. Dcr) (D& Type) (V&. Dcr) (V& Type) (E&. Dcr) (E& Type) (x Poly)) (! (=> (has_type x (TYPE%lib!kv.kvimpl_v.UntrustedKvStoreImpl. PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E&)) (has_type (lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/durable_store (%Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. x)) D&)) :pattern ((lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/durable_store (%Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. x)) (has_type x (TYPE%lib!kv.kvimpl_v.UntrustedKvStoreImpl. PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E&))) )))
(assert (forall ((x lib!kv.kvimpl_v.UntrustedKvStoreImpl.)) (! (= (lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/volatile_index x) (lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/?volatile_index x)) :pattern ((lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/volatile_index x)) )))
(assert (forall ((PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (D&. Dcr) (D& Type) (V&. Dcr) (V& Type) (E&. Dcr) (E& Type) (x Poly)) (! (=> (has_type x (TYPE%lib!kv.kvimpl_v.UntrustedKvStoreImpl. PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E&)) (has_type (lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/volatile_index (%Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. x)) V&)) :pattern ((lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/volatile_index (%Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. x)) (has_type x (TYPE%lib!kv.kvimpl_v.UntrustedKvStoreImpl. PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E&))) )))
(assert (forall ((x lib!kv.kvimpl_v.UntrustedKvStoreImpl.)) (! (= (lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/entries_per_list_node x) (lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/?entries_per_list_node x)) :pattern ((lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/entries_per_list_node x)) )))
(assert (forall ((PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (D&. Dcr) (D& Type) (V&. Dcr) (V& Type) (E&. Dcr) (E& Type) (x Poly)) (! (=> (has_type x (TYPE%lib!kv.kvimpl_v.UntrustedKvStoreImpl. PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E&)) (uInv SZ (lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/entries_per_list_node (%Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. x)))) :pattern ((lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/entries_per_list_node (%Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. x)) (has_type x (TYPE%lib!kv.kvimpl_v.UntrustedKvStoreImpl. PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E&))) )))
(assert (forall ((x lib!kv.kvimpl_v.UntrustedKvStoreImpl.)) (! (= (lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/_phantom x) (lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/?_phantom x)) :pattern ((lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/_phantom x)) )))
(define-fun is-lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl_ ((c lib!kv.kvimpl_v.UntrustedKvStoreImpl.)) Bool ((_ is lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl) c))
(assert (forall ((x lib!kv.kvimpl_v.UntrustedKvStoreImpl.)) (! (=> (is-lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl_ x) (height_lt (height (lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/durable_store x)) (height (Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. x)))) :pattern ((height (lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/durable_store x))) )))
(assert (forall ((x lib!kv.kvimpl_v.UntrustedKvStoreImpl.)) (! (=> (is-lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl_ x) (height_lt (height (lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/volatile_index x)) (height (Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. x)))) :pattern ((height (lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/volatile_index x))) )))
(assert (forall ((x lib!kv.kvimpl_v.UntrustedKvStoreImpl.)) (! (=> (is-lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl_ x) (height_lt (height (Poly%core!marker.PhantomData. (lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/_phantom x))) (height (Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. x)))) :pattern ((height (Poly%core!marker.PhantomData. (lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/_phantom x)))) )))
(assert (forall ((x lib!kv.kvspec_t.AbstractKvStoreState.)) (! (= x (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. (Poly%lib!kv.kvspec_t.AbstractKvStoreState. x))) :pattern ((Poly%lib!kv.kvspec_t.AbstractKvStoreState. x)) )))
(assert (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (x Poly)) (! (=> (has_type x (TYPE%lib!kv.kvspec_t.AbstractKvStoreState. K&. K& I&. I& L&. L& E&. E&)) (= x (Poly%lib!kv.kvspec_t.AbstractKvStoreState. (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. x)))) :pattern ((has_type x (TYPE%lib!kv.kvspec_t.AbstractKvStoreState. K&. K& I&. I& L&. L& E&. E&))) )))
(assert (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (_id! Int) (_contents! Poly) (__phantom! core!option.Option.)) (! (=> (and (uInv 128 _id!) (has_type _contents! (TYPE%vstd!map.Map. K&. K& $ (TYPE%tuple%2. I&. I& $ (TYPE%vstd!seq.Seq. L&. L&)))) (has_type (Poly%core!option.Option. __phantom!) (TYPE%core!option.Option. E&. E&))) (has_type (Poly%lib!kv.kvspec_t.AbstractKvStoreState. (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState _id! _contents! __phantom!)) (TYPE%lib!kv.kvspec_t.AbstractKvStoreState. K&. K& I&. I& L&. L& E&. E&))) :pattern ((has_type (Poly%lib!kv.kvspec_t.AbstractKvStoreState. (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState _id! _contents! __phantom!)) (TYPE%lib!kv.kvspec_t.AbstractKvStoreState. K&. K& I&. I& L&. L& E&. E&))) )))
(assert (forall ((x lib!kv.kvspec_t.AbstractKvStoreState.)) (! (= (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/id x) (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/?id x)) :pattern ((lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/id x)) )))
(assert (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (x Poly)) (! (=> (has_type x (TYPE%lib!kv.kvspec_t.AbstractKvStoreState. K&. K& I&. I& L&. L& E&. E&)) (uInv 128 (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/id (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. x)))) :pattern ((lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/id (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. x)) (has_type x (TYPE%lib!kv.kvspec_t.AbstractKvStoreState. K&. K& I&. I& L&. L& E&. E&))) )))
(assert (forall ((x lib!kv.kvspec_t.AbstractKvStoreState.)) (! (= (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/contents x) (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/?contents x)) :pattern ((lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/contents x)) )))
(assert (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (x Poly)) (! (=> (has_type x (TYPE%lib!kv.kvspec_t.AbstractKvStoreState. K&. K& I&. I& L&. L& E&. E&)) (has_type (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/contents (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. x)) (TYPE%vstd!map.Map. K&. K& $ (TYPE%tuple%2. I&. I& $ (TYPE%vstd!seq.Seq. L&. L&))))) :pattern ((lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/contents (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. x)) (has_type x (TYPE%lib!kv.kvspec_t.AbstractKvStoreState. K&. K& I&. I& L&. L& E&. E&))) )))
(assert (forall ((x lib!kv.kvspec_t.AbstractKvStoreState.)) (! (= (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/_phantom x) (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/?_phantom x)) :pattern ((lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/_phantom x)) )))
(assert (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (x Poly)) (! (=> (has_type x (TYPE%lib!kv.kvspec_t.AbstractKvStoreState. K&. K& I&. I& L&. L& E&. E&)) (has_type (Poly%core!option.Option. (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/_phantom (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. x))) (TYPE%core!option.Option. E&. E&))) :pattern ((lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/_phantom (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. x)) (has_type x (TYPE%lib!kv.kvspec_t.AbstractKvStoreState. K&. K& I&. I& L&. L& E&. E&))) )))
(define-fun is-lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState_ ((c lib!kv.kvspec_t.AbstractKvStoreState.)) Bool ((_ is lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState) c))
(assert (forall ((x lib!kv.kvspec_t.AbstractKvStoreState.)) (! (=> (is-lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState_ x) (height_lt (height (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/contents x)) (height (Poly%lib!kv.kvspec_t.AbstractKvStoreState. x)))) :pattern ((height (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/contents x))) )))
(assert (forall ((x lib!kv.kvspec_t.AbstractKvStoreState.)) (! (=> (is-lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState_ x) (height_lt (height (Poly%core!option.Option. (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/_phantom x))) (height (Poly%lib!kv.kvspec_t.AbstractKvStoreState. x)))) :pattern ((height (Poly%core!option.Option. (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/_phantom x)))) )))
(assert (forall ((x tuple%0.)) (! (= x (%Poly%tuple%0. (Poly%tuple%0. x))) :pattern ((Poly%tuple%0. x)) )))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%tuple%0.) (= x (Poly%tuple%0. (%Poly%tuple%0. x)))) :pattern ((has_type x TYPE%tuple%0.)) )))
(assert (forall ((x tuple%0.)) (! (has_type (Poly%tuple%0. x) TYPE%tuple%0.) :pattern ((has_type (Poly%tuple%0. x) TYPE%tuple%0.)) )))
(assert (forall ((x tuple%2.)) (! (= x (%Poly%tuple%2. (Poly%tuple%2. x))) :pattern ((Poly%tuple%2. x)) )))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (x Poly)) (! (=> (has_type x (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&)) (= x (Poly%tuple%2. (%Poly%tuple%2. x)))) :pattern ((has_type x (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&))) )))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (_0! Poly) (_1! Poly)) (! (=> (and (has_type _0! T%0&) (has_type _1! T%1&)) (has_type (Poly%tuple%2. (tuple%2./tuple%2 _0! _1!)) (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&))) :pattern ((has_type (Poly%tuple%2. (tuple%2./tuple%2 _0! _1!)) (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&))) )))
(assert (forall ((x tuple%2.)) (! (= (tuple%2./tuple%2/0 x) (tuple%2./tuple%2/?0 x)) :pattern ((tuple%2./tuple%2/0 x)) )))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (x Poly)) (! (=> (has_type x (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&)) (has_type (tuple%2./tuple%2/0 (%Poly%tuple%2. x)) T%0&)) :pattern ((tuple%2./tuple%2/0 (%Poly%tuple%2. x)) (has_type x (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&))) )))
(assert (forall ((x tuple%2.)) (! (= (tuple%2./tuple%2/1 x) (tuple%2./tuple%2/?1 x)) :pattern ((tuple%2./tuple%2/1 x)) )))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (x Poly)) (! (=> (has_type x (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&)) (has_type (tuple%2./tuple%2/1 (%Poly%tuple%2. x)) T%1&)) :pattern ((tuple%2./tuple%2/1 (%Poly%tuple%2. x)) (has_type x (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&))) )))
(define-fun is-tuple%2./tuple%2_ ((c tuple%2.)) Bool ((_ is tuple%2./tuple%2) c))
(assert (forall ((x tuple%2.)) (! (=> (is-tuple%2./tuple%2_ x) (height_lt (height (tuple%2./tuple%2/0 x)) (height (Poly%tuple%2. x)))) :pattern ((height (tuple%2./tuple%2/0 x))) )))
(assert (forall ((x tuple%2.)) (! (=> (is-tuple%2./tuple%2_ x) (height_lt (height (tuple%2./tuple%2/1 x)) (height (Poly%tuple%2. x)))) :pattern ((height (tuple%2./tuple%2/1 x))) )))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (deep Bool) (x Poly) (y Poly)) (! (=> (and (has_type x (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&)) (has_type y (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&)) (ext_eq deep T%0& (tuple%2./tuple%2/0 (%Poly%tuple%2. x)) (tuple%2./tuple%2/0 (%Poly%tuple%2. y))) (ext_eq deep T%1& (tuple%2./tuple%2/1 (%Poly%tuple%2. x)) (tuple%2./tuple%2/1 (%Poly%tuple%2. y)))) (ext_eq deep (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&) x y)) :pattern ((ext_eq deep (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&) x y)) )))
(assert (forall ((x tuple%3.)) (! (= x (%Poly%tuple%3. (Poly%tuple%3. x))) :pattern ((Poly%tuple%3. x)) )))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (T%2&. Dcr) (T%2& Type) (x Poly)) (! (=> (has_type x (TYPE%tuple%3. T%0&. T%0& T%1&. T%1& T%2&. T%2&)) (= x (Poly%tuple%3. (%Poly%tuple%3. x)))) :pattern ((has_type x (TYPE%tuple%3. T%0&. T%0& T%1&. T%1& T%2&. T%2&))) )))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (T%2&. Dcr) (T%2& Type) (_0! Poly) (_1! Poly) (_2! Poly)) (! (=> (and (has_type _0! T%0&) (has_type _1! T%1&) (has_type _2! T%2&)) (has_type (Poly%tuple%3. (tuple%3./tuple%3 _0! _1! _2!)) (TYPE%tuple%3. T%0&. T%0& T%1&. T%1& T%2&. T%2&))) :pattern ((has_type (Poly%tuple%3. (tuple%3./tuple%3 _0! _1! _2!)) (TYPE%tuple%3. T%0&. T%0& T%1&. T%1& T%2&. T%2&))) )))
(assert (forall ((x tuple%3.)) (! (= (tuple%3./tuple%3/0 x) (tuple%3./tuple%3/?0 x)) :pattern ((tuple%3./tuple%3/0 x)) )))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (T%2&. Dcr) (T%2& Type) (x Poly)) (! (=> (has_type x (TYPE%tuple%3. T%0&. T%0& T%1&. T%1& T%2&. T%2&)) (has_type (tuple%3./tuple%3/0 (%Poly%tuple%3. x)) T%0&)) :pattern ((tuple%3./tuple%3/0 (%Poly%tuple%3. x)) (has_type x (TYPE%tuple%3. T%0&. T%0& T%1&. T%1& T%2&. T%2&))) )))
(assert (forall ((x tuple%3.)) (! (= (tuple%3./tuple%3/1 x) (tuple%3./tuple%3/?1 x)) :pattern ((tuple%3./tuple%3/1 x)) )))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (T%2&. Dcr) (T%2& Type) (x Poly)) (! (=> (has_type x (TYPE%tuple%3. T%0&. T%0& T%1&. T%1& T%2&. T%2&)) (has_type (tuple%3./tuple%3/1 (%Poly%tuple%3. x)) T%1&)) :pattern ((tuple%3./tuple%3/1 (%Poly%tuple%3. x)) (has_type x (TYPE%tuple%3. T%0&. T%0& T%1&. T%1& T%2&. T%2&))) )))
(assert (forall ((x tuple%3.)) (! (= (tuple%3./tuple%3/2 x) (tuple%3./tuple%3/?2 x)) :pattern ((tuple%3./tuple%3/2 x)) )))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (T%2&. Dcr) (T%2& Type) (x Poly)) (! (=> (has_type x (TYPE%tuple%3. T%0&. T%0& T%1&. T%1& T%2&. T%2&)) (has_type (tuple%3./tuple%3/2 (%Poly%tuple%3. x)) T%2&)) :pattern ((tuple%3./tuple%3/2 (%Poly%tuple%3. x)) (has_type x (TYPE%tuple%3. T%0&. T%0& T%1&. T%1& T%2&. T%2&))) )))
(define-fun is-tuple%3./tuple%3_ ((c tuple%3.)) Bool ((_ is tuple%3./tuple%3) c))
(assert (forall ((x tuple%3.)) (! (=> (is-tuple%3./tuple%3_ x) (height_lt (height (tuple%3./tuple%3/0 x)) (height (Poly%tuple%3. x)))) :pattern ((height (tuple%3./tuple%3/0 x))) )))
(assert (forall ((x tuple%3.)) (! (=> (is-tuple%3./tuple%3_ x) (height_lt (height (tuple%3./tuple%3/1 x)) (height (Poly%tuple%3. x)))) :pattern ((height (tuple%3./tuple%3/1 x))) )))
(assert (forall ((x tuple%3.)) (! (=> (is-tuple%3./tuple%3_ x) (height_lt (height (tuple%3./tuple%3/2 x)) (height (Poly%tuple%3. x)))) :pattern ((height (tuple%3./tuple%3/2 x))) )))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (T%2&. Dcr) (T%2& Type) (deep Bool) (x Poly) (y Poly)) (! (=> (and (has_type x (TYPE%tuple%3. T%0&. T%0& T%1&. T%1& T%2&. T%2&)) (has_type y (TYPE%tuple%3. T%0&. T%0& T%1&. T%1& T%2&. T%2&)) (ext_eq deep T%0& (tuple%3./tuple%3/0 (%Poly%tuple%3. x)) (tuple%3./tuple%3/0 (%Poly%tuple%3. y))) (ext_eq deep T%1& (tuple%3./tuple%3/1 (%Poly%tuple%3. x)) (tuple%3./tuple%3/1 (%Poly%tuple%3. y))) (ext_eq deep T%2& (tuple%3./tuple%3/2 (%Poly%tuple%3. x)) (tuple%3./tuple%3/2 (%Poly%tuple%3. y)))) (ext_eq deep (TYPE%tuple%3. T%0&. T%0& T%1&. T%1& T%2&. T%2&) x y)) :pattern ((ext_eq deep (TYPE%tuple%3. T%0&. T%0& T%1&. T%1& T%2&. T%2&) x y)) )))
(assert (forall ((x tuple%5.)) (! (= x (%Poly%tuple%5. (Poly%tuple%5. x))) :pattern ((Poly%tuple%5. x)) )))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (T%2&. Dcr) (T%2& Type) (T%3&. Dcr) (T%3& Type) (T%4&. Dcr) (T%4& Type) (x Poly)) (! (=> (has_type x (TYPE%tuple%5. T%0&. T%0& T%1&. T%1& T%2&. T%2& T%3&. T%3& T%4&. T%4&)) (= x (Poly%tuple%5. (%Poly%tuple%5. x)))) :pattern ((has_type x (TYPE%tuple%5. T%0&. T%0& T%1&. T%1& T%2&. T%2& T%3&. T%3& T%4&. T%4&))) )))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (T%2&. Dcr) (T%2& Type) (T%3&. Dcr) (T%3& Type) (T%4&. Dcr) (T%4& Type) (_0! Poly) (_1! Poly) (_2! Poly) (_3! Poly) (_4! Poly)) (! (=> (and (has_type _0! T%0&) (has_type _1! T%1&) (has_type _2! T%2&) (has_type _3! T%3&) (has_type _4! T%4&)) (has_type (Poly%tuple%5. (tuple%5./tuple%5 _0! _1! _2! _3! _4!)) (TYPE%tuple%5. T%0&. T%0& T%1&. T%1& T%2&. T%2& T%3&. T%3& T%4&. T%4&))) :pattern ((has_type (Poly%tuple%5. (tuple%5./tuple%5 _0! _1! _2! _3! _4!)) (TYPE%tuple%5. T%0&. T%0& T%1&. T%1& T%2&. T%2& T%3&. T%3& T%4&. T%4&))) )))
(assert (forall ((x tuple%5.)) (! (= (tuple%5./tuple%5/0 x) (tuple%5./tuple%5/?0 x)) :pattern ((tuple%5./tuple%5/0 x)) )))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (T%2&. Dcr) (T%2& Type) (T%3&. Dcr) (T%3& Type) (T%4&. Dcr) (T%4& Type) (x Poly)) (! (=> (has_type x (TYPE%tuple%5. T%0&. T%0& T%1&. T%1& T%2&. T%2& T%3&. T%3& T%4&. T%4&)) (has_type (tuple%5./tuple%5/0 (%Poly%tuple%5. x)) T%0&)) :pattern ((tuple%5./tuple%5/0 (%Poly%tuple%5. x)) (has_type x (TYPE%tuple%5. T%0&. T%0& T%1&. T%1& T%2&. T%2& T%3&. T%3& T%4&. T%4&))) )))
(assert (forall ((x tuple%5.)) (! (= (tuple%5./tuple%5/1 x) (tuple%5./tuple%5/?1 x)) :pattern ((tuple%5./tuple%5/1 x)) )))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (T%2&. Dcr) (T%2& Type) (T%3&. Dcr) (T%3& Type) (T%4&. Dcr) (T%4& Type) (x Poly)) (! (=> (has_type x (TYPE%tuple%5. T%0&. T%0& T%1&. T%1& T%2&. T%2& T%3&. T%3& T%4&. T%4&)) (has_type (tuple%5./tuple%5/1 (%Poly%tuple%5. x)) T%1&)) :pattern ((tuple%5./tuple%5/1 (%Poly%tuple%5. x)) (has_type x (TYPE%tuple%5. T%0&. T%0& T%1&. T%1& T%2&. T%2& T%3&. T%3& T%4&. T%4&))) )))
(assert (forall ((x tuple%5.)) (! (= (tuple%5./tuple%5/2 x) (tuple%5./tuple%5/?2 x)) :pattern ((tuple%5./tuple%5/2 x)) )))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (T%2&. Dcr) (T%2& Type) (T%3&. Dcr) (T%3& Type) (T%4&. Dcr) (T%4& Type) (x Poly)) (! (=> (has_type x (TYPE%tuple%5. T%0&. T%0& T%1&. T%1& T%2&. T%2& T%3&. T%3& T%4&. T%4&)) (has_type (tuple%5./tuple%5/2 (%Poly%tuple%5. x)) T%2&)) :pattern ((tuple%5./tuple%5/2 (%Poly%tuple%5. x)) (has_type x (TYPE%tuple%5. T%0&. T%0& T%1&. T%1& T%2&. T%2& T%3&. T%3& T%4&. T%4&))) )))
(assert (forall ((x tuple%5.)) (! (= (tuple%5./tuple%5/3 x) (tuple%5./tuple%5/?3 x)) :pattern ((tuple%5./tuple%5/3 x)) )))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (T%2&. Dcr) (T%2& Type) (T%3&. Dcr) (T%3& Type) (T%4&. Dcr) (T%4& Type) (x Poly)) (! (=> (has_type x (TYPE%tuple%5. T%0&. T%0& T%1&. T%1& T%2&. T%2& T%3&. T%3& T%4&. T%4&)) (has_type (tuple%5./tuple%5/3 (%Poly%tuple%5. x)) T%3&)) :pattern ((tuple%5./tuple%5/3 (%Poly%tuple%5. x)) (has_type x (TYPE%tuple%5. T%0&. T%0& T%1&. T%1& T%2&. T%2& T%3&. T%3& T%4&. T%4&))) )))
(assert (forall ((x tuple%5.)) (! (= (tuple%5./tuple%5/4 x) (tuple%5./tuple%5/?4 x)) :pattern ((tuple%5./tuple%5/4 x)) )))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (T%2&. Dcr) (T%2& Type) (T%3&. Dcr) (T%3& Type) (T%4&. Dcr) (T%4& Type) (x Poly)) (! (=> (has_type x (TYPE%tuple%5. T%0&. T%0& T%1&. T%1& T%2&. T%2& T%3&. T%3& T%4&. T%4&)) (has_type (tuple%5./tuple%5/4 (%Poly%tuple%5. x)) T%4&)) :pattern ((tuple%5./tuple%5/4 (%Poly%tuple%5. x)) (has_type x (TYPE%tuple%5. T%0&. T%0& T%1&. T%1& T%2&. T%2& T%3&. T%3& T%4&. T%4&))) )))
(define-fun is-tuple%5./tuple%5_ ((c tuple%5.)) Bool ((_ is tuple%5./tuple%5) c))
(assert (forall ((x tuple%5.)) (! (=> (is-tuple%5./tuple%5_ x) (height_lt (height (tuple%5./tuple%5/0 x)) (height (Poly%tuple%5. x)))) :pattern ((height (tuple%5./tuple%5/0 x))) )))
(assert (forall ((x tuple%5.)) (! (=> (is-tuple%5./tuple%5_ x) (height_lt (height (tuple%5./tuple%5/1 x)) (height (Poly%tuple%5. x)))) :pattern ((height (tuple%5./tuple%5/1 x))) )))
(assert (forall ((x tuple%5.)) (! (=> (is-tuple%5./tuple%5_ x) (height_lt (height (tuple%5./tuple%5/2 x)) (height (Poly%tuple%5. x)))) :pattern ((height (tuple%5./tuple%5/2 x))) )))
(assert (forall ((x tuple%5.)) (! (=> (is-tuple%5./tuple%5_ x) (height_lt (height (tuple%5./tuple%5/3 x)) (height (Poly%tuple%5. x)))) :pattern ((height (tuple%5./tuple%5/3 x))) )))
(assert (forall ((x tuple%5.)) (! (=> (is-tuple%5./tuple%5_ x) (height_lt (height (tuple%5./tuple%5/4 x)) (height (Poly%tuple%5. x)))) :pattern ((height (tuple%5./tuple%5/4 x))) )))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (T%2&. Dcr) (T%2& Type) (T%3&. Dcr) (T%3& Type) (T%4&. Dcr) (T%4& Type) (deep Bool) (x Poly) (y Poly)) (! (=> (and (has_type x (TYPE%tuple%5. T%0&. T%0& T%1&. T%1& T%2&. T%2& T%3&. T%3& T%4&. T%4&)) (has_type y (TYPE%tuple%5. T%0&. T%0& T%1&. T%1& T%2&. T%2& T%3&. T%3& T%4&. T%4&)) (ext_eq deep T%0& (tuple%5./tuple%5/0 (%Poly%tuple%5. x)) (tuple%5./tuple%5/0 (%Poly%tuple%5. y))) (ext_eq deep T%1& (tuple%5./tuple%5/1 (%Poly%tuple%5. x)) (tuple%5./tuple%5/1 (%Poly%tuple%5. y))) (ext_eq deep T%2& (tuple%5./tuple%5/2 (%Poly%tuple%5. x)) (tuple%5./tuple%5/2 (%Poly%tuple%5. y))) (ext_eq deep T%3& (tuple%5./tuple%5/3 (%Poly%tuple%5. x)) (tuple%5./tuple%5/3 (%Poly%tuple%5. y))) (ext_eq deep T%4& (tuple%5./tuple%5/4 (%Poly%tuple%5. x)) (tuple%5./tuple%5/4 (%Poly%tuple%5. y)))) (ext_eq deep (TYPE%tuple%5. T%0&. T%0& T%1&. T%1& T%2&. T%2& T%3&. T%3& T%4&. T%4&) x y)) :pattern ((ext_eq deep (TYPE%tuple%5. T%0&. T%0& T%1&. T%1& T%2&. T%2& T%3&. T%3& T%4&. T%4&) x y)) )))
(set-info :comment ";; Traits")
(declare-fun tr_bound%vstd!view.View. (Dcr Type) Bool)
(declare-fun tr_bound%core!clone.Clone. (Dcr Type) Bool)
(declare-fun tr_bound%core!alloc.Allocator. (Dcr Type) Bool)
(declare-fun tr_bound%core!fmt.Debug. (Dcr Type) Bool)
(declare-fun tr_bound%core!convert.From. (Dcr Type Dcr Type) Bool)
(declare-fun tr_bound%core!cmp.PartialEq. (Dcr Type Dcr Type) Bool)
(declare-fun tr_bound%core!cmp.Eq. (Dcr Type) Bool)
(declare-fun tr_bound%core!hash.Hash. (Dcr Type) Bool)
(declare-fun tr_bound%vstd!std_specs.option.OptionAdditionalFns. (Dcr Type Dcr Type) Bool)
(declare-fun tr_bound%vstd!std_specs.result.ResultAdditionalSpecFns. (Dcr Type Dcr Type Dcr Type) Bool)
(declare-fun tr_bound%lib!kv.durable.durableimpl_v.DurableKvStore. (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type) Bool)
(declare-fun tr_bound%lib!kv.kvimpl_t.Item. (Dcr Type Dcr Type) Bool)
(declare-fun tr_bound%lib!kv.volatile.volatileimpl_v.VolatileKvIndex. (Dcr Type Dcr Type Dcr Type) Bool)
(declare-fun tr_bound%lib!pmem.pmemspec_t.PersistentMemoryRegions. (Dcr Type) Bool)
(declare-fun tr_bound%lib!pmem.pmcopy_t.PmCopy. (Dcr Type) Bool)
(declare-fun tr_bound%lib!pmem.pmcopy_t.SpecPmSized. (Dcr Type) Bool)
(declare-fun tr_bound%lib!pmem.traits_t.PmSafe. (Dcr Type) Bool)
(declare-fun tr_bound%lib!pmem.traits_t.PmSized. (Dcr Type) Bool)
(declare-fun tr_bound%lib!pmem.traits_t.UnsafeSpecPmSized. (Dcr Type) Bool)
(assert (forall ((Self%&. Dcr) (Self%& Type)) (! true :pattern ((tr_bound%vstd!view.View. Self%&. Self%&)) )))
(assert (forall ((Self%&. Dcr) (Self%& Type)) (! true :pattern ((tr_bound%core!clone.Clone. Self%&. Self%&)) )))
(assert (forall ((Self%&. Dcr) (Self%& Type)) (! true :pattern ((tr_bound%core!alloc.Allocator. Self%&. Self%&)) )))
(assert (forall ((Self%&. Dcr) (Self%& Type)) (! true :pattern ((tr_bound%core!fmt.Debug. Self%&. Self%&)) )))
(assert (forall ((Self%&. Dcr) (Self%& Type) (T&. Dcr) (T& Type)) (! true :pattern ((tr_bound%core!convert.From. Self%&. Self%& T&. T&)) )))
(assert (forall ((Self%&. Dcr) (Self%& Type) (Rhs&. Dcr) (Rhs& Type)) (! true :pattern ((tr_bound%core!cmp.PartialEq. Self%&. Self%& Rhs&. Rhs&)) )))
(assert (forall ((Self%&. Dcr) (Self%& Type)) (! (=> (tr_bound%core!cmp.Eq. Self%&. Self%&) (tr_bound%core!cmp.PartialEq. Self%&. Self%& Self%&. Self%&)) :pattern ((tr_bound%core!cmp.Eq. Self%&. Self%&)) )))
(assert (forall ((Self%&. Dcr) (Self%& Type)) (! true :pattern ((tr_bound%core!hash.Hash. Self%&. Self%&)) )))
(assert (forall ((Self%&. Dcr) (Self%& Type) (T&. Dcr) (T& Type)) (! true :pattern ((tr_bound%vstd!std_specs.option.OptionAdditionalFns. Self%&. Self%& T&. T&)) )))
(assert (forall ((Self%&. Dcr) (Self%& Type) (T&. Dcr) (T& Type) (E&. Dcr) (E& Type)) (! true :pattern ((tr_bound%vstd!std_specs.result.ResultAdditionalSpecFns. Self%&. Self%& T&. T& E&. E&)) )))
(assert (forall ((Self%&. Dcr) (Self%& Type) (PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type)) (! (=> (tr_bound%lib!kv.durable.durableimpl_v.DurableKvStore. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E&) (and (tr_bound%lib!pmem.pmemspec_t.PersistentMemoryRegions. PM&. PM&) (tr_bound%core!hash.Hash. K&. K&) (tr_bound%core!cmp.Eq. K&. K&) (tr_bound%core!clone.Clone. K&. K&) (tr_bound%lib!pmem.pmcopy_t.PmCopy. K&. K&) (tr_bound%core!fmt.Debug. K&. K&) (tr_bound%lib!pmem.pmcopy_t.PmCopy. I&. I&) (tr_bound%lib!kv.kvimpl_t.Item. I&. I& K&. K&) (tr_bound%core!fmt.Debug. I&. I&) (tr_bound%lib!pmem.pmcopy_t.PmCopy. L&. L&) (tr_bound%core!fmt.Debug. L&. L&) (tr_bound%core!fmt.Debug. E&. E&))) :pattern ((tr_bound%lib!kv.durable.durableimpl_v.DurableKvStore. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E&)) )))
(assert (forall ((Self%&. Dcr) (Self%& Type) (K&. Dcr) (K& Type)) (! true :pattern ((tr_bound%lib!kv.kvimpl_t.Item. Self%&. Self%& K&. K&)) )))
(assert (forall ((Self%&. Dcr) (Self%& Type) (K&. Dcr) (K& Type) (E&. Dcr) (E& Type)) (! (=> (tr_bound%lib!kv.volatile.volatileimpl_v.VolatileKvIndex. Self%&. Self%& K&. K& E&. E&) (and (tr_bound%core!hash.Hash. K&. K&) (tr_bound%core!cmp.Eq. K&. K&) (tr_bound%core!clone.Clone. K&. K&) (tr_bound%lib!pmem.pmcopy_t.PmCopy. K&. K&) (tr_bound%core!fmt.Debug. K&. K&) (tr_bound%core!fmt.Debug. E&. E&))) :pattern ((tr_bound%lib!kv.volatile.volatileimpl_v.VolatileKvIndex. Self%&. Self%& K&. K& E&. E&)) )))
(assert (forall ((Self%&. Dcr) (Self%& Type)) (! true :pattern ((tr_bound%lib!pmem.pmemspec_t.PersistentMemoryRegions. Self%&. Self%&)) )))
(assert (forall ((Self%&. Dcr) (Self%& Type)) (! (=> (tr_bound%lib!pmem.pmcopy_t.PmCopy. Self%&. Self%&) (and (tr_bound%lib!pmem.traits_t.PmSized. Self%&. Self%&) (tr_bound%lib!pmem.pmcopy_t.SpecPmSized. Self%&. Self%&) (tr_bound%lib!pmem.traits_t.PmSafe. Self%&. Self%&))) :pattern ((tr_bound%lib!pmem.pmcopy_t.PmCopy. Self%&. Self%&)) )))
(assert (forall ((Self%&. Dcr) (Self%& Type)) (! (=> (tr_bound%lib!pmem.pmcopy_t.SpecPmSized. Self%&. Self%&) (tr_bound%lib!pmem.traits_t.UnsafeSpecPmSized. Self%&. Self%&)) :pattern ((tr_bound%lib!pmem.pmcopy_t.SpecPmSized. Self%&. Self%&)) )))
(assert (forall ((Self%&. Dcr) (Self%& Type)) (! true :pattern ((tr_bound%lib!pmem.traits_t.PmSafe. Self%&. Self%&)) )))
(assert (forall ((Self%&. Dcr) (Self%& Type)) (! (=> (tr_bound%lib!pmem.traits_t.PmSized. Self%&. Self%&) (tr_bound%lib!pmem.pmcopy_t.SpecPmSized. Self%&. Self%&)) :pattern ((tr_bound%lib!pmem.traits_t.PmSized. Self%&. Self%&)) )))
(assert (forall ((Self%&. Dcr) (Self%& Type)) (! true :pattern ((tr_bound%lib!pmem.traits_t.UnsafeSpecPmSized. Self%&. Self%&)) )))
(set-info :comment ";; Associated-Type-Impls")
(assert (forall ((T&. Dcr) (T& Type)) (! (= (proj%%vstd!view.View./V $ (PTR T&. T&)) $) :pattern ((proj%%vstd!view.View./V $ (PTR T&. T&))) )))
(assert (forall ((T&. Dcr) (T& Type)) (! (= (proj%vstd!view.View./V $ (PTR T&. T&)) TYPE%vstd!raw_ptr.PtrData.) :pattern ((proj%vstd!view.View./V $ (PTR T&. T&))) )))
(assert (forall ((T&. Dcr) (T& Type)) (! (= (proj%%vstd!view.View./V (CONST_PTR $) (PTR T&. T&)) $) :pattern ((proj%%vstd!view.View./V (CONST_PTR $) (PTR T&. T&))) )))
(assert (forall ((T&. Dcr) (T& Type)) (! (= (proj%vstd!view.View./V (CONST_PTR $) (PTR T&. T&)) TYPE%vstd!raw_ptr.PtrData.) :pattern ((proj%vstd!view.View./V (CONST_PTR $) (PTR T&. T&))) )))
(assert (forall ((T&. Dcr) (T& Type)) (! (= (proj%%vstd!view.View./V $ (SLICE T&. T&)) $) :pattern ((proj%%vstd!view.View./V $ (SLICE T&. T&))) )))
(assert (forall ((T&. Dcr) (T& Type)) (! (= (proj%vstd!view.View./V $ (SLICE T&. T&)) (TYPE%vstd!seq.Seq. T&. T&)) :pattern ((proj%vstd!view.View./V $ (SLICE T&. T&))) )))
(assert (forall ((A&. Dcr) (A& Type)) (! (= (proj%%vstd!view.View./V (REF A&.) A&) (proj%%vstd!view.View./V A&. A&)) :pattern ((proj%%vstd!view.View./V (REF A&.) A&)) )))
(assert (forall ((A&. Dcr) (A& Type)) (! (= (proj%vstd!view.View./V (REF A&.) A&) (proj%vstd!view.View./V A&. A&)) :pattern ((proj%vstd!view.View./V (REF A&.) A&)) )))
(assert (forall ((A&. Dcr) (A& Type)) (! (= (proj%%vstd!view.View./V (BOX $ ALLOCATOR_GLOBAL A&.) A&) (proj%%vstd!view.View./V A&. A&)) :pattern ((proj%%vstd!view.View./V (BOX $ ALLOCATOR_GLOBAL A&.) A&)) )))
(assert (forall ((A&. Dcr) (A& Type)) (! (= (proj%vstd!view.View./V (BOX $ ALLOCATOR_GLOBAL A&.) A&) (proj%vstd!view.View./V A&. A&)) :pattern ((proj%vstd!view.View./V (BOX $ ALLOCATOR_GLOBAL A&.) A&)) )))
(assert (forall ((A&. Dcr) (A& Type)) (! (= (proj%%vstd!view.View./V (RC $ ALLOCATOR_GLOBAL A&.) A&) (proj%%vstd!view.View./V A&. A&)) :pattern ((proj%%vstd!view.View./V (RC $ ALLOCATOR_GLOBAL A&.) A&)) )))
(assert (forall ((A&. Dcr) (A& Type)) (! (= (proj%vstd!view.View./V (RC $ ALLOCATOR_GLOBAL A&.) A&) (proj%vstd!view.View./V A&. A&)) :pattern ((proj%vstd!view.View./V (RC $ ALLOCATOR_GLOBAL A&.) A&)) )))
(assert (forall ((A&. Dcr) (A& Type)) (! (= (proj%%vstd!view.View./V (ARC $ ALLOCATOR_GLOBAL A&.) A&) (proj%%vstd!view.View./V A&. A&)) :pattern ((proj%%vstd!view.View./V (ARC $ ALLOCATOR_GLOBAL A&.) A&)) )))
(assert (forall ((A&. Dcr) (A& Type)) (! (= (proj%vstd!view.View./V (ARC $ ALLOCATOR_GLOBAL A&.) A&) (proj%vstd!view.View./V A&. A&)) :pattern ((proj%vstd!view.View./V (ARC $ ALLOCATOR_GLOBAL A&.) A&)) )))
(assert (forall ((T&. Dcr) (T& Type) (A&. Dcr) (A& Type)) (! (= (proj%%vstd!view.View./V $ (TYPE%alloc!vec.Vec. T&. T& A&. A&)) $) :pattern ((proj%%vstd!view.View./V $ (TYPE%alloc!vec.Vec. T&. T& A&. A&))) )))
(assert (forall ((T&. Dcr) (T& Type) (A&. Dcr) (A& Type)) (! (= (proj%vstd!view.View./V $ (TYPE%alloc!vec.Vec. T&. T& A&. A&)) (TYPE%vstd!seq.Seq. T&. T&)) :pattern ((proj%vstd!view.View./V $ (TYPE%alloc!vec.Vec. T&. T& A&. A&))) )))
(assert (= (proj%%vstd!view.View./V $ TYPE%tuple%0.) $))
(assert (= (proj%vstd!view.View./V $ TYPE%tuple%0.) TYPE%tuple%0.))
(assert (= (proj%%vstd!view.View./V $ BOOL) $))
(assert (= (proj%vstd!view.View./V $ BOOL) BOOL))
(assert (= (proj%%vstd!view.View./V $ (UINT 8)) $))
(assert (= (proj%vstd!view.View./V $ (UINT 8)) (UINT 8)))
(assert (= (proj%%vstd!view.View./V $ (UINT 64)) $))
(assert (= (proj%vstd!view.View./V $ (UINT 64)) (UINT 64)))
(assert (= (proj%%vstd!view.View./V $ (UINT 128)) $))
(assert (= (proj%vstd!view.View./V $ (UINT 128)) (UINT 128)))
(assert (= (proj%%vstd!view.View./V $ (UINT SZ)) $))
(assert (= (proj%vstd!view.View./V $ (UINT SZ)) (UINT SZ)))
(assert (forall ((A0&. Dcr) (A0& Type) (A1&. Dcr) (A1& Type)) (! (= (proj%%vstd!view.View./V $ (TYPE%tuple%2. A0&. A0& A1&. A1&)) $) :pattern ((proj%%vstd!view.View./V $ (TYPE%tuple%2. A0&. A0& A1&. A1&))) )))
(assert (forall ((A0&. Dcr) (A0& Type) (A1&. Dcr) (A1& Type)) (! (= (proj%vstd!view.View./V $ (TYPE%tuple%2. A0&. A0& A1&. A1&)) (TYPE%tuple%2. (proj%%vstd!view.View./V A0&. A0&) (proj%vstd!view.View./V A0&. A0&) (proj%%vstd!view.View./V A1&. A1&) (proj%vstd!view.View./V A1&. A1&))) :pattern ((proj%vstd!view.View./V $ (TYPE%tuple%2. A0&. A0& A1&. A1&))) )))
(assert (forall ((A0&. Dcr) (A0& Type) (A1&. Dcr) (A1& Type) (A2&. Dcr) (A2& Type)) (! (= (proj%%vstd!view.View./V $ (TYPE%tuple%3. A0&. A0& A1&. A1& A2&. A2&)) $) :pattern ((proj%%vstd!view.View./V $ (TYPE%tuple%3. A0&. A0& A1&. A1& A2&. A2&))) )))
(assert (forall ((A0&. Dcr) (A0& Type) (A1&. Dcr) (A1& Type) (A2&. Dcr) (A2& Type)) (! (= (proj%vstd!view.View./V $ (TYPE%tuple%3. A0&. A0& A1&. A1& A2&. A2&)) (TYPE%tuple%3. (proj%%vstd!view.View./V A0&. A0&) (proj%vstd!view.View./V A0&. A0&) (proj%%vstd!view.View./V A1&. A1&) (proj%vstd!view.View./V A1&. A1&) (proj%%vstd!view.View./V A2&. A2&) (proj%vstd!view.View./V A2&. A2&))) :pattern ((proj%vstd!view.View./V $ (TYPE%tuple%3. A0&. A0& A1&. A1& A2&. A2&))) )))
(set-info :comment ";; Function-Decl vstd::view::View::view")
(declare-fun vstd!view.View.view.? (Dcr Type Poly) Poly)
(declare-fun vstd!view.View.view%default%.? (Dcr Type Poly) Poly)
(set-info :comment ";; Function-Decl vstd::seq::Seq::len")
(declare-fun vstd!seq.Seq.len.? (Dcr Type Poly) Int)
(set-info :comment ";; Function-Decl vstd::seq::Seq::index")
(declare-fun vstd!seq.Seq.index.? (Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::seq::impl&%0::spec_index")
(declare-fun vstd!seq.impl&%0.spec_index.? (Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::seq::Seq::subrange")
(declare-fun vstd!seq.Seq.subrange.? (Dcr Type Poly Poly Poly) Poly)
(set-info :comment ";; Function-Decl lib::kv::kvimpl_t::Item::spec_key")
(declare-fun lib!kv.kvimpl_t.Item.spec_key.? (Dcr Type Dcr Type Poly) Poly)
(declare-fun lib!kv.kvimpl_t.Item.spec_key%default%.? (Dcr Type Dcr Type Poly) Poly)
(set-info :comment ";; Function-Decl lib::kv::durable::durableimpl_v::DurableKvStore::view")
(declare-fun lib!kv.durable.durableimpl_v.DurableKvStore.view.? (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Poly) Poly)
(declare-fun lib!kv.durable.durableimpl_v.DurableKvStore.view%default%.? (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Poly) Poly)
(set-info :comment ";; Function-Decl lib::kv::durable::durableimpl_v::DurableKvStore::valid")
(declare-fun lib!kv.durable.durableimpl_v.DurableKvStore.valid.? (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Poly) Poly)
(declare-fun lib!kv.durable.durableimpl_v.DurableKvStore.valid%default%.? (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Poly) Poly)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::len")
(declare-fun vstd!set.impl&%0.len.? (Dcr Type Poly) Int)
(set-info :comment ";; Function-Decl vstd::set_lib::impl&%0::is_empty")
(declare-fun vstd!set_lib.impl&%0.is_empty.? (Dcr Type Poly) Bool)
(set-info :comment ";; Function-Decl vstd::map::impl&%0::dom")
(declare-fun vstd!map.impl&%0.dom.? (Dcr Type Dcr Type Poly) Poly)
(set-info :comment ";; Function-Decl vstd::map_lib::impl&%0::is_empty")
(declare-fun vstd!map_lib.impl&%0.is_empty.? (Dcr Type Dcr Type Poly) Bool)
(set-info :comment ";; Function-Decl lib::kv::durable::durablespec_t::DurableKvStoreView::empty")
(declare-fun lib!kv.durable.durablespec_t.impl&%2.empty.? (Dcr Type Dcr Type Dcr Type Dcr Type Poly) Bool)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::contains")
(declare-fun vstd!set.impl&%0.contains.? (Dcr Type Poly Poly) Bool)
(set-info :comment ";; Function-Decl vstd::map_lib::impl&%0::contains_key")
(declare-fun vstd!map_lib.impl&%0.contains_key.? (Dcr Type Dcr Type Poly Poly) Bool)
(set-info :comment ";; Function-Decl vstd::map::impl&%0::index")
(declare-fun vstd!map.impl&%0.index.? (Dcr Type Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::map::impl&%0::spec_index")
(declare-fun vstd!map.impl&%0.spec_index.? (Dcr Type Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl lib::kv::durable::durablespec_t::DurableKvStoreView::spec_index")
(declare-fun lib!kv.durable.durablespec_t.impl&%2.spec_index.? (Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly) core!option.Option.)
(set-info :comment ";; Function-Decl lib::kv::durable::durablespec_t::DurableKvStoreView::contains_key")
(declare-fun lib!kv.durable.durablespec_t.impl&%2.contains_key.? (Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly) Bool)
(set-info :comment ";; Function-Decl lib::kv::durable::durablespec_t::DurableKvStoreViewEntry::key")
(declare-fun lib!kv.durable.durablespec_t.impl&%1.key.? (Dcr Type Dcr Type Dcr Type Poly) Poly)
(set-info :comment ";; Function-Decl vstd::std_specs::option::OptionAdditionalFns::is_Some")
(declare-fun vstd!std_specs.option.OptionAdditionalFns.is_Some.? (Dcr Type Dcr Type Poly) Poly)
(declare-fun vstd!std_specs.option.OptionAdditionalFns.is_Some%default%.? (Dcr Type Dcr Type Poly) Poly)
(set-info :comment ";; Function-Decl vstd::std_specs::option::OptionAdditionalFns::get_Some_0")
(declare-fun vstd!std_specs.option.OptionAdditionalFns.get_Some_0.? (Dcr Type Dcr Type Poly) Poly)
(declare-fun vstd!std_specs.option.OptionAdditionalFns.get_Some_0%default%.? (Dcr Type Dcr Type Poly) Poly)
(set-info :comment ";; Function-Decl vstd::std_specs::option::OptionAdditionalFns::is_None")
(declare-fun vstd!std_specs.option.OptionAdditionalFns.is_None.? (Dcr Type Dcr Type Poly) Poly)
(declare-fun vstd!std_specs.option.OptionAdditionalFns.is_None%default%.? (Dcr Type Dcr Type Poly) Poly)
(set-info :comment ";; Function-Decl vstd::std_specs::option::spec_unwrap")
(declare-fun vstd!std_specs.option.spec_unwrap.? (Dcr Type Poly) Poly)
(set-info :comment ";; Function-Decl lib::kv::durable::durablespec_t::DurableKvStoreView::valid")
(declare-fun lib!kv.durable.durablespec_t.impl&%2.valid.? (Dcr Type Dcr Type Dcr Type Dcr Type Poly) Bool)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::finite")
(declare-fun vstd!set.impl&%0.finite.? (Dcr Type Poly) Bool)
(set-info :comment ";; Function-Decl vstd::map::impl&%0::insert")
(declare-fun vstd!map.impl&%0.insert.? (Dcr Type Dcr Type Poly Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::seq::Seq::empty")
(declare-fun vstd!seq.Seq.empty.? (Dcr Type) Poly)
(set-info :comment ";; Function-Decl vstd::map::impl&%0::empty")
(declare-fun vstd!map.impl&%0.empty.? (Dcr Type Dcr Type) Poly)
(set-info :comment ";; Function-Decl lib::kv::durable::durablespec_t::DurableKvStoreList::empty")
(declare-fun lib!kv.durable.durablespec_t.impl&%0.empty.? (Dcr Type) lib!kv.durable.durablespec_t.DurableKvStoreList.)
(set-info :comment ";; Function-Decl lib::kv::durable::durablespec_t::DurableKvStoreView::create")
(declare-fun lib!kv.durable.durablespec_t.impl&%2.create.? (Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly Poly) core!result.Result.)
(set-info :comment ";; Function-Decl vstd::map::impl&%0::len")
(declare-fun vstd!map.impl&%0.len.? (Dcr Type Dcr Type Poly) Int)
(set-info :comment ";; Function-Decl lib::kv::durable::durablespec_t::DurableKvStoreView::len")
(declare-fun lib!kv.durable.durablespec_t.impl&%2.len.? (Dcr Type Dcr Type Dcr Type Dcr Type Poly) Int)
(set-info :comment ";; Function-Decl lib::kv::durable::durablespec_t::DurableKvStoreViewEntry::item")
(declare-fun lib!kv.durable.durablespec_t.impl&%1.item.? (Dcr Type Dcr Type Dcr Type Poly) Poly)
(set-info :comment ";; Function-Decl lib::kv::durable::durablespec_t::DurableKvStoreList::spec_index")
(declare-fun lib!kv.durable.durablespec_t.impl&%0.spec_index.? (Dcr Type Poly Poly) core!option.Option.)
(set-info :comment ";; Function-Decl lib::kv::durable::durablespec_t::DurableKvStoreViewEntry::list")
(declare-fun lib!kv.durable.durablespec_t.impl&%1.list.? (Dcr Type Dcr Type Dcr Type Poly) lib!kv.durable.durablespec_t.DurableKvStoreList.)
(set-info :comment ";; Function-Decl vstd::seq::Seq::push")
(declare-fun vstd!seq.Seq.push.? (Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl lib::kv::durable::durablespec_t::DurableKvStoreList::len")
(declare-fun lib!kv.durable.durablespec_t.impl&%0.len.? (Dcr Type Poly) Int)
(set-info :comment ";; Function-Decl lib::kv::durable::durablespec_t::DurableKvStoreList::offset_index")
(declare-fun lib!kv.durable.durablespec_t.impl&%0.offset_index.? (Dcr Type Poly Poly) core!option.Option.)
(set-info :comment ";; Function-Decl lib::kv::volatile::volatileimpl_v::VolatileKvIndex::view")
(declare-fun lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? (Dcr Type Dcr Type Dcr Type Poly) Poly)
(declare-fun lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view%default%.? (Dcr Type Dcr Type Dcr Type Poly) Poly)
(set-info :comment ";; Function-Decl lib::kv::volatile::volatileimpl_v::VolatileKvIndex::valid")
(declare-fun lib!kv.volatile.volatileimpl_v.VolatileKvIndex.valid.? (Dcr Type Dcr Type Dcr Type Poly) Poly)
(declare-fun lib!kv.volatile.volatileimpl_v.VolatileKvIndex.valid%default%.? (Dcr Type Dcr Type Dcr Type Poly) Poly)
(set-info :comment ";; Function-Decl lib::kv::volatile::volatilespec_t::VolatileKvIndexView::empty")
(declare-fun lib!kv.volatile.volatilespec_t.impl&%1.empty.? (Dcr Type Poly) Bool)
(set-info :comment ";; Function-Decl lib::kv::volatile::volatilespec_t::VolatileKvIndexView::spec_index")
(declare-fun lib!kv.volatile.volatilespec_t.impl&%1.spec_index.? (Dcr Type Poly Poly) core!option.Option.)
(set-info :comment ";; Function-Decl lib::kv::volatile::volatilespec_t::VolatileKvIndexView::insert_item_offset")
(declare-fun lib!kv.volatile.volatilespec_t.impl&%1.insert_item_offset.? (Dcr Type Poly Poly Poly) lib!kv.volatile.volatilespec_t.VolatileKvIndexView.)
(set-info :comment ";; Function-Decl lib::kv::volatile::volatilespec_t::VolatileKvIndexView::len")
(declare-fun lib!kv.volatile.volatilespec_t.impl&%1.len.? (Dcr Type Poly) Int)
(set-info :comment ";; Function-Decl lib::kv::volatile::volatilespec_t::VolatileKvIndexView::contains_key")
(declare-fun lib!kv.volatile.volatilespec_t.impl&%1.contains_key.? (Dcr Type Poly Poly) Bool)
(set-info :comment ";; Function-Decl vstd::std_specs::result::ResultAdditionalSpecFns::is_Ok")
(declare-fun vstd!std_specs.result.ResultAdditionalSpecFns.is_Ok.? (Dcr Type Dcr Type Dcr Type Poly) Poly)
(declare-fun vstd!std_specs.result.ResultAdditionalSpecFns.is_Ok%default%.? (Dcr Type Dcr Type Dcr Type Poly) Poly)
(set-info :comment ";; Function-Decl vstd::std_specs::result::ResultAdditionalSpecFns::get_Ok_0")
(declare-fun vstd!std_specs.result.ResultAdditionalSpecFns.get_Ok_0.? (Dcr Type Dcr Type Dcr Type Poly) Poly)
(declare-fun vstd!std_specs.result.ResultAdditionalSpecFns.get_Ok_0%default%.? (Dcr Type Dcr Type Dcr Type Poly) Poly)
(set-info :comment ";; Function-Decl vstd::std_specs::result::spec_unwrap")
(declare-fun vstd!std_specs.result.spec_unwrap.? (Dcr Type Dcr Type Poly) Poly)
(set-info :comment ";; Function-Decl lib::kv::volatile::volatilespec_t::VolatileKvIndexView::get_node_view")
(declare-fun lib!kv.volatile.volatilespec_t.impl&%1.get_node_view.? (Dcr Type Dcr Type Poly Poly Poly) core!result.Result.)
(set-info :comment ";; Function-Decl lib::kv::volatile::volatilespec_t::VolatileKvIndexView::list_len")
(declare-fun lib!kv.volatile.volatilespec_t.impl&%1.list_len.? (Dcr Type Poly Poly) Int)
(set-info :comment ";; Function-Decl lib::kv::volatile::volatilespec_t::ListNodeIndexEntry::has_free_space")
(declare-fun lib!kv.volatile.volatilespec_t.impl&%0.has_free_space.? (Poly) Bool)
(set-info :comment ";; Function-Decl lib::kv::volatile::volatilespec_t::ListNodeIndexEntry::append_entry")
(declare-fun lib!kv.volatile.volatilespec_t.impl&%0.append_entry.? (Dcr Type Dcr Type Poly) core!result.Result.)
(set-info :comment ";; Function-Decl lib::kv::volatile::volatilespec_t::VolatileKvIndexView::append_to_list")
(declare-fun lib!kv.volatile.volatilespec_t.impl&%1.append_to_list.? (Dcr Type Dcr Type Poly Poly) core!result.Result.)
(set-info :comment ";; Function-Decl lib::kv::volatile::volatilespec_t::VolatileKvIndexView::get_node_offset")
(declare-fun lib!kv.volatile.volatilespec_t.impl&%1.get_node_offset.? (Dcr Type Dcr Type Poly Poly Poly) core!result.Result.)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::new")
(declare-fun vstd!set.impl&%0.new.? (Dcr Type Dcr Type Poly) Poly)
(set-info :comment ";; Function-Decl vstd::map::impl&%0::remove")
(declare-fun vstd!map.impl&%0.remove.? (Dcr Type Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::mk_map")
(declare-fun vstd!set.impl&%0.mk_map.? (Dcr Type Dcr Type Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::map::impl&%0::new")
(declare-fun vstd!map.impl&%0.new.? (Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::map_lib::impl&%0::remove_keys")
(declare-fun vstd!map_lib.impl&%0.remove_keys.? (Dcr Type Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl lib::kv::volatile::volatilespec_t::VolatileKvIndexView::trim_list")
(declare-fun lib!kv.volatile.volatilespec_t.impl&%1.trim_list.? (Dcr Type Dcr Type Poly Poly Poly) core!result.Result.)
(set-info :comment ";; Function-Decl lib::kv::volatile::volatilespec_t::VolatileKvIndexView::keys")
(declare-fun lib!kv.volatile.volatilespec_t.impl&%1.keys.? (Dcr Type Poly) Poly)
(set-info :comment ";; Function-Decl vstd::seq_lib::impl&%0::contains")
(declare-fun vstd!seq_lib.impl&%0.contains.? (Dcr Type Poly Poly) Bool)
(set-info :comment ";; Function-Decl vstd::seq_lib::impl&%0::to_set")
(declare-fun vstd!seq_lib.impl&%0.to_set.? (Dcr Type Poly) Poly)
(set-info :comment ";; Function-Decl vstd::std_specs::control_flow::spec_from")
(declare-fun vstd!std_specs.control_flow.spec_from.? (Dcr Type Dcr Type Poly Poly) Bool)
(set-info :comment ";; Function-Decl vstd::std_specs::option::is_some")
(declare-fun vstd!std_specs.option.is_some.? (Dcr Type Poly) Bool)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::empty")
(declare-fun vstd!set.impl&%0.empty.? (Dcr Type) Poly)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::insert")
(declare-fun vstd!set.impl&%0.insert.? (Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::remove")
(declare-fun vstd!set.impl&%0.remove.? (Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::seq::Seq::update")
(declare-fun vstd!seq.Seq.update.? (Dcr Type Poly Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::raw_ptr::view_reverse_for_eq")
(declare-fun vstd!raw_ptr.view_reverse_for_eq.? (Dcr Type Poly) Poly)
(set-info :comment ";; Function-Decl lib::kv::kvimpl_t::spec_phantom_data")
(declare-fun lib!kv.kvimpl_t.spec_phantom_data.? (Dcr Type) core!marker.PhantomData.)
(set-info :comment ";; Function-Decl lib::kv::durable::durablespec_t::DurableKvStoreView::matches_volatile_index")
(declare-fun lib!kv.durable.durablespec_t.impl&%2.matches_volatile_index.? (Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly) Bool)
(set-info :comment ";; Function-Decl lib::kv::kvspec_t::AbstractKvStoreState::construct_view_contents")
(declare-fun lib!kv.kvspec_t.impl&%2.construct_view_contents.? (Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl lib::kv::kvimpl_v::UntrustedKvStoreImpl::view")
(declare-fun lib!kv.kvimpl_v.impl&%0.view.? (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Poly) lib!kv.kvspec_t.AbstractKvStoreState.)
(set-info :comment ";; Function-Decl lib::kv::kvimpl_v::UntrustedKvStoreImpl::valid")
(declare-fun lib!kv.kvimpl_v.impl&%0.valid.? (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Poly) Bool)
(set-info :comment ";; Function-Decl lib::kv::kvimpl_v::UntrustedKvStoreImpl::recover")
(declare-fun lib!kv.kvimpl_v.impl&%0.recover.? (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly) core!option.Option.)
(set-info :comment ";; Function-Decl lib::kv::kvspec_t::AbstractKvStoreState::spec_index")
(declare-fun lib!kv.kvspec_t.impl&%2.spec_index.? (Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly) core!option.Option.)
(set-info :comment ";; Function-Decl lib::kv::kvspec_t::AbstractKvStoreState::empty")
(declare-fun lib!kv.kvspec_t.impl&%2.empty.? (Dcr Type Dcr Type Dcr Type Dcr Type Poly) Bool)
(set-info :comment ";; Function-Decl lib::kv::kvspec_t::AbstractKvStoreState::create")
(declare-fun lib!kv.kvspec_t.impl&%2.create.? (Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly Poly) core!result.Result.)
(set-info :comment ";; Function-Decl lib::kv::kvspec_t::AbstractKvStoreState::read_item_and_list")
(declare-fun lib!kv.kvspec_t.impl&%2.read_item_and_list.? (Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly) core!option.Option.)
(set-info :comment ";; Function-Decl lib::kv::kvspec_t::AbstractKvStoreState::read_list_entry_at_index")
(declare-fun lib!kv.kvspec_t.impl&%2.read_list_entry_at_index.? (Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly Poly) core!result.Result.)
(set-info :comment ";; Function-Decl lib::kv::kvspec_t::AbstractKvStoreState::update_item")
(declare-fun lib!kv.kvspec_t.impl&%2.update_item.? (Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly Poly) core!result.Result.)
(set-info :comment ";; Function-Decl lib::kv::kvspec_t::AbstractKvStoreState::delete")
(declare-fun lib!kv.kvspec_t.impl&%2.delete.? (Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly) core!result.Result.)
(set-info :comment ";; Function-Decl lib::kv::kvspec_t::AbstractKvStoreState::append_to_list")
(declare-fun lib!kv.kvspec_t.impl&%2.append_to_list.? (Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly Poly) core!result.Result.)
(set-info :comment ";; Function-Decl lib::kv::kvspec_t::AbstractKvStoreState::append_to_list_and_update_item")
(declare-fun lib!kv.kvspec_t.impl&%2.append_to_list_and_update_item.? (Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly Poly Poly) core!result.Result.)
(set-info :comment ";; Function-Decl lib::kv::kvspec_t::AbstractKvStoreState::update_list_entry_at_index")
(declare-fun lib!kv.kvspec_t.impl&%2.update_list_entry_at_index.? (Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly Poly Poly) core!result.Result.)
(set-info :comment ";; Function-Decl lib::kv::kvspec_t::AbstractKvStoreState::update_entry_at_index_and_item")
(declare-fun lib!kv.kvspec_t.impl&%2.update_entry_at_index_and_item.? (Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly Poly Poly Poly) core!result.Result.)
(set-info :comment ";; Function-Decl lib::kv::kvspec_t::AbstractKvStoreState::trim_list")
(declare-fun lib!kv.kvspec_t.impl&%2.trim_list.? (Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly Poly) core!result.Result.)
(set-info :comment ";; Function-Decl lib::kv::kvspec_t::AbstractKvStoreState::trim_list_and_update_item")
(declare-fun lib!kv.kvspec_t.impl&%2.trim_list_and_update_item.? (Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly Poly Poly) core!result.Result.)
(set-info :comment ";; Function-Decl lib::kv::kvspec_t::AbstractKvStoreState::get_keys")
(declare-fun lib!kv.kvspec_t.impl&%2.get_keys.? (Dcr Type Dcr Type Dcr Type Dcr Type Poly) Poly)
(set-info :comment ";; Function-Axioms vstd::view::View::view")
(assert (forall ((Self%&. Dcr) (Self%& Type) (self! Poly)) (! (=> (has_type self! Self%&) (has_type (vstd!view.View.view.? Self%&. Self%& self!) (proj%vstd!view.View./V Self%&. Self%&))) :pattern ((vstd!view.View.view.? Self%&. Self%& self!)) )))
(set-info :comment ";; Function-Axioms vstd::seq::Seq::len")
(assert (forall ((A&. Dcr) (A& Type) (self! Poly)) (! (=> (has_type self! (TYPE%vstd!seq.Seq. A&. A&)) (<= 0 (vstd!seq.Seq.len.? A&. A& self!))) :pattern ((vstd!seq.Seq.len.? A&. A& self!)) )))
(set-info :comment ";; Function-Specs vstd::seq::Seq::index")
(declare-fun req%vstd!seq.Seq.index. (Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%0 Bool)
(assert (forall ((A&. Dcr) (A& Type) (self! Poly) (i! Poly)) (! (= (req%vstd!seq.Seq.index. A&. A& self! i!) (=> %%global_location_label%%0 (and (<= 0 (%I i!)) (< (%I i!) (vstd!seq.Seq.len.? A&. A& self!))))) :pattern ((req%vstd!seq.Seq.index. A&. A& self! i!)) )))
(set-info :comment ";; Function-Axioms vstd::seq::Seq::index")
(assert (forall ((A&. Dcr) (A& Type) (self! Poly) (i! Poly)) (! (=> (and (has_type self! (TYPE%vstd!seq.Seq. A&. A&)) (has_type i! INT)) (has_type (vstd!seq.Seq.index.? A&. A& self! i!) A&)) :pattern ((vstd!seq.Seq.index.? A&. A& self! i!)) )))
(set-info :comment ";; Function-Specs vstd::seq::impl&%0::spec_index")
(declare-fun req%vstd!seq.impl&%0.spec_index. (Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%1 Bool)
(assert (forall ((A&. Dcr) (A& Type) (self! Poly) (i! Poly)) (! (= (req%vstd!seq.impl&%0.spec_index. A&. A& self! i!) (=> %%global_location_label%%1 (and (<= 0 (%I i!)) (< (%I i!) (vstd!seq.Seq.len.? A&. A& self!))))) :pattern ((req%vstd!seq.impl&%0.spec_index. A&. A& self! i!)) )))
(set-info :comment ";; Function-Axioms vstd::seq::impl&%0::spec_index")
(assert (fuel_bool_default fuel%vstd!seq.impl&%0.spec_index.))
(assert (=> (fuel_bool fuel%vstd!seq.impl&%0.spec_index.) (forall ((A&. Dcr) (A& Type) (self! Poly) (i! Poly)) (! (= (vstd!seq.impl&%0.spec_index.? A&. A& self! i!) (vstd!seq.Seq.index.? A&. A& self! i!)) :pattern ((vstd!seq.impl&%0.spec_index.? A&. A& self! i!)) ))))
(assert (forall ((A&. Dcr) (A& Type) (self! Poly) (i! Poly)) (! (=> (and (has_type self! (TYPE%vstd!seq.Seq. A&. A&)) (has_type i! INT)) (has_type (vstd!seq.impl&%0.spec_index.? A&. A& self! i!) A&)) :pattern ((vstd!seq.impl&%0.spec_index.? A&. A& self! i!)) )))
(set-info :comment ";; Function-Specs vstd::seq::Seq::subrange")
(declare-fun req%vstd!seq.Seq.subrange. (Dcr Type Poly Poly Poly) Bool)
(declare-const %%global_location_label%%2 Bool)
(assert (forall ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly)) (! (= (req%vstd!seq.Seq.subrange. A&. A& self! start_inclusive! end_exclusive!) (=> %%global_location_label%%2 (and (and (<= 0 (%I start_inclusive!)) (<= (%I start_inclusive!) (%I end_exclusive!))) (<= (%I end_exclusive!) (vstd!seq.Seq.len.? A&. A& self!))))) :pattern ((req%vstd!seq.Seq.subrange. A&. A& self! start_inclusive! end_exclusive!)) )))
(set-info :comment ";; Function-Axioms vstd::seq::Seq::subrange")
(assert (forall ((A&. Dcr) (A& Type) (self! Poly) (start_inclusive! Poly) (end_exclusive! Poly)) (! (=> (and (has_type self! (TYPE%vstd!seq.Seq. A&. A&)) (has_type start_inclusive! INT) (has_type end_exclusive! INT)) (has_type (vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!) (TYPE%vstd!seq.Seq. A&. A&))) :pattern ((vstd!seq.Seq.subrange.? A&. A& self! start_inclusive! end_exclusive!)) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!alloc.Allocator. $ ALLOCATOR_GLOBAL))
(set-info :comment ";; Function-Axioms lib::kv::kvimpl_t::Item::spec_key")
(assert (forall ((Self%&. Dcr) (Self%& Type) (K&. Dcr) (K& Type) (self! Poly)) (! (=> (has_type self! Self%&) (has_type (lib!kv.kvimpl_t.Item.spec_key.? Self%&. Self%& K&. K& self!) K&)) :pattern ((lib!kv.kvimpl_t.Item.spec_key.? Self%&. Self%& K&. K& self!)) )))
(set-info :comment ";; Function-Axioms lib::kv::durable::durableimpl_v::DurableKvStore::view")
(assert (forall ((Self%&. Dcr) (Self%& Type) (PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly)) (! (=> (has_type self! Self%&) (has_type (lib!kv.durable.durableimpl_v.DurableKvStore.view.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& self!) (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreView. K&. K& I&. I& L&. L& E&. E&))) :pattern ((lib!kv.durable.durableimpl_v.DurableKvStore.view.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& self!)) )))
(set-info :comment ";; Function-Axioms lib::kv::durable::durableimpl_v::DurableKvStore::valid")
(assert (forall ((Self%&. Dcr) (Self%& Type) (PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly)) (! (=> (has_type self! Self%&) (has_type (lib!kv.durable.durableimpl_v.DurableKvStore.valid.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& self!) BOOL)) :pattern ((lib!kv.durable.durableimpl_v.DurableKvStore.valid.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& self!)) )))
(set-info :comment ";; Function-Axioms vstd::set::impl&%0::len")
(assert (forall ((A&. Dcr) (A& Type) (self! Poly)) (! (=> (has_type self! (TYPE%vstd!set.Set. A&. A&)) (<= 0 (vstd!set.impl&%0.len.? A&. A& self!))) :pattern ((vstd!set.impl&%0.len.? A&. A& self!)) )))
(set-info :comment ";; Function-Axioms vstd::set_lib::impl&%0::is_empty")
(assert (fuel_bool_default fuel%vstd!set_lib.impl&%0.is_empty.))
(assert (=> (fuel_bool fuel%vstd!set_lib.impl&%0.is_empty.) (forall ((A&. Dcr) (A& Type) (self! Poly)) (! (= (vstd!set_lib.impl&%0.is_empty.? A&. A& self!) (= (vstd!set.impl&%0.len.? A&. A& self!) 0)) :pattern ((vstd!set_lib.impl&%0.is_empty.? A&. A& self!)) ))))
(set-info :comment ";; Function-Axioms vstd::map::impl&%0::dom")
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self! Poly)) (! (=> (has_type self! (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type (vstd!map.impl&%0.dom.? K&. K& V&. V& self!) (TYPE%vstd!set.Set. K&. K&))) :pattern ((vstd!map.impl&%0.dom.? K&. K& V&. V& self!)) )))
(set-info :comment ";; Function-Axioms vstd::map_lib::impl&%0::is_empty")
(assert (fuel_bool_default fuel%vstd!map_lib.impl&%0.is_empty.))
(assert (=> (fuel_bool fuel%vstd!map_lib.impl&%0.is_empty.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self! Poly)) (! (= (vstd!map_lib.impl&%0.is_empty.? K&. K& V&. V& self!) (vstd!set_lib.impl&%0.is_empty.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& self!))) :pattern ((vstd!map_lib.impl&%0.is_empty.? K&. K& V&. V& self!)) ))))
(set-info :comment ";; Function-Axioms lib::kv::durable::durablespec_t::DurableKvStoreView::empty")
(assert (fuel_bool_default fuel%lib!kv.durable.durablespec_t.impl&%2.empty.))
(assert (=> (fuel_bool fuel%lib!kv.durable.durablespec_t.impl&%2.empty.) (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly)) (! (= (lib!kv.durable.durablespec_t.impl&%2.empty.? K&. K& I&. I& L&. L& E&. E& self!) (vstd!set_lib.impl&%0.is_empty.? $ INT (vstd!map.impl&%0.dom.? $ INT $ (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. K&. K& I&. I& L&. L&) (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/contents (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. self!))))) :pattern ((lib!kv.durable.durablespec_t.impl&%2.empty.? K&. K& I&. I& L&. L& E&. E& self!)) ))))
(set-info :comment ";; Function-Axioms vstd::map_lib::impl&%0::contains_key")
(assert (fuel_bool_default fuel%vstd!map_lib.impl&%0.contains_key.))
(assert (=> (fuel_bool fuel%vstd!map_lib.impl&%0.contains_key.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self! Poly) (k! Poly)) (! (= (vstd!map_lib.impl&%0.contains_key.? K&. K& V&. V& self! k!) (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& self!) k!)) :pattern ((vstd!map_lib.impl&%0.contains_key.? K&. K& V&. V& self! k!)) ))))
(set-info :comment ";; Function-Specs vstd::map::impl&%0::index")
(declare-fun req%vstd!map.impl&%0.index. (Dcr Type Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%3 Bool)
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self! Poly) (key! Poly)) (! (= (req%vstd!map.impl&%0.index. K&. K& V&. V& self! key!) (=> %%global_location_label%%3 (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& self!) key!))) :pattern ((req%vstd!map.impl&%0.index. K&. K& V&. V& self! key!)) )))
(set-info :comment ";; Function-Axioms vstd::map::impl&%0::index")
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self! Poly) (key! Poly)) (! (=> (and (has_type self! (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type key! K&)) (has_type (vstd!map.impl&%0.index.? K&. K& V&. V& self! key!) V&)) :pattern ((vstd!map.impl&%0.index.? K&. K& V&. V& self! key!)) )))
(set-info :comment ";; Function-Specs vstd::map::impl&%0::spec_index")
(declare-fun req%vstd!map.impl&%0.spec_index. (Dcr Type Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%4 Bool)
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self! Poly) (key! Poly)) (! (= (req%vstd!map.impl&%0.spec_index. K&. K& V&. V& self! key!) (=> %%global_location_label%%4 (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& self!) key!))) :pattern ((req%vstd!map.impl&%0.spec_index. K&. K& V&. V& self! key!)) )))
(set-info :comment ";; Function-Axioms vstd::map::impl&%0::spec_index")
(assert (fuel_bool_default fuel%vstd!map.impl&%0.spec_index.))
(assert (=> (fuel_bool fuel%vstd!map.impl&%0.spec_index.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self! Poly) (key! Poly)) (! (= (vstd!map.impl&%0.spec_index.? K&. K& V&. V& self! key!) (vstd!map.impl&%0.index.? K&. K& V&. V& self! key!)) :pattern ((vstd!map.impl&%0.spec_index.? K&. K& V&. V& self! key!)) ))))
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self! Poly) (key! Poly)) (! (=> (and (has_type self! (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type key! K&)) (has_type (vstd!map.impl&%0.spec_index.? K&. K& V&. V& self! key!) V&)) :pattern ((vstd!map.impl&%0.spec_index.? K&. K& V&. V& self! key!)) )))
(set-info :comment ";; Function-Axioms lib::kv::durable::durablespec_t::DurableKvStoreView::spec_index")
(assert (fuel_bool_default fuel%lib!kv.durable.durablespec_t.impl&%2.spec_index.))
(assert (=> (fuel_bool fuel%lib!kv.durable.durablespec_t.impl&%2.spec_index.) (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly) (idx! Poly)) (! (= (lib!kv.durable.durablespec_t.impl&%2.spec_index.? K&. K& I&. I& L&. L& E&. E& self! idx!) (ite (vstd!set.impl&%0.contains.? $ INT (vstd!map.impl&%0.dom.? $ INT $ (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. K&. K& I&. I& L&. L&) (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/contents (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. self!))) idx!) (core!option.Option./Some (vstd!map.impl&%0.index.? $ INT $ (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. K&. K& I&. I& L&. L&) (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/contents (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. self!)) idx!)) core!option.Option./None)) :pattern ((lib!kv.durable.durablespec_t.impl&%2.spec_index.? K&. K& I&. I& L&. L& E&. E& self! idx!)) ))))
(assert (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly) (idx! Poly)) (! (=> (and (has_type self! (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreView. K&. K& I&. I& L&. L& E&. E&)) (has_type idx! INT)) (has_type (Poly%core!option.Option. (lib!kv.durable.durablespec_t.impl&%2.spec_index.? K&. K& I&. I& L&. L& E&. E& self! idx!)) (TYPE%core!option.Option. $ (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. K&. K& I&. I& L&. L&)))) :pattern ((lib!kv.durable.durablespec_t.impl&%2.spec_index.? K&. K& I&. I& L&. L& E&. E& self! idx!)) )))
(set-info :comment ";; Function-Axioms lib::kv::durable::durablespec_t::DurableKvStoreView::contains_key")
(assert (fuel_bool_default fuel%lib!kv.durable.durablespec_t.impl&%2.contains_key.))
(assert (=> (fuel_bool fuel%lib!kv.durable.durablespec_t.impl&%2.contains_key.) (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly) (idx! Poly)) (! (= (lib!kv.durable.durablespec_t.impl&%2.contains_key.? K&. K& I&. I& L&. L& E&. E& self! idx!) (is-core!option.Option./Some_ (lib!kv.durable.durablespec_t.impl&%2.spec_index.? K&. K& I&. I& L&. L& E&. E& self! idx!))) :pattern ((lib!kv.durable.durablespec_t.impl&%2.contains_key.? K&. K& I&. I& L&. L& E&. E& self! idx!)) ))))
(set-info :comment ";; Function-Axioms lib::kv::durable::durablespec_t::DurableKvStoreViewEntry::key")
(assert (fuel_bool_default fuel%lib!kv.durable.durablespec_t.impl&%1.key.))
(assert (=> (fuel_bool fuel%lib!kv.durable.durablespec_t.impl&%1.key.) (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (self! Poly)) (! (= (lib!kv.durable.durablespec_t.impl&%1.key.? K&. K& I&. I& L&. L& self!) (lib!kv.durable.durablespec_t.DurableKvStoreViewEntry./DurableKvStoreViewEntry/key (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. self!))) :pattern ((lib!kv.durable.durablespec_t.impl&%1.key.? K&. K& I&. I& L&. L& self!)) ))))
(assert (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (self! Poly)) (! (=> (has_type self! (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. K&. K& I&. I& L&. L&)) (has_type (lib!kv.durable.durablespec_t.impl&%1.key.? K&. K& I&. I& L&. L& self!) K&)) :pattern ((lib!kv.durable.durablespec_t.impl&%1.key.? K&. K& I&. I& L&. L& self!)) )))
(set-info :comment ";; Function-Axioms vstd::std_specs::option::OptionAdditionalFns::is_Some")
(assert (forall ((Self%&. Dcr) (Self%& Type) (T&. Dcr) (T& Type) (self! Poly)) (! (=> (has_type self! Self%&) (has_type (vstd!std_specs.option.OptionAdditionalFns.is_Some.? Self%&. Self%& T&. T& self!) BOOL)) :pattern ((vstd!std_specs.option.OptionAdditionalFns.is_Some.? Self%&. Self%& T&. T& self!)) )))
(set-info :comment ";; Function-Axioms vstd::std_specs::option::OptionAdditionalFns::get_Some_0")
(assert (forall ((Self%&. Dcr) (Self%& Type) (T&. Dcr) (T& Type) (self! Poly)) (! (=> (has_type self! Self%&) (has_type (vstd!std_specs.option.OptionAdditionalFns.get_Some_0.? Self%&. Self%& T&. T& self!) T&)) :pattern ((vstd!std_specs.option.OptionAdditionalFns.get_Some_0.? Self%&. Self%& T&. T& self!)) )))
(set-info :comment ";; Function-Axioms vstd::std_specs::option::OptionAdditionalFns::is_None")
(assert (forall ((Self%&. Dcr) (Self%& Type) (T&. Dcr) (T& Type) (self! Poly)) (! (=> (has_type self! Self%&) (has_type (vstd!std_specs.option.OptionAdditionalFns.is_None.? Self%&. Self%& T&. T& self!) BOOL)) :pattern ((vstd!std_specs.option.OptionAdditionalFns.is_None.? Self%&. Self%& T&. T& self!)) )))
(set-info :comment ";; Function-Axioms vstd::std_specs::option::impl&%0::is_Some")
(assert (fuel_bool_default fuel%vstd!std_specs.option.impl&%0.is_Some.))
(assert (=> (fuel_bool fuel%vstd!std_specs.option.impl&%0.is_Some.) (forall ((T&. Dcr) (T& Type) (self! Poly)) (! (= (vstd!std_specs.option.OptionAdditionalFns.is_Some.? $ (TYPE%core!option.Option. T&. T&) T&. T& self!) (B (is-core!option.Option./Some_ (%Poly%core!option.Option. self!)))) :pattern ((vstd!std_specs.option.OptionAdditionalFns.is_Some.? $ (TYPE%core!option.Option. T&. T&) T&. T& self!)) ))))
(set-info :comment ";; Function-Axioms vstd::std_specs::option::impl&%0::get_Some_0")
(assert (fuel_bool_default fuel%vstd!std_specs.option.impl&%0.get_Some_0.))
(assert (=> (fuel_bool fuel%vstd!std_specs.option.impl&%0.get_Some_0.) (forall ((T&. Dcr) (T& Type) (self! Poly)) (! (= (vstd!std_specs.option.OptionAdditionalFns.get_Some_0.? $ (TYPE%core!option.Option. T&. T&) T&. T& self!) (core!option.Option./Some/0 (%Poly%core!option.Option. self!))) :pattern ((vstd!std_specs.option.OptionAdditionalFns.get_Some_0.? $ (TYPE%core!option.Option. T&. T&) T&. T& self!)) ))))
(set-info :comment ";; Function-Specs vstd::std_specs::option::spec_unwrap")
(declare-fun req%vstd!std_specs.option.spec_unwrap. (Dcr Type Poly) Bool)
(declare-const %%global_location_label%%5 Bool)
(assert (forall ((T&. Dcr) (T& Type) (option! Poly)) (! (= (req%vstd!std_specs.option.spec_unwrap. T&. T& option!) (=> %%global_location_label%%5 (is-core!option.Option./Some_ (%Poly%core!option.Option. option!)))) :pattern ((req%vstd!std_specs.option.spec_unwrap. T&. T& option!)) )))
(set-info :comment ";; Function-Axioms vstd::std_specs::option::spec_unwrap")
(assert (fuel_bool_default fuel%vstd!std_specs.option.spec_unwrap.))
(assert (=> (fuel_bool fuel%vstd!std_specs.option.spec_unwrap.) (forall ((T&. Dcr) (T& Type) (option! Poly)) (! (= (vstd!std_specs.option.spec_unwrap.? T&. T& option!) (core!option.Option./Some/0 (%Poly%core!option.Option. option!))) :pattern ((vstd!std_specs.option.spec_unwrap.? T&. T& option!)) ))))
(assert (forall ((T&. Dcr) (T& Type) (option! Poly)) (! (=> (has_type option! (TYPE%core!option.Option. T&. T&)) (has_type (vstd!std_specs.option.spec_unwrap.? T&. T& option!) T&)) :pattern ((vstd!std_specs.option.spec_unwrap.? T&. T& option!)) )))
(set-info :comment ";; Function-Axioms lib::kv::durable::durablespec_t::DurableKvStoreView::valid")
(assert (fuel_bool_default fuel%lib!kv.durable.durablespec_t.impl&%2.valid.))
(assert (=> (fuel_bool fuel%lib!kv.durable.durablespec_t.impl&%2.valid.) (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly)) (! (= (lib!kv.durable.durablespec_t.impl&%2.valid.? K&. K& I&. I& L&. L& E&. E& self!) (and (forall ((i$ Poly)) (! (=> (has_type i$ INT) (= (lib!kv.durable.durablespec_t.impl&%2.contains_key.? K&. K& I&. I& L&. L& E&. E& self! i$) (vstd!set.impl&%0.contains.? $ INT (vstd!map.impl&%0.dom.? $ INT K&. K& (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/index_to_key_map (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. self!))) i$))) :pattern ((vstd!set.impl&%0.contains.? $ INT (vstd!map.impl&%0.dom.? $ INT K&. K& (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/index_to_key_map (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. self!))) i$)) )) (forall ((i$ Poly)) (! (=> (has_type i$ INT) (=> (vstd!set.impl&%0.contains.? $ INT (vstd!map.impl&%0.dom.? $ INT K&. K& (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/index_to_key_map (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. self!))) i$) (and (is-core!option.Option./Some_ (lib!kv.durable.durablespec_t.impl&%2.spec_index.? K&. K& I&. I& L&. L& E&. E& self! i$)) (= (lib!kv.durable.durablespec_t.impl&%1.key.? K&. K& I&. I& L&. L& (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. (lib!kv.durable.durablespec_t.impl&%2.spec_index.? K&. K& I&. I& L&. L& E&. E& self! i$))))) (vstd!map.impl&%0.index.? $ INT K&. K& (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/index_to_key_map (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. self!)) i$))))) :pattern ((vstd!map.impl&%0.index.? $ INT K&. K& (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/index_to_key_map (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. self!)) i$)) )))) :pattern ((lib!kv.durable.durablespec_t.impl&%2.valid.? K&. K& I&. I& L&. L& E&. E& self!)) ))))
(set-info :comment ";; Function-Specs lib::kv::durable::durableimpl_v::DurableKvStore::new")
(declare-fun ens%lib!kv.durable.durableimpl_v.DurableKvStore.new. (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly Poly Poly Poly) Bool)
(assert (forall ((Self%&. Dcr) (Self%& Type) (PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (pmem! Poly) (kvstore_id! Poly) (max_keys! Poly) (lower_bound_on_max_pages! Poly) (result! Poly)) (! (= (ens%lib!kv.durable.durableimpl_v.DurableKvStore.new. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pmem! kvstore_id! max_keys! lower_bound_on_max_pages! result!) (and (has_type result! (TYPE%core!result.Result. Self%&. Self%& $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) (=> (is-core!result.Result./Ok_ (%Poly%core!result.Result. result!)) (let ((durable_store$ (core!result.Result./Ok/0 (%Poly%core!result.Result. result!)))) (and (and (and (lib!kv.durable.durablespec_t.impl&%2.empty.? K&. K& I&. I& L&. L& E&. E& (lib!kv.durable.durableimpl_v.DurableKvStore.view.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& durable_store$)) (%B (lib!kv.durable.durableimpl_v.DurableKvStore.valid.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& durable_store$))) (lib!kv.durable.durablespec_t.impl&%2.valid.? K&. K& I&. I& L&. L& E&. E& (lib!kv.durable.durableimpl_v.DurableKvStore.view.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& durable_store$))) (vstd!set.impl&%0.finite.? $ INT (vstd!map.impl&%0.dom.? $ INT $ (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. K&. K& I&. I& L&. L&) (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/contents (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. (lib!kv.durable.durableimpl_v.DurableKvStore.view.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& durable_store$)))))))))) :pattern ((ens%lib!kv.durable.durableimpl_v.DurableKvStore.new. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pmem! kvstore_id! max_keys! lower_bound_on_max_pages! result!)) )))
(set-info :comment ";; Function-Axioms vstd::map::impl&%0::insert")
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self! Poly) (key! Poly) (value! Poly)) (! (=> (and (has_type self! (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type key! K&) (has_type value! V&)) (has_type (vstd!map.impl&%0.insert.? K&. K& V&. V& self! key! value!) (TYPE%vstd!map.Map. K&. K& V&. V&))) :pattern ((vstd!map.impl&%0.insert.? K&. K& V&. V& self! key! value!)) )))
(set-info :comment ";; Function-Axioms vstd::seq::Seq::empty")
(assert (forall ((A&. Dcr) (A& Type)) (! (has_type (vstd!seq.Seq.empty.? A&. A&) (TYPE%vstd!seq.Seq. A&. A&)) :pattern ((vstd!seq.Seq.empty.? A&. A&)) )))
(set-info :comment ";; Function-Axioms vstd::map::impl&%0::empty")
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type)) (! (has_type (vstd!map.impl&%0.empty.? K&. K& V&. V&) (TYPE%vstd!map.Map. K&. K& V&. V&)) :pattern ((vstd!map.impl&%0.empty.? K&. K& V&. V&)) )))
(set-info :comment ";; Function-Axioms lib::kv::durable::durablespec_t::DurableKvStoreList::empty")
(assert (fuel_bool_default fuel%lib!kv.durable.durablespec_t.impl&%0.empty.))
(assert (=> (fuel_bool fuel%lib!kv.durable.durablespec_t.impl&%0.empty.) (forall ((L&. Dcr) (L& Type)) (! (= (lib!kv.durable.durablespec_t.impl&%0.empty.? L&. L&) (lib!kv.durable.durablespec_t.DurableKvStoreList./DurableKvStoreList (vstd!seq.Seq.empty.? L&. L&) (%Poly%vstd!map.Map<int./int.>. (vstd!map.impl&%0.empty.? $ INT $ INT)))) :pattern ((lib!kv.durable.durablespec_t.impl&%0.empty.? L&. L&)) ))))
(assert (forall ((L&. Dcr) (L& Type)) (! (has_type (Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (lib!kv.durable.durablespec_t.impl&%0.empty.? L&. L&)) (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreList. L&. L&)) :pattern ((lib!kv.durable.durablespec_t.impl&%0.empty.? L&. L&)) )))
(set-info :comment ";; Function-Axioms lib::kv::durable::durablespec_t::DurableKvStoreView::create")
(assert (fuel_bool_default fuel%lib!kv.durable.durablespec_t.impl&%2.create.))
(assert (=> (fuel_bool fuel%lib!kv.durable.durablespec_t.impl&%2.create.) (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly) (offset! Poly) (item! Poly)) (! (= (lib!kv.durable.durablespec_t.impl&%2.create.? K&. K& I&. I& L&. L& E&. E& self! offset! item!) (ite (vstd!set.impl&%0.contains.? $ INT (vstd!map.impl&%0.dom.? $ INT $ (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. K&. K& I&. I& L&. L&) (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/contents (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. self!))) offset!) (core!result.Result./Err (Poly%lib!kv.kvimpl_t.KvError. lib!kv.kvimpl_t.KvError./KeyAlreadyExists)) (core!result.Result./Ok (Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView (vstd!map.impl&%0.insert.? $ INT $ (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. K&. K& I&. I& L&. L&) (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/contents (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. self!)) offset! (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. (lib!kv.durable.durablespec_t.DurableKvStoreViewEntry./DurableKvStoreViewEntry (lib!kv.kvimpl_t.Item.spec_key.? I&. I& K&. K& item!) item! (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (lib!kv.durable.durablespec_t.impl&%0.empty.? L&. L&)))))) (vstd!map.impl&%0.insert.? $ INT K&. K& (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/index_to_key_map (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. self!)) offset! (lib!kv.kvimpl_t.Item.spec_key.? I&. I& K&. K& item!)) (%Poly%core!option.Option. (Poly%core!option.Option. core!option.Option./None))))))) :pattern ((lib!kv.durable.durablespec_t.impl&%2.create.? K&. K& I&. I& L&. L& E&. E& self! offset! item!)) ))))
(assert (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly) (offset! Poly) (item! Poly)) (! (=> (and (has_type self! (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreView. K&. K& I&. I& L&. L& E&. E&)) (has_type offset! INT) (has_type item! I&)) (has_type (Poly%core!result.Result. (lib!kv.durable.durablespec_t.impl&%2.create.? K&. K& I&. I& L&. L& E&. E& self! offset! item!)) (TYPE%core!result.Result. $ (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreView. K&. K& I&. I& L&. L& E&. E&) $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&)))) :pattern ((lib!kv.durable.durablespec_t.impl&%2.create.? K&. K& I&. I& L&. L& E&. E& self! offset! item!)) )))
(set-info :comment ";; Function-Axioms vstd::map::impl&%0::len")
(assert (fuel_bool_default fuel%vstd!map.impl&%0.len.))
(assert (=> (fuel_bool fuel%vstd!map.impl&%0.len.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self! Poly)) (! (= (vstd!map.impl&%0.len.? K&. K& V&. V& self!) (vstd!set.impl&%0.len.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& self!))) :pattern ((vstd!map.impl&%0.len.? K&. K& V&. V& self!)) ))))
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self! Poly)) (! (=> (has_type self! (TYPE%vstd!map.Map. K&. K& V&. V&)) (<= 0 (vstd!map.impl&%0.len.? K&. K& V&. V& self!))) :pattern ((vstd!map.impl&%0.len.? K&. K& V&. V& self!)) )))
(set-info :comment ";; Function-Axioms lib::kv::durable::durablespec_t::DurableKvStoreView::len")
(assert (fuel_bool_default fuel%lib!kv.durable.durablespec_t.impl&%2.len.))
(assert (=> (fuel_bool fuel%lib!kv.durable.durablespec_t.impl&%2.len.) (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly)) (! (= (lib!kv.durable.durablespec_t.impl&%2.len.? K&. K& I&. I& L&. L& E&. E& self!) (vstd!map.impl&%0.len.? $ INT $ (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. K&. K& I&. I& L&. L&) (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/contents (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. self!)))) :pattern ((lib!kv.durable.durablespec_t.impl&%2.len.? K&. K& I&. I& L&. L& E&. E& self!)) ))))
(assert (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly)) (! (=> (has_type self! (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreView. K&. K& I&. I& L&. L& E&. E&)) (<= 0 (lib!kv.durable.durablespec_t.impl&%2.len.? K&. K& I&. I& L&. L& E&. E& self!))) :pattern ((lib!kv.durable.durablespec_t.impl&%2.len.? K&. K& I&. I& L&. L& E&. E& self!)) )))
(set-info :comment ";; Function-Specs lib::kv::durable::durableimpl_v::DurableKvStore::create")
(declare-fun req%lib!kv.durable.durableimpl_v.DurableKvStore.create. (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly Poly) Bool)
(declare-const %%global_location_label%%6 Bool)
(assert (forall ((Self%&. Dcr) (Self%& Type) (PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (pre%self! Poly) (item! Poly) (perm! Poly)) (! (= (req%lib!kv.durable.durableimpl_v.DurableKvStore.create. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self! item! perm!) (=> %%global_location_label%%6 (%B (lib!kv.durable.durableimpl_v.DurableKvStore.valid.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self!)))) :pattern ((req%lib!kv.durable.durableimpl_v.DurableKvStore.create. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self! item! perm!)) )))
(declare-fun ens%lib!kv.durable.durableimpl_v.DurableKvStore.create. (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly Poly Poly Poly) Bool)
(assert (forall ((Self%&. Dcr) (Self%& Type) (PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (pre%self! Poly) (self! Poly) (item! Poly) (perm! Poly) (result! Poly)) (! (= (ens%lib!kv.durable.durableimpl_v.DurableKvStore.create. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self! self! item! perm! result!) (and (has_type result! (TYPE%core!result.Result. $ (UINT 64) $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) (has_type self! Self%&) (%B (lib!kv.durable.durableimpl_v.DurableKvStore.valid.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& self!)) (and (is-core!result.Result./Ok_ (%Poly%core!result.Result. result!)) (let ((offset$ (%I (core!result.Result./Ok/0 (%Poly%core!result.Result. result!))))) (let ((spec_result$ (lib!kv.durable.durablespec_t.impl&%2.create.? K&. K& I&. I& L&. L& E&. E& (lib!kv.durable.durableimpl_v.DurableKvStore.view.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self!) (I offset$) item!))) (and (is-core!result.Result./Ok_ spec_result$) (let ((spec_result$1 (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. (core!result.Result./Ok/0 (%Poly%core!result.Result. (Poly%core!result.Result. spec_result$)))))) (and (and (and (= (lib!kv.durable.durablespec_t.impl&%2.len.? K&. K& I&. I& L&. L& E&. E& (lib!kv.durable.durableimpl_v.DurableKvStore.view.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& self!)) (nClip (Add (lib!kv.durable.durablespec_t.impl&%2.len.? K&. K& I&. I& L&. L& E&. E& (lib!kv.durable.durableimpl_v.DurableKvStore.view.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self!)) 1))) (= (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. (lib!kv.durable.durableimpl_v.DurableKvStore.view.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& self!)) spec_result$1)) (and (<= 0 offset$) (< offset$ (lib!kv.durable.durablespec_t.impl&%2.len.? K&. K& I&. I& L&. L& E&. E& (lib!kv.durable.durableimpl_v.DurableKvStore.view.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& self!))))) (is-core!option.Option./Some_ (lib!kv.durable.durablespec_t.impl&%2.spec_index.? K&. K& I&. I& L&. L& E&. E& (lib!kv.durable.durableimpl_v.DurableKvStore.view.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& self!) (I offset$))))))))))) :pattern ((ens%lib!kv.durable.durableimpl_v.DurableKvStore.create. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self! self! item! perm! result!)) )))
(set-info :comment ";; Function-Axioms lib::kv::durable::durablespec_t::DurableKvStoreViewEntry::item")
(assert (fuel_bool_default fuel%lib!kv.durable.durablespec_t.impl&%1.item.))
(assert (=> (fuel_bool fuel%lib!kv.durable.durablespec_t.impl&%1.item.) (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (self! Poly)) (! (= (lib!kv.durable.durablespec_t.impl&%1.item.? K&. K& I&. I& L&. L& self!) (lib!kv.durable.durablespec_t.DurableKvStoreViewEntry./DurableKvStoreViewEntry/item (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. self!))) :pattern ((lib!kv.durable.durablespec_t.impl&%1.item.? K&. K& I&. I& L&. L& self!)) ))))
(assert (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (self! Poly)) (! (=> (has_type self! (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. K&. K& I&. I& L&. L&)) (has_type (lib!kv.durable.durablespec_t.impl&%1.item.? K&. K& I&. I& L&. L& self!) I&)) :pattern ((lib!kv.durable.durablespec_t.impl&%1.item.? K&. K& I&. I& L&. L& self!)) )))
(set-info :comment ";; Function-Axioms vstd::std_specs::option::impl&%0::is_None")
(assert (fuel_bool_default fuel%vstd!std_specs.option.impl&%0.is_None.))
(assert (=> (fuel_bool fuel%vstd!std_specs.option.impl&%0.is_None.) (forall ((T&. Dcr) (T& Type) (self! Poly)) (! (= (vstd!std_specs.option.OptionAdditionalFns.is_None.? $ (TYPE%core!option.Option. T&. T&) T&. T& self!) (B (is-core!option.Option./None_ (%Poly%core!option.Option. self!)))) :pattern ((vstd!std_specs.option.OptionAdditionalFns.is_None.? $ (TYPE%core!option.Option. T&. T&) T&. T& self!)) ))))
(set-info :comment ";; Function-Specs lib::kv::durable::durableimpl_v::DurableKvStore::read_item")
(declare-fun req%lib!kv.durable.durableimpl_v.DurableKvStore.read_item. (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%7 Bool)
(assert (forall ((Self%&. Dcr) (Self%& Type) (PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly) (offset! Poly)) (! (= (req%lib!kv.durable.durableimpl_v.DurableKvStore.read_item. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& self! offset!) (=> %%global_location_label%%7 (%B (lib!kv.durable.durableimpl_v.DurableKvStore.valid.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& self!)))) :pattern ((req%lib!kv.durable.durableimpl_v.DurableKvStore.read_item. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& self! offset!)) )))
(declare-fun ens%lib!kv.durable.durableimpl_v.DurableKvStore.read_item. (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly Poly) Bool)
(assert (forall ((Self%&. Dcr) (Self%& Type) (PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly) (offset! Poly) (result! Poly)) (! (= (ens%lib!kv.durable.durableimpl_v.DurableKvStore.read_item. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& self! offset! result!) (and (has_type result! (TYPE%core!option.Option. (REF I&.) I&)) (ite (is-core!option.Option./Some_ (%Poly%core!option.Option. result!)) (let ((item$ (core!option.Option./Some/0 (%Poly%core!option.Option. result!)))) (let ((tmp%%$ (lib!kv.durable.durablespec_t.impl&%2.spec_index.? K&. K& I&. I& L&. L& E&. E& (lib!kv.durable.durableimpl_v.DurableKvStore.view.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& self!) offset!))) (and (is-core!option.Option./Some_ tmp%%$) (let ((entry$ (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. tmp%%$)))))) (= (lib!kv.durable.durablespec_t.impl&%1.item.? K&. K& I&. I& L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. entry$)) item$))))) (is-core!option.Option./None_ (lib!kv.durable.durablespec_t.impl&%2.spec_index.? K&. K& I&. I& L&. L& E&. E& (lib!kv.durable.durableimpl_v.DurableKvStore.view.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& self!) offset!))))) :pattern ((ens%lib!kv.durable.durableimpl_v.DurableKvStore.read_item. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& self! offset! result!)) )))
(set-info :comment ";; Function-Axioms lib::kv::durable::durablespec_t::DurableKvStoreList::spec_index")
(assert (fuel_bool_default fuel%lib!kv.durable.durablespec_t.impl&%0.spec_index.))
(assert (=> (fuel_bool fuel%lib!kv.durable.durablespec_t.impl&%0.spec_index.) (forall ((L&. Dcr) (L& Type) (self! Poly) (idx! Poly)) (! (= (lib!kv.durable.durablespec_t.impl&%0.spec_index.? L&. L& self! idx!) (ite (< (%I idx!) (vstd!seq.Seq.len.? L&. L& (lib!kv.durable.durablespec_t.DurableKvStoreList./DurableKvStoreList/list (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. self!)))) (core!option.Option./Some (vstd!seq.Seq.index.? L&. L& (lib!kv.durable.durablespec_t.DurableKvStoreList./DurableKvStoreList/list (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. self!)) idx!)) core!option.Option./None)) :pattern ((lib!kv.durable.durablespec_t.impl&%0.spec_index.? L&. L& self! idx!)) ))))
(assert (forall ((L&. Dcr) (L& Type) (self! Poly) (idx! Poly)) (! (=> (and (has_type self! (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreList. L&. L&)) (has_type idx! INT)) (has_type (Poly%core!option.Option. (lib!kv.durable.durablespec_t.impl&%0.spec_index.? L&. L& self! idx!)) (TYPE%core!option.Option. L&. L&))) :pattern ((lib!kv.durable.durablespec_t.impl&%0.spec_index.? L&. L& self! idx!)) )))
(set-info :comment ";; Function-Axioms lib::kv::durable::durablespec_t::DurableKvStoreViewEntry::list")
(assert (fuel_bool_default fuel%lib!kv.durable.durablespec_t.impl&%1.list.))
(assert (=> (fuel_bool fuel%lib!kv.durable.durablespec_t.impl&%1.list.) (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (self! Poly)) (! (= (lib!kv.durable.durablespec_t.impl&%1.list.? K&. K& I&. I& L&. L& self!) (lib!kv.durable.durablespec_t.DurableKvStoreViewEntry./DurableKvStoreViewEntry/list (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. self!))) :pattern ((lib!kv.durable.durablespec_t.impl&%1.list.? K&. K& I&. I& L&. L& self!)) ))))
(assert (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (self! Poly)) (! (=> (has_type self! (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. K&. K& I&. I& L&. L&)) (has_type (Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (lib!kv.durable.durablespec_t.impl&%1.list.? K&. K& I&. I& L&. L& self!)) (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreList. L&. L&))) :pattern ((lib!kv.durable.durablespec_t.impl&%1.list.? K&. K& I&. I& L&. L& self!)) )))
(set-info :comment ";; Function-Specs lib::kv::durable::durableimpl_v::DurableKvStore::update_item")
(declare-fun req%lib!kv.durable.durableimpl_v.DurableKvStore.update_item. (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly Poly) Bool)
(declare-const %%global_location_label%%8 Bool)
(assert (forall ((Self%&. Dcr) (Self%& Type) (PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (pre%self! Poly) (offset! Poly) (new_item! Poly)) (! (= (req%lib!kv.durable.durableimpl_v.DurableKvStore.update_item. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self! offset! new_item!) (=> %%global_location_label%%8 (%B (lib!kv.durable.durableimpl_v.DurableKvStore.valid.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self!)))) :pattern ((req%lib!kv.durable.durableimpl_v.DurableKvStore.update_item. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self! offset! new_item!)) )))
(declare-fun ens%lib!kv.durable.durableimpl_v.DurableKvStore.update_item. (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly Poly Poly Poly) Bool)
(define-fun is-tuple%0./tuple%0_ ((c tuple%0.)) Bool ((_ is tuple%0./tuple%0) c))
(define-fun is-lib!kv.kvimpl_t.KvError./KeyNotFound_ ((c lib!kv.kvimpl_t.KvError.)) Bool ((_ is lib!kv.kvimpl_t.KvError./KeyNotFound) c))
(assert (forall ((Self%&. Dcr) (Self%& Type) (PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (pre%self! Poly) (self! Poly) (offset! Poly) (new_item! Poly) (result! Poly)) (! (= (ens%lib!kv.durable.durableimpl_v.DurableKvStore.update_item. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self! self! offset! new_item! result!) (and (has_type result! (TYPE%core!result.Result. $ TYPE%tuple%0. $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) (has_type self! Self%&) (%B (lib!kv.durable.durableimpl_v.DurableKvStore.valid.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& self!)) (ite (and (is-core!result.Result./Ok_ (%Poly%core!result.Result. result!)) (is-tuple%0./tuple%0_ (%Poly%tuple%0. (core!result.Result./Ok/0 (%Poly%core!result.Result. result!))))) (let ((tmp%%$ (tuple%2./tuple%2 (Poly%core!option.Option. (lib!kv.durable.durablespec_t.impl&%2.spec_index.? K&. K& I&. I& L&. L& E&. E& (lib!kv.durable.durableimpl_v.DurableKvStore.view.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self!) offset!)) (Poly%core!option.Option. (lib!kv.durable.durablespec_t.impl&%2.spec_index.? K&. K& I&. I& L&. L& E&. E& (lib!kv.durable.durableimpl_v.DurableKvStore.view.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& self!) offset!))))) (and (and (and (is-tuple%2./tuple%2_ tmp%%$) (is-core!option.Option./Some_ (%Poly%core!option.Option. (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$)))))) (is-core!option.Option./Some_ (%Poly%core!option.Option. (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$)))))) (let ((old_entry$ (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. (core!option.Option./Some/0 (%Poly%core!option.Option. (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$)))))))) (let ((entry$ (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. (core!option.Option./Some/0 (%Poly%core!option.Option. (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$)))))))) (and (and (= (lib!kv.durable.durablespec_t.impl&%1.key.? K&. K& I&. I& L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. entry$)) (lib!kv.durable.durablespec_t.impl&%1.key.? K&. K& I&. I& L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. old_entry$))) (= (lib!kv.durable.durablespec_t.impl&%1.item.? K&. K& I&. I& L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. entry$)) new_item!)) (= (lib!kv.durable.durablespec_t.impl&%1.list.? K&. K& I&. I& L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. entry$)) (lib!kv.durable.durablespec_t.impl&%1.list.? K&. K& I&. I& L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. old_entry$)))))))) (=> (and (is-core!result.Result./Err_ (%Poly%core!result.Result. result!)) (is-lib!kv.kvimpl_t.KvError./KeyNotFound_ (%Poly%lib!kv.kvimpl_t.KvError. (core!result.Result./Err/0 (%Poly%core!result.Result. result!))))) (is-core!option.Option./None_ (lib!kv.durable.durablespec_t.impl&%2.spec_index.? K&. K& I&. I& L&. L& E&. E& (lib!kv.durable.durableimpl_v.DurableKvStore.view.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& self!) offset!)))))) :pattern ((ens%lib!kv.durable.durableimpl_v.DurableKvStore.update_item. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self! self! offset! new_item! result!)) )))
(set-info :comment ";; Function-Specs lib::kv::durable::durableimpl_v::DurableKvStore::delete")
(declare-fun req%lib!kv.durable.durableimpl_v.DurableKvStore.delete. (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly Poly) Bool)
(declare-const %%global_location_label%%9 Bool)
(assert (forall ((Self%&. Dcr) (Self%& Type) (PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (pre%self! Poly) (offset! Poly) (perm! Poly)) (! (= (req%lib!kv.durable.durableimpl_v.DurableKvStore.delete. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self! offset! perm!) (=> %%global_location_label%%9 (%B (lib!kv.durable.durableimpl_v.DurableKvStore.valid.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self!)))) :pattern ((req%lib!kv.durable.durableimpl_v.DurableKvStore.delete. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self! offset! perm!)) )))
(declare-fun ens%lib!kv.durable.durableimpl_v.DurableKvStore.delete. (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly Poly Poly Poly) Bool)
(assert (forall ((Self%&. Dcr) (Self%& Type) (PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (pre%self! Poly) (self! Poly) (offset! Poly) (perm! Poly) (result! Poly)) (! (= (ens%lib!kv.durable.durableimpl_v.DurableKvStore.delete. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self! self! offset! perm! result!) (and (has_type result! (TYPE%core!result.Result. $ TYPE%tuple%0. $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) (has_type self! Self%&) (%B (lib!kv.durable.durableimpl_v.DurableKvStore.valid.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& self!)) (=> (and (is-core!result.Result./Ok_ (%Poly%core!result.Result. result!)) (is-tuple%0./tuple%0_ (%Poly%tuple%0. (core!result.Result./Ok/0 (%Poly%core!result.Result. result!))))) (is-core!option.Option./None_ (lib!kv.durable.durablespec_t.impl&%2.spec_index.? K&. K& I&. I& L&. L& E&. E& (lib!kv.durable.durableimpl_v.DurableKvStore.view.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& self!) offset!))))) :pattern ((ens%lib!kv.durable.durableimpl_v.DurableKvStore.delete. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self! self! offset! perm! result!)) )))
(set-info :comment ";; Function-Axioms vstd::seq::Seq::push")
(assert (forall ((A&. Dcr) (A& Type) (self! Poly) (a! Poly)) (! (=> (and (has_type self! (TYPE%vstd!seq.Seq. A&. A&)) (has_type a! A&)) (has_type (vstd!seq.Seq.push.? A&. A& self! a!) (TYPE%vstd!seq.Seq. A&. A&))) :pattern ((vstd!seq.Seq.push.? A&. A& self! a!)) )))
(set-info :comment ";; Function-Specs lib::kv::durable::durableimpl_v::DurableKvStore::update_item_and_append")
(declare-fun req%lib!kv.durable.durableimpl_v.DurableKvStore.update_item_and_append. (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly Poly Poly Poly) Bool)
(declare-const %%global_location_label%%10 Bool)
(assert (forall ((Self%&. Dcr) (Self%& Type) (PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (pre%self! Poly) (offset! Poly) (new_entry! Poly) (new_item! Poly) (perm! Poly)) (! (= (req%lib!kv.durable.durableimpl_v.DurableKvStore.update_item_and_append. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self! offset! new_entry! new_item! perm!) (=> %%global_location_label%%10 (%B (lib!kv.durable.durableimpl_v.DurableKvStore.valid.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self!)))) :pattern ((req%lib!kv.durable.durableimpl_v.DurableKvStore.update_item_and_append. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self! offset! new_entry! new_item! perm!)) )))
(declare-fun ens%lib!kv.durable.durableimpl_v.DurableKvStore.update_item_and_append. (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly Poly Poly Poly Poly Poly) Bool)
(assert (forall ((Self%&. Dcr) (Self%& Type) (PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (pre%self! Poly) (self! Poly) (offset! Poly) (new_entry! Poly) (new_item! Poly) (perm! Poly) (result! Poly)) (! (= (ens%lib!kv.durable.durableimpl_v.DurableKvStore.update_item_and_append. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self! self! offset! new_entry! new_item! perm! result!) (and (has_type result! (TYPE%core!result.Result. $ (UINT 64) $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) (has_type self! Self%&) (%B (lib!kv.durable.durableimpl_v.DurableKvStore.valid.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& self!)) (and (is-core!result.Result./Ok_ (%Poly%core!result.Result. result!)) (let ((phys_offset$ (%I (core!result.Result./Ok/0 (%Poly%core!result.Result. result!))))) (let ((old_record$ (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. (vstd!map.impl&%0.index.? $ INT $ (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. K&. K& I&. I& L&. L&) (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/contents (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. (lib!kv.durable.durableimpl_v.DurableKvStore.view.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self!))) offset!)))) (let ((new_record$ (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. (vstd!map.impl&%0.index.? $ INT $ (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. K&. K& I&. I& L&. L&) (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/contents (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. (lib!kv.durable.durableimpl_v.DurableKvStore.view.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& self!))) offset!)))) (and (= (lib!kv.durable.durablespec_t.impl&%1.item.? K&. K& I&. I& L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. new_record$)) new_item!) (= (lib!kv.durable.durablespec_t.DurableKvStoreList./DurableKvStoreList/list (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (lib!kv.durable.durablespec_t.impl&%1.list.? K&. K& I&. I& L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. new_record$))))) (vstd!seq.Seq.push.? L&. L& (lib!kv.durable.durablespec_t.DurableKvStoreList./DurableKvStoreList/list (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (lib!kv.durable.durablespec_t.impl&%1.list.? K&. K& I&. I& L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. old_record$))))) new_entry!))))))))) :pattern ((ens%lib!kv.durable.durableimpl_v.DurableKvStore.update_item_and_append. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self! self! offset! new_entry! new_item! perm! result!)) )))
(set-info :comment ";; Function-Specs lib::kv::durable::durableimpl_v::DurableKvStore::update_list_entry_at_index")
(declare-fun req%lib!kv.durable.durableimpl_v.DurableKvStore.update_list_entry_at_index. (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly Poly Poly Poly) Bool)
(declare-const %%global_location_label%%11 Bool)
(assert (forall ((Self%&. Dcr) (Self%& Type) (PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (pre%self! Poly) (item_offset! Poly) (entry_offset! Poly) (new_entry! Poly) (perm! Poly)) (! (= (req%lib!kv.durable.durableimpl_v.DurableKvStore.update_list_entry_at_index. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self! item_offset! entry_offset! new_entry! perm!) (=> %%global_location_label%%11 (%B (lib!kv.durable.durableimpl_v.DurableKvStore.valid.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self!)))) :pattern ((req%lib!kv.durable.durableimpl_v.DurableKvStore.update_list_entry_at_index. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self! item_offset! entry_offset! new_entry! perm!)) )))
(declare-fun ens%lib!kv.durable.durableimpl_v.DurableKvStore.update_list_entry_at_index. (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly Poly Poly Poly Poly Poly) Bool)
(assert (forall ((Self%&. Dcr) (Self%& Type) (PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (pre%self! Poly) (self! Poly) (item_offset! Poly) (entry_offset! Poly) (new_entry! Poly) (perm! Poly) (result! Poly)) (! (= (ens%lib!kv.durable.durableimpl_v.DurableKvStore.update_list_entry_at_index. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self! self! item_offset! entry_offset! new_entry! perm! result!) (and (has_type result! (TYPE%core!result.Result. $ TYPE%tuple%0. $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) (has_type self! Self%&) (%B (lib!kv.durable.durableimpl_v.DurableKvStore.valid.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& self!)) (and (and (is-core!result.Result./Ok_ (%Poly%core!result.Result. result!)) (is-tuple%0./tuple%0_ (%Poly%tuple%0. (core!result.Result./Ok/0 (%Poly%core!result.Result. result!))))) (let ((old_record$ (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. (vstd!map.impl&%0.index.? $ INT $ (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. K&. K& I&. I& L&. L&) (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/contents (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. (lib!kv.durable.durableimpl_v.DurableKvStore.view.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self!))) item_offset!)))) (let ((new_record$ (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. (vstd!map.impl&%0.index.? $ INT $ (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. K&. K& I&. I& L&. L&) (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/contents (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. (lib!kv.durable.durableimpl_v.DurableKvStore.view.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& self!))) item_offset!)))) (let ((list_index$ (%I (vstd!map.impl&%0.index.? $ INT $ INT (Poly%vstd!map.Map<int./int.>. (lib!kv.durable.durablespec_t.DurableKvStoreList./DurableKvStoreList/node_offset_map (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (lib!kv.durable.durablespec_t.impl&%1.list.? K&. K& I&. I& L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. new_record$)))))) entry_offset!)))) (and (and (= list_index$ (%I (vstd!map.impl&%0.index.? $ INT $ INT (Poly%vstd!map.Map<int./int.>. (lib!kv.durable.durablespec_t.DurableKvStoreList./DurableKvStoreList/node_offset_map (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (lib!kv.durable.durablespec_t.impl&%1.list.? K&. K& I&. I& L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. old_record$)))))) entry_offset!))) (is-core!option.Option./Some_ (lib!kv.durable.durablespec_t.impl&%0.spec_index.? L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (lib!kv.durable.durablespec_t.impl&%1.list.? K&. K& I&. I& L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. new_record$))) (I list_index$)))) (= (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. (lib!kv.durable.durablespec_t.impl&%0.spec_index.? L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (lib!kv.durable.durablespec_t.impl&%1.list.? K&. K& I&. I& L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. new_record$))) (I list_index$))))) new_entry!)))))))) :pattern ((ens%lib!kv.durable.durableimpl_v.DurableKvStore.update_list_entry_at_index. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self! self! item_offset! entry_offset! new_entry! perm! result!)) )))
(set-info :comment ";; Function-Specs lib::kv::durable::durableimpl_v::DurableKvStore::update_entry_at_index_and_item")
(declare-fun req%lib!kv.durable.durableimpl_v.DurableKvStore.update_entry_at_index_and_item. (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly Poly Poly Poly Poly) Bool)
(declare-const %%global_location_label%%12 Bool)
(assert (forall ((Self%&. Dcr) (Self%& Type) (PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (pre%self! Poly) (item_offset! Poly) (entry_offset! Poly) (new_item! Poly) (new_entry! Poly) (perm! Poly)) (! (= (req%lib!kv.durable.durableimpl_v.DurableKvStore.update_entry_at_index_and_item. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self! item_offset! entry_offset! new_item! new_entry! perm!) (=> %%global_location_label%%12 (%B (lib!kv.durable.durableimpl_v.DurableKvStore.valid.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self!)))) :pattern ((req%lib!kv.durable.durableimpl_v.DurableKvStore.update_entry_at_index_and_item. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self! item_offset! entry_offset! new_item! new_entry! perm!)) )))
(declare-fun ens%lib!kv.durable.durableimpl_v.DurableKvStore.update_entry_at_index_and_item. (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly Poly Poly Poly Poly Poly Poly) Bool)
(assert (forall ((Self%&. Dcr) (Self%& Type) (PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (pre%self! Poly) (self! Poly) (item_offset! Poly) (entry_offset! Poly) (new_item! Poly) (new_entry! Poly) (perm! Poly) (result! Poly)) (! (= (ens%lib!kv.durable.durableimpl_v.DurableKvStore.update_entry_at_index_and_item. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self! self! item_offset! entry_offset! new_item! new_entry! perm! result!) (and (has_type result! (TYPE%core!result.Result. $ TYPE%tuple%0. $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) (has_type self! Self%&) (%B (lib!kv.durable.durableimpl_v.DurableKvStore.valid.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& self!)) (and (and (is-core!result.Result./Ok_ (%Poly%core!result.Result. result!)) (is-tuple%0./tuple%0_ (%Poly%tuple%0. (core!result.Result./Ok/0 (%Poly%core!result.Result. result!))))) (let ((old_record$ (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. (vstd!map.impl&%0.index.? $ INT $ (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. K&. K& I&. I& L&. L&) (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/contents (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. (lib!kv.durable.durableimpl_v.DurableKvStore.view.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self!))) item_offset!)))) (let ((new_record$ (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. (vstd!map.impl&%0.index.? $ INT $ (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. K&. K& I&. I& L&. L&) (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/contents (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. (lib!kv.durable.durableimpl_v.DurableKvStore.view.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& self!))) item_offset!)))) (let ((list_index$ (%I (vstd!map.impl&%0.index.? $ INT $ INT (Poly%vstd!map.Map<int./int.>. (lib!kv.durable.durablespec_t.DurableKvStoreList./DurableKvStoreList/node_offset_map (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (lib!kv.durable.durablespec_t.impl&%1.list.? K&. K& I&. I& L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. new_record$)))))) entry_offset!)))) (and (and (and (= list_index$ (%I (vstd!map.impl&%0.index.? $ INT $ INT (Poly%vstd!map.Map<int./int.>. (lib!kv.durable.durablespec_t.DurableKvStoreList./DurableKvStoreList/node_offset_map (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (lib!kv.durable.durablespec_t.impl&%1.list.? K&. K& I&. I& L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. old_record$)))))) entry_offset!))) (is-core!option.Option./Some_ (lib!kv.durable.durablespec_t.impl&%0.spec_index.? L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (lib!kv.durable.durablespec_t.impl&%1.list.? K&. K& I&. I& L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. new_record$))) (I list_index$)))) (= (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. (lib!kv.durable.durablespec_t.impl&%0.spec_index.? L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (lib!kv.durable.durablespec_t.impl&%1.list.? K&. K& I&. I& L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. new_record$))) (I list_index$))))) new_entry!)) (= (lib!kv.durable.durablespec_t.impl&%1.item.? K&. K& I&. I& L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. new_record$)) new_item!)))))))) :pattern ((ens%lib!kv.durable.durableimpl_v.DurableKvStore.update_entry_at_index_and_item. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self! self! item_offset! entry_offset! new_item! new_entry! perm! result!)) )))
(set-info :comment ";; Function-Axioms lib::kv::durable::durablespec_t::DurableKvStoreList::len")
(assert (fuel_bool_default fuel%lib!kv.durable.durablespec_t.impl&%0.len.))
(assert (=> (fuel_bool fuel%lib!kv.durable.durablespec_t.impl&%0.len.) (forall ((L&. Dcr) (L& Type) (self! Poly)) (! (= (lib!kv.durable.durablespec_t.impl&%0.len.? L&. L& self!) (vstd!seq.Seq.len.? L&. L& (lib!kv.durable.durablespec_t.DurableKvStoreList./DurableKvStoreList/list (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. self!)))) :pattern ((lib!kv.durable.durablespec_t.impl&%0.len.? L&. L& self!)) ))))
(set-info :comment ";; Function-Axioms lib::kv::durable::durablespec_t::DurableKvStoreList::offset_index")
(assert (fuel_bool_default fuel%lib!kv.durable.durablespec_t.impl&%0.offset_index.))
(assert (=> (fuel_bool fuel%lib!kv.durable.durablespec_t.impl&%0.offset_index.) (forall ((L&. Dcr) (L& Type) (self! Poly) (offset! Poly)) (! (= (lib!kv.durable.durablespec_t.impl&%0.offset_index.? L&. L& self! offset!) (ite (vstd!set.impl&%0.contains.? $ INT (vstd!map.impl&%0.dom.? $ INT $ INT (Poly%vstd!map.Map<int./int.>. (lib!kv.durable.durablespec_t.DurableKvStoreList./DurableKvStoreList/node_offset_map (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. self!)))) offset!) (core!option.Option./Some (vstd!map.impl&%0.index.? $ INT $ INT (Poly%vstd!map.Map<int./int.>. (lib!kv.durable.durablespec_t.DurableKvStoreList./DurableKvStoreList/node_offset_map (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. self!))) offset!)) core!option.Option./None)) :pattern ((lib!kv.durable.durablespec_t.impl&%0.offset_index.? L&. L& self! offset!)) ))))
(assert (forall ((L&. Dcr) (L& Type) (self! Poly) (offset! Poly)) (! (=> (and (has_type self! (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreList. L&. L&)) (has_type offset! INT)) (has_type (Poly%core!option.Option. (lib!kv.durable.durablespec_t.impl&%0.offset_index.? L&. L& self! offset!)) (TYPE%core!option.Option. $ INT))) :pattern ((lib!kv.durable.durablespec_t.impl&%0.offset_index.? L&. L& self! offset!)) )))
(set-info :comment ";; Function-Specs lib::kv::durable::durableimpl_v::DurableKvStore::trim_list")
(declare-fun req%lib!kv.durable.durableimpl_v.DurableKvStore.trim_list. (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly Poly Poly Poly Poly) Bool)
(declare-const %%global_location_label%%13 Bool)
(assert (forall ((Self%&. Dcr) (Self%& Type) (PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (pre%self! Poly) (item_offset! Poly) (old_head_node_offset! Poly) (new_head_node_offset! Poly) (trim_length! Poly) (perm! Poly)) (! (= (req%lib!kv.durable.durableimpl_v.DurableKvStore.trim_list. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self! item_offset! old_head_node_offset! new_head_node_offset! trim_length! perm!) (=> %%global_location_label%%13 (%B (lib!kv.durable.durableimpl_v.DurableKvStore.valid.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self!)))) :pattern ((req%lib!kv.durable.durableimpl_v.DurableKvStore.trim_list. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self! item_offset! old_head_node_offset! new_head_node_offset! trim_length! perm!)) )))
(declare-fun ens%lib!kv.durable.durableimpl_v.DurableKvStore.trim_list. (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly Poly Poly Poly Poly Poly Poly) Bool)
(assert (forall ((Self%&. Dcr) (Self%& Type) (PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (pre%self! Poly) (self! Poly) (item_offset! Poly) (old_head_node_offset! Poly) (new_head_node_offset! Poly) (trim_length! Poly) (perm! Poly) (result! Poly)) (! (= (ens%lib!kv.durable.durableimpl_v.DurableKvStore.trim_list. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self! self! item_offset! old_head_node_offset! new_head_node_offset! trim_length! perm! result!) (and (has_type result! (TYPE%core!result.Result. $ TYPE%tuple%0. $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) (has_type self! Self%&) (%B (lib!kv.durable.durableimpl_v.DurableKvStore.valid.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& self!)) (and (and (is-core!result.Result./Ok_ (%Poly%core!result.Result. result!)) (is-tuple%0./tuple%0_ (%Poly%tuple%0. (core!result.Result./Ok/0 (%Poly%core!result.Result. result!))))) (let ((old_record$ (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. (vstd!map.impl&%0.index.? $ INT $ (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. K&. K& I&. I& L&. L&) (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/contents (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. (lib!kv.durable.durableimpl_v.DurableKvStore.view.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self!))) item_offset!)))) (let ((new_record$ (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. (vstd!map.impl&%0.index.? $ INT $ (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. K&. K& I&. I& L&. L&) (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/contents (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. (lib!kv.durable.durableimpl_v.DurableKvStore.view.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& self!))) item_offset!)))) (and (= (lib!kv.durable.durablespec_t.DurableKvStoreList./DurableKvStoreList/list (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (lib!kv.durable.durablespec_t.impl&%1.list.? K&. K& I&. I& L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. new_record$))))) (vstd!seq.Seq.subrange.? L&. L& (lib!kv.durable.durablespec_t.DurableKvStoreList./DurableKvStoreList/list (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (lib!kv.durable.durablespec_t.impl&%1.list.? K&. K& I&. I& L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. old_record$))))) trim_length! (I (lib!kv.durable.durablespec_t.impl&%0.len.? L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (lib!kv.durable.durablespec_t.impl&%1.list.? K&. K& I&. I& L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. old_record$))))))) (forall ((i$ Poly)) (! (=> (has_type i$ INT) (=> (let ((tmp%%$ (%I (vstd!map.impl&%0.index.? $ INT $ INT (Poly%vstd!map.Map<int./int.>. (lib!kv.durable.durablespec_t.DurableKvStoreList./DurableKvStoreList/node_offset_map (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (lib!kv.durable.durablespec_t.impl&%1.list.? K&. K& I&. I& L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. old_record$)))))) i$)))) (and (<= 0 tmp%%$) (< tmp%%$ (%I trim_length!)))) (is-core!option.Option./None_ (lib!kv.durable.durablespec_t.impl&%0.offset_index.? L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (lib!kv.durable.durablespec_t.impl&%1.list.? K&. K& I&. I& L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. new_record$))) i$)))) :pattern ((lib!kv.durable.durablespec_t.impl&%0.offset_index.? L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (lib!kv.durable.durablespec_t.impl&%1.list.? K&. K& I&. I& L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. new_record$))) i$)) )))))))) :pattern ((ens%lib!kv.durable.durableimpl_v.DurableKvStore.trim_list. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self! self! item_offset! old_head_node_offset! new_head_node_offset! trim_length! perm! result!)) )))
(set-info :comment ";; Function-Specs lib::kv::durable::durableimpl_v::DurableKvStore::trim_list_and_update_item")
(declare-fun req%lib!kv.durable.durableimpl_v.DurableKvStore.trim_list_and_update_item. (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly Poly Poly Poly Poly Poly) Bool)
(declare-const %%global_location_label%%14 Bool)
(assert (forall ((Self%&. Dcr) (Self%& Type) (PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (pre%self! Poly) (item_offset! Poly) (old_head_node_offset! Poly) (new_head_node_offset! Poly) (trim_length! Poly) (new_item! Poly) (perm! Poly)) (! (= (req%lib!kv.durable.durableimpl_v.DurableKvStore.trim_list_and_update_item. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self! item_offset! old_head_node_offset! new_head_node_offset! trim_length! new_item! perm!) (=> %%global_location_label%%14 (%B (lib!kv.durable.durableimpl_v.DurableKvStore.valid.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self!)))) :pattern ((req%lib!kv.durable.durableimpl_v.DurableKvStore.trim_list_and_update_item. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self! item_offset! old_head_node_offset! new_head_node_offset! trim_length! new_item! perm!)) )))
(declare-fun ens%lib!kv.durable.durableimpl_v.DurableKvStore.trim_list_and_update_item. (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly Poly Poly Poly Poly Poly Poly Poly) Bool)
(assert (forall ((Self%&. Dcr) (Self%& Type) (PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (pre%self! Poly) (self! Poly) (item_offset! Poly) (old_head_node_offset! Poly) (new_head_node_offset! Poly) (trim_length! Poly) (new_item! Poly) (perm! Poly) (result! Poly)) (! (= (ens%lib!kv.durable.durableimpl_v.DurableKvStore.trim_list_and_update_item. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self! self! item_offset! old_head_node_offset! new_head_node_offset! trim_length! new_item! perm! result!) (and (has_type result! (TYPE%core!result.Result. $ TYPE%tuple%0. $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) (has_type self! Self%&) (%B (lib!kv.durable.durableimpl_v.DurableKvStore.valid.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& self!)) (and (and (is-core!result.Result./Ok_ (%Poly%core!result.Result. result!)) (is-tuple%0./tuple%0_ (%Poly%tuple%0. (core!result.Result./Ok/0 (%Poly%core!result.Result. result!))))) (let ((old_record$ (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. (vstd!map.impl&%0.index.? $ INT $ (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. K&. K& I&. I& L&. L&) (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/contents (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. (lib!kv.durable.durableimpl_v.DurableKvStore.view.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self!))) item_offset!)))) (let ((new_record$ (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. (vstd!map.impl&%0.index.? $ INT $ (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. K&. K& I&. I& L&. L&) (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/contents (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. (lib!kv.durable.durableimpl_v.DurableKvStore.view.? Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& self!))) item_offset!)))) (and (and (= (lib!kv.durable.durablespec_t.impl&%1.item.? K&. K& I&. I& L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. new_record$)) new_item!) (= (lib!kv.durable.durablespec_t.DurableKvStoreList./DurableKvStoreList/list (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (lib!kv.durable.durablespec_t.impl&%1.list.? K&. K& I&. I& L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. new_record$))))) (vstd!seq.Seq.subrange.? L&. L& (lib!kv.durable.durablespec_t.DurableKvStoreList./DurableKvStoreList/list (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (lib!kv.durable.durablespec_t.impl&%1.list.? K&. K& I&. I& L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. old_record$))))) trim_length! (I (lib!kv.durable.durablespec_t.impl&%0.len.? L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (lib!kv.durable.durablespec_t.impl&%1.list.? K&. K& I&. I& L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. old_record$)))))))) (forall ((i$ Poly)) (! (=> (has_type i$ INT) (=> (let ((tmp%%$ (%I (vstd!map.impl&%0.index.? $ INT $ INT (Poly%vstd!map.Map<int./int.>. (lib!kv.durable.durablespec_t.DurableKvStoreList./DurableKvStoreList/node_offset_map (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (lib!kv.durable.durablespec_t.impl&%1.list.? K&. K& I&. I& L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. old_record$)))))) i$)))) (and (<= 0 tmp%%$) (< tmp%%$ (%I trim_length!)))) (is-core!option.Option./None_ (lib!kv.durable.durablespec_t.impl&%0.offset_index.? L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (lib!kv.durable.durablespec_t.impl&%1.list.? K&. K& I&. I& L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. new_record$))) i$)))) :pattern ((lib!kv.durable.durablespec_t.impl&%0.offset_index.? L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (lib!kv.durable.durablespec_t.impl&%1.list.? K&. K& I&. I& L&. L& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. new_record$))) i$)) )))))))) :pattern ((ens%lib!kv.durable.durableimpl_v.DurableKvStore.trim_list_and_update_item. Self%&. Self%& PM&. PM& K&. K& I&. I& L&. L& E&. E& pre%self! self! item_offset! old_head_node_offset! new_head_node_offset! trim_length! new_item! perm! result!)) )))
(set-info :comment ";; Function-Axioms lib::kv::volatile::volatileimpl_v::VolatileKvIndex::view")
(assert (forall ((Self%&. Dcr) (Self%& Type) (K&. Dcr) (K& Type) (E&. Dcr) (E& Type) (self! Poly)) (! (=> (has_type self! Self%&) (has_type (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? Self%&. Self%& K&. K& E&. E& self!) (TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. K&. K&))) :pattern ((lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? Self%&. Self%& K&. K& E&. E& self!)) )))
(set-info :comment ";; Function-Axioms lib::kv::volatile::volatileimpl_v::VolatileKvIndex::valid")
(assert (forall ((Self%&. Dcr) (Self%& Type) (K&. Dcr) (K& Type) (E&. Dcr) (E& Type) (self! Poly)) (! (=> (has_type self! Self%&) (has_type (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.valid.? Self%&. Self%& K&. K& E&. E& self!) BOOL)) :pattern ((lib!kv.volatile.volatileimpl_v.VolatileKvIndex.valid.? Self%&. Self%& K&. K& E&. E& self!)) )))
(set-info :comment ";; Function-Axioms lib::kv::volatile::volatilespec_t::VolatileKvIndexView::empty")
(assert (fuel_bool_default fuel%lib!kv.volatile.volatilespec_t.impl&%1.empty.))
(assert (=> (fuel_bool fuel%lib!kv.volatile.volatilespec_t.impl&%1.empty.) (forall ((K&. Dcr) (K& Type) (self! Poly)) (! (= (lib!kv.volatile.volatilespec_t.impl&%1.empty.? K&. K& self!) (and (vstd!set_lib.impl&%0.is_empty.? K&. K& (vstd!map.impl&%0.dom.? K&. K& $ TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView/contents (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. self!)))) (vstd!set.impl&%0.finite.? K&. K& (vstd!map.impl&%0.dom.? K&. K& $ TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView/contents (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. self!)))))) :pattern ((lib!kv.volatile.volatilespec_t.impl&%1.empty.? K&. K& self!)) ))))
(set-info :comment ";; Function-Specs lib::kv::volatile::volatileimpl_v::VolatileKvIndex::new")
(declare-fun ens%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.new. (Dcr Type Dcr Type Dcr Type Poly Poly Poly) Bool)
(assert (forall ((Self%&. Dcr) (Self%& Type) (K&. Dcr) (K& Type) (E&. Dcr) (E& Type) (kvstore_id! Poly) (max_keys! Poly) (result! Poly)) (! (= (ens%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.new. Self%&. Self%& K&. K& E&. E& kvstore_id! max_keys! result!) (and (has_type result! (TYPE%core!result.Result. Self%&. Self%& $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) (=> (is-core!result.Result./Ok_ (%Poly%core!result.Result. result!)) (let ((volatile_index$ (core!result.Result./Ok/0 (%Poly%core!result.Result. result!)))) (and (lib!kv.volatile.volatilespec_t.impl&%1.empty.? K&. K& (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? Self%&. Self%& K&. K& E&. E& volatile_index$)) (%B (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.valid.? Self%&. Self%& K&. K& E&. E& volatile_index$))))))) :pattern ((ens%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.new. Self%&. Self%& K&. K& E&. E& kvstore_id! max_keys! result!)) )))
(set-info :comment ";; Function-Axioms lib::kv::volatile::volatilespec_t::VolatileKvIndexView::spec_index")
(assert (fuel_bool_default fuel%lib!kv.volatile.volatilespec_t.impl&%1.spec_index.))
(assert (=> (fuel_bool fuel%lib!kv.volatile.volatilespec_t.impl&%1.spec_index.) (forall ((K&. Dcr) (K& Type) (self! Poly) (key! Poly)) (! (= (lib!kv.volatile.volatilespec_t.impl&%1.spec_index.? K&. K& self! key!) (ite (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& $ TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView/contents (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. self!))) key!) (core!option.Option./Some (vstd!map.impl&%0.index.? K&. K& $ TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView/contents (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. self!)) key!)) core!option.Option./None)) :pattern ((lib!kv.volatile.volatilespec_t.impl&%1.spec_index.? K&. K& self! key!)) ))))
(assert (forall ((K&. Dcr) (K& Type) (self! Poly) (key! Poly)) (! (=> (and (has_type self! (TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. K&. K&)) (has_type key! K&)) (has_type (Poly%core!option.Option. (lib!kv.volatile.volatilespec_t.impl&%1.spec_index.? K&. K& self! key!)) (TYPE%core!option.Option. $ TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry.))) :pattern ((lib!kv.volatile.volatilespec_t.impl&%1.spec_index.? K&. K& self! key!)) )))
(set-info :comment ";; Function-Axioms lib::kv::volatile::volatilespec_t::VolatileKvIndexView::insert_item_offset")
(assert (fuel_bool_default fuel%lib!kv.volatile.volatilespec_t.impl&%1.insert_item_offset.))
(assert (=> (fuel_bool fuel%lib!kv.volatile.volatilespec_t.impl&%1.insert_item_offset.) (forall ((K&. Dcr) (K& Type) (self! Poly) (key! Poly) (item_offset! Poly)) (! (= (lib!kv.volatile.volatilespec_t.impl&%1.insert_item_offset.? K&. K& self! key! item_offset!) (lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView (vstd!map.impl&%0.insert.? K&. K& $ TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView/contents (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. self!)) key! (Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry (%I item_offset!) (%Poly%vstd!map.Map<tuple%2<int./int.>./lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.>. (vstd!map.impl&%0.empty.? $ (TYPE%tuple%2. $ INT $ INT) $ TYPE%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.)) (%I (I 0))))) (%I (I (lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView/list_entries_per_node (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. self!)))))) :pattern ((lib!kv.volatile.volatilespec_t.impl&%1.insert_item_offset.? K&. K& self! key! item_offset!)) ))))
(assert (forall ((K&. Dcr) (K& Type) (self! Poly) (key! Poly) (item_offset! Poly)) (! (=> (and (has_type self! (TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. K&. K&)) (has_type key! K&) (has_type item_offset! INT)) (has_type (Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. (lib!kv.volatile.volatilespec_t.impl&%1.insert_item_offset.? K&. K& self! key! item_offset!)) (TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. K&. K&))) :pattern ((lib!kv.volatile.volatilespec_t.impl&%1.insert_item_offset.? K&. K& self! key! item_offset!)) )))
(set-info :comment ";; Function-Axioms lib::kv::volatile::volatilespec_t::VolatileKvIndexView::len")
(assert (fuel_bool_default fuel%lib!kv.volatile.volatilespec_t.impl&%1.len.))
(assert (=> (fuel_bool fuel%lib!kv.volatile.volatilespec_t.impl&%1.len.) (forall ((K&. Dcr) (K& Type) (self! Poly)) (! (= (lib!kv.volatile.volatilespec_t.impl&%1.len.? K&. K& self!) (vstd!map.impl&%0.len.? K&. K& $ TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView/contents (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. self!)))) :pattern ((lib!kv.volatile.volatilespec_t.impl&%1.len.? K&. K& self!)) ))))
(set-info :comment ";; Function-Specs lib::kv::volatile::volatileimpl_v::VolatileKvIndex::insert_item_offset")
(declare-fun req%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.insert_item_offset. (Dcr Type Dcr Type Dcr Type Poly Poly Poly) Bool)
(declare-const %%global_location_label%%15 Bool)
(declare-const %%global_location_label%%16 Bool)
(assert (forall ((Self%&. Dcr) (Self%& Type) (K&. Dcr) (K& Type) (E&. Dcr) (E& Type) (pre%self! Poly) (key! Poly) (offset! Poly)) (! (= (req%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.insert_item_offset. Self%&. Self%& K&. K& E&. E& pre%self! key! offset!) (and (=> %%global_location_label%%15 (%B (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.valid.? Self%&. Self%& K&. K& E&. E& pre%self!))) (=> %%global_location_label%%16 (is-core!option.Option./None_ (lib!kv.volatile.volatilespec_t.impl&%1.spec_index.? K&. K& (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? Self%&. Self%& K&. K& E&. E& pre%self!) key!))))) :pattern ((req%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.insert_item_offset. Self%&. Self%& K&. K& E&. E& pre%self! key! offset!)) )))
(declare-fun ens%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.insert_item_offset. (Dcr Type Dcr Type Dcr Type Poly Poly Poly Poly Poly) Bool)
(assert (forall ((Self%&. Dcr) (Self%& Type) (K&. Dcr) (K& Type) (E&. Dcr) (E& Type) (pre%self! Poly) (self! Poly) (key! Poly) (offset! Poly) (result! Poly)) (! (= (ens%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.insert_item_offset. Self%&. Self%& K&. K& E&. E& pre%self! self! key! offset! result!) (and (has_type result! (TYPE%core!result.Result. $ TYPE%tuple%0. $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) (has_type self! Self%&) (%B (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.valid.? Self%&. Self%& K&. K& E&. E& self!)) (and (and (is-core!result.Result./Ok_ (%Poly%core!result.Result. result!)) (is-tuple%0./tuple%0_ (%Poly%tuple%0. (core!result.Result./Ok/0 (%Poly%core!result.Result. result!))))) (and (= (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? Self%&. Self%& K&. K& E&. E& self!)) (lib!kv.volatile.volatilespec_t.impl&%1.insert_item_offset.? K&. K& (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? Self%&. Self%& K&. K& E&. E& pre%self!) key! offset!)) (= (lib!kv.volatile.volatilespec_t.impl&%1.len.? K&. K& (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? Self%&. Self%& K&. K& E&. E& self!)) (Add (lib!kv.volatile.volatilespec_t.impl&%1.len.? K&. K& (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? Self%&. Self%& K&. K& E&. E& pre%self!)) 1)))))) :pattern ((ens%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.insert_item_offset. Self%&. Self%& K&. K& E&. E& pre%self! self! key! offset! result!)) )))
(set-info :comment ";; Function-Axioms lib::kv::volatile::volatilespec_t::VolatileKvIndexView::contains_key")
(assert (fuel_bool_default fuel%lib!kv.volatile.volatilespec_t.impl&%1.contains_key.))
(assert (=> (fuel_bool fuel%lib!kv.volatile.volatilespec_t.impl&%1.contains_key.) (forall ((K&. Dcr) (K& Type) (self! Poly) (key! Poly)) (! (= (lib!kv.volatile.volatilespec_t.impl&%1.contains_key.? K&. K& self! key!) (is-core!option.Option./Some_ (lib!kv.volatile.volatilespec_t.impl&%1.spec_index.? K&. K& self! key!))) :pattern ((lib!kv.volatile.volatilespec_t.impl&%1.contains_key.? K&. K& self! key!)) ))))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((K&. Dcr) (K& Type) (E&. Dcr) (E& Type)) (! (=> (and (tr_bound%core!fmt.Debug. K&. K&) (tr_bound%core!fmt.Debug. E&. E&) (tr_bound%core!fmt.Debug. K&. K&) (tr_bound%core!fmt.Debug. E&. E&)) (tr_bound%core!fmt.Debug. $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) :pattern ((tr_bound%core!fmt.Debug. $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) )))
(set-info :comment ";; Function-Axioms vstd::std_specs::result::ResultAdditionalSpecFns::is_Ok")
(assert (forall ((Self%&. Dcr) (Self%& Type) (T&. Dcr) (T& Type) (E&. Dcr) (E& Type) (self! Poly)) (! (=> (has_type self! Self%&) (has_type (vstd!std_specs.result.ResultAdditionalSpecFns.is_Ok.? Self%&. Self%& T&. T& E&. E& self!) BOOL)) :pattern ((vstd!std_specs.result.ResultAdditionalSpecFns.is_Ok.? Self%&. Self%& T&. T& E&. E& self!)) )))
(set-info :comment ";; Function-Axioms vstd::std_specs::result::ResultAdditionalSpecFns::get_Ok_0")
(assert (forall ((Self%&. Dcr) (Self%& Type) (T&. Dcr) (T& Type) (E&. Dcr) (E& Type) (self! Poly)) (! (=> (has_type self! Self%&) (has_type (vstd!std_specs.result.ResultAdditionalSpecFns.get_Ok_0.? Self%&. Self%& T&. T& E&. E& self!) T&)) :pattern ((vstd!std_specs.result.ResultAdditionalSpecFns.get_Ok_0.? Self%&. Self%& T&. T& E&. E& self!)) )))
(set-info :comment ";; Function-Axioms vstd::std_specs::result::impl&%0::is_Ok")
(assert (fuel_bool_default fuel%vstd!std_specs.result.impl&%0.is_Ok.))
(assert (=> (fuel_bool fuel%vstd!std_specs.result.impl&%0.is_Ok.) (forall ((T&. Dcr) (T& Type) (E&. Dcr) (E& Type) (self! Poly)) (! (= (vstd!std_specs.result.ResultAdditionalSpecFns.is_Ok.? $ (TYPE%core!result.Result. T&. T& E&. E&) T&. T& E&. E& self!) (B (is-core!result.Result./Ok_ (%Poly%core!result.Result. self!)))) :pattern ((vstd!std_specs.result.ResultAdditionalSpecFns.is_Ok.? $ (TYPE%core!result.Result. T&. T& E&. E&) T&. T& E&. E& self!)) ))))
(set-info :comment ";; Function-Axioms vstd::std_specs::result::impl&%0::get_Ok_0")
(assert (fuel_bool_default fuel%vstd!std_specs.result.impl&%0.get_Ok_0.))
(assert (=> (fuel_bool fuel%vstd!std_specs.result.impl&%0.get_Ok_0.) (forall ((T&. Dcr) (T& Type) (E&. Dcr) (E& Type) (self! Poly)) (! (= (vstd!std_specs.result.ResultAdditionalSpecFns.get_Ok_0.? $ (TYPE%core!result.Result. T&. T& E&. E&) T&. T& E&. E& self!) (core!result.Result./Ok/0 (%Poly%core!result.Result. self!))) :pattern ((vstd!std_specs.result.ResultAdditionalSpecFns.get_Ok_0.? $ (TYPE%core!result.Result. T&. T& E&. E&) T&. T& E&. E& self!)) ))))
(set-info :comment ";; Function-Specs vstd::std_specs::result::spec_unwrap")
(declare-fun req%vstd!std_specs.result.spec_unwrap. (Dcr Type Dcr Type Poly) Bool)
(declare-const %%global_location_label%%17 Bool)
(assert (forall ((T&. Dcr) (T& Type) (E&. Dcr) (E& Type) (result! Poly)) (! (= (req%vstd!std_specs.result.spec_unwrap. T&. T& E&. E& result!) (=> %%global_location_label%%17 (is-core!result.Result./Ok_ (%Poly%core!result.Result. result!)))) :pattern ((req%vstd!std_specs.result.spec_unwrap. T&. T& E&. E& result!)) )))
(set-info :comment ";; Function-Axioms vstd::std_specs::result::spec_unwrap")
(assert (fuel_bool_default fuel%vstd!std_specs.result.spec_unwrap.))
(assert (=> (fuel_bool fuel%vstd!std_specs.result.spec_unwrap.) (forall ((T&. Dcr) (T& Type) (E&. Dcr) (E& Type) (result! Poly)) (! (= (vstd!std_specs.result.spec_unwrap.? T&. T& E&. E& result!) (core!result.Result./Ok/0 (%Poly%core!result.Result. result!))) :pattern ((vstd!std_specs.result.spec_unwrap.? T&. T& E&. E& result!)) ))))
(assert (forall ((T&. Dcr) (T& Type) (E&. Dcr) (E& Type) (result! Poly)) (! (=> (has_type result! (TYPE%core!result.Result. T&. T& E&. E&)) (has_type (vstd!std_specs.result.spec_unwrap.? T&. T& E&. E& result!) T&)) :pattern ((vstd!std_specs.result.spec_unwrap.? T&. T& E&. E& result!)) )))
(set-info :comment ";; Function-Axioms lib::kv::volatile::volatilespec_t::VolatileKvIndexView::get_node_view")
(assert (fuel_bool_default fuel%lib!kv.volatile.volatilespec_t.impl&%1.get_node_view.))
(declare-fun %%choose%%0 (Type Int Int Dcr Type Poly Dcr Type Poly) Poly)
(assert (forall ((%%hole%%0 Type) (%%hole%%1 Int) (%%hole%%2 Int) (%%hole%%3 Dcr) (%%hole%%4 Type) (%%hole%%5 Poly) (%%hole%%6 Dcr) (%%hole%%7 Type) (%%hole%%8 Poly)) (! (=> (exists ((k$ Poly)) (! (and (has_type k$ %%hole%%0) (let ((i$ (%I (tuple%2./tuple%2/0 (%Poly%tuple%2. k$))))) (let ((j$ (%I (tuple%2./tuple%2/1 (%Poly%tuple%2. k$))))) (and (and (<= i$ %%hole%%1) (< %%hole%%2 j$)) (vstd!set.impl&%0.contains.? %%hole%%3 %%hole%%4 %%hole%%5 k$))))) :pattern ((vstd!set.impl&%0.contains.? %%hole%%6 %%hole%%7 %%hole%%8 k$)) )) (exists ((k$ Poly)) (! (and (and (has_type k$ %%hole%%0) (let ((i$ (%I (tuple%2./tuple%2/0 (%Poly%tuple%2. k$))))) (let ((j$ (%I (tuple%2./tuple%2/1 (%Poly%tuple%2. k$))))) (and (and (<= i$ %%hole%%1) (< %%hole%%2 j$)) (vstd!set.impl&%0.contains.? %%hole%%3 %%hole%%4 %%hole%%5 k$))))) (= (%%choose%%0 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5 %%hole%%6 %%hole%%7 %%hole%%8) k$)) :pattern ((vstd!set.impl&%0.contains.? %%hole%%6 %%hole%%7 %%hole%%8 k$))))) :pattern ((%%choose%%0 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5 %%hole%%6 %%hole%%7 %%hole%%8)))))
(assert (=> (fuel_bool fuel%lib!kv.volatile.volatilespec_t.impl&%1.get_node_view.) (forall ((K&. Dcr) (K& Type) (E&. Dcr) (E& Type) (self! Poly) (key! Poly) (index! Poly)) (! (= (lib!kv.volatile.volatilespec_t.impl&%1.get_node_view.? K&. K& E&. E& self! key! index!) (ite (not (lib!kv.volatile.volatilespec_t.impl&%1.contains_key.? K&. K& self! key!)) (core!result.Result./Err (Poly%lib!kv.kvimpl_t.KvError. lib!kv.kvimpl_t.KvError./KeyNotFound)) (let ((index_entry$ (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (vstd!map.impl&%0.index.? K&. K& $ TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView/contents (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. self!)) key!)))) (ite (exists ((k$ Poly)) (! (and (has_type k$ (TYPE%tuple%2. $ INT $ INT)) (let ((i$ (%I (tuple%2./tuple%2/0 (%Poly%tuple%2. k$))))) (let ((j$ (%I (tuple%2./tuple%2/1 (%Poly%tuple%2. k$))))) (and (and (<= i$ (%I index!)) (< (%I index!) j$)) (vstd!set.impl&%0.contains.? $ (TYPE%tuple%2. $ INT $ INT) (vstd!map.impl&%0.dom.? $ (TYPE%tuple%2. $ INT $ INT) $ TYPE%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. (Poly%vstd!map.Map<tuple%2<int./int.>./lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.>. (lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry/list_node_offsets (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. index_entry$))))) k$))))) :pattern ((vstd!set.impl&%0.contains.? $ (TYPE%tuple%2. $ INT $ INT) (vstd!map.impl&%0.dom.? $ (TYPE%tuple%2. $ INT $ INT) $ TYPE%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. (Poly%vstd!map.Map<tuple%2<int./int.>./lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.>. (lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry/list_node_offsets (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. index_entry$))))) k$)) )) (let ((range$ (%Poly%tuple%2. (as_type (%%choose%%0 (TYPE%tuple%2. $ INT $ INT) (%I index!) (%I index!) $ (TYPE%tuple%2. $ INT $ INT) (vstd!map.impl&%0.dom.? $ (TYPE%tuple%2. $ INT $ INT) $ TYPE%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. (Poly%vstd!map.Map<tuple%2<int./int.>./lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.>. (lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry/list_node_offsets (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. index_entry$))))) $ (TYPE%tuple%2. $ INT $ INT) (vstd!map.impl&%0.dom.? $ (TYPE%tuple%2. $ INT $ INT) $ TYPE%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. (Poly%vstd!map.Map<tuple%2<int./int.>./lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.>. (lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry/list_node_offsets (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. index_entry$)))))) (TYPE%tuple%2. $ INT $ INT))))) (core!result.Result./Ok (Poly%tuple%2. (tuple%2./tuple%2 (Poly%tuple%2. range$) (vstd!map.impl&%0.index.? $ (TYPE%tuple%2. $ INT $ INT) $ TYPE%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. (Poly%vstd!map.Map<tuple%2<int./int.>./lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.>. (lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry/list_node_offsets (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. index_entry$)))) (Poly%tuple%2. range$)))))) (core!result.Result./Err (Poly%lib!kv.kvimpl_t.KvError. lib!kv.kvimpl_t.KvError./IndexOutOfRange)))))) :pattern ((lib!kv.volatile.volatilespec_t.impl&%1.get_node_view.? K&. K& E&. E& self! key! index!)) ))))
(assert (forall ((K&. Dcr) (K& Type) (E&. Dcr) (E& Type) (self! Poly) (key! Poly) (index! Poly)) (! (=> (and (has_type self! (TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. K&. K&)) (has_type key! K&) (has_type index! INT)) (has_type (Poly%core!result.Result. (lib!kv.volatile.volatilespec_t.impl&%1.get_node_view.? K&. K& E&. E& self! key! index!)) (TYPE%core!result.Result. $ (TYPE%tuple%2. $ (TYPE%tuple%2. $ INT $ INT) $ TYPE%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.) $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&)))) :pattern ((lib!kv.volatile.volatilespec_t.impl&%1.get_node_view.? K&. K& E&. E& self! key! index!)) )))
(set-info :comment ";; Function-Specs lib::kv::volatile::volatilespec_t::VolatileKvIndexView::list_len")
(declare-fun req%lib!kv.volatile.volatilespec_t.impl&%1.list_len. (Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%18 Bool)
(assert (forall ((K&. Dcr) (K& Type) (self! Poly) (key! Poly)) (! (= (req%lib!kv.volatile.volatilespec_t.impl&%1.list_len. K&. K& self! key!) (=> %%global_location_label%%18 (lib!kv.volatile.volatilespec_t.impl&%1.contains_key.? K&. K& self! key!))) :pattern ((req%lib!kv.volatile.volatilespec_t.impl&%1.list_len. K&. K& self! key!)) )))
(set-info :comment ";; Function-Axioms lib::kv::volatile::volatilespec_t::VolatileKvIndexView::list_len")
(assert (fuel_bool_default fuel%lib!kv.volatile.volatilespec_t.impl&%1.list_len.))
(assert (=> (fuel_bool fuel%lib!kv.volatile.volatilespec_t.impl&%1.list_len.) (forall ((K&. Dcr) (K& Type) (self! Poly) (key! Poly)) (! (= (lib!kv.volatile.volatilespec_t.impl&%1.list_len.? K&. K& self! key!) (lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry/list_len (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. (lib!kv.volatile.volatilespec_t.impl&%1.spec_index.? K&. K& self! key!))))))) :pattern ((lib!kv.volatile.volatilespec_t.impl&%1.list_len.? K&. K& self! key!)) ))))
(set-info :comment ";; Function-Axioms lib::kv::volatile::volatilespec_t::ListNodeIndexEntry::has_free_space")
(assert (fuel_bool_default fuel%lib!kv.volatile.volatilespec_t.impl&%0.has_free_space.))
(assert (=> (fuel_bool fuel%lib!kv.volatile.volatilespec_t.impl&%0.has_free_space.) (forall ((self! Poly)) (! (= (lib!kv.volatile.volatilespec_t.impl&%0.has_free_space.? self!) (> (lib!kv.volatile.volatilespec_t.ListNodeIndexEntry./ListNodeIndexEntry/free_entries (%Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. self!)) 0)) :pattern ((lib!kv.volatile.volatilespec_t.impl&%0.has_free_space.? self!)) ))))
(set-info :comment ";; Function-Axioms lib::kv::volatile::volatilespec_t::ListNodeIndexEntry::append_entry")
(assert (fuel_bool_default fuel%lib!kv.volatile.volatilespec_t.impl&%0.append_entry.))
(assert (=> (fuel_bool fuel%lib!kv.volatile.volatilespec_t.impl&%0.append_entry.) (forall ((K&. Dcr) (K& Type) (E&. Dcr) (E& Type) (self! Poly)) (! (= (lib!kv.volatile.volatilespec_t.impl&%0.append_entry.? K&. K& E&. E& self!) (ite (<= (lib!kv.volatile.volatilespec_t.ListNodeIndexEntry./ListNodeIndexEntry/free_entries (%Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. self!)) 0) (core!result.Result./Err (Poly%lib!kv.kvimpl_t.KvError. lib!kv.kvimpl_t.KvError./OutOfSpace)) (core!result.Result./Ok (Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. (lib!kv.volatile.volatilespec_t.ListNodeIndexEntry./ListNodeIndexEntry (%I (I (lib!kv.volatile.volatilespec_t.ListNodeIndexEntry./ListNodeIndexEntry/start_index (%Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. self!)))) (%I (I (lib!kv.volatile.volatilespec_t.ListNodeIndexEntry./ListNodeIndexEntry/live_index (%Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. self!)))) (%I (I (lib!kv.volatile.volatilespec_t.ListNodeIndexEntry./ListNodeIndexEntry/physical_offset (%Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. self!)))) (%I (I (Sub (lib!kv.volatile.volatilespec_t.ListNodeIndexEntry./ListNodeIndexEntry/free_entries (%Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. self!)) 1)))))))) :pattern ((lib!kv.volatile.volatilespec_t.impl&%0.append_entry.? K&. K& E&. E& self!)) ))))
(assert (forall ((K&. Dcr) (K& Type) (E&. Dcr) (E& Type) (self! Poly)) (! (=> (has_type self! TYPE%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.) (has_type (Poly%core!result.Result. (lib!kv.volatile.volatilespec_t.impl&%0.append_entry.? K&. K& E&. E& self!)) (TYPE%core!result.Result. $ TYPE%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&)))) :pattern ((lib!kv.volatile.volatilespec_t.impl&%0.append_entry.? K&. K& E&. E& self!)) )))
(set-info :comment ";; Function-Axioms lib::kv::volatile::volatilespec_t::VolatileKvIndexView::append_to_list")
(assert (fuel_bool_default fuel%lib!kv.volatile.volatilespec_t.impl&%1.append_to_list.))
(assert (=> (fuel_bool fuel%lib!kv.volatile.volatilespec_t.impl&%1.append_to_list.) (forall ((K&. Dcr) (K& Type) (E&. Dcr) (E& Type) (self! Poly) (key! Poly)) (! (= (lib!kv.volatile.volatilespec_t.impl&%1.append_to_list.? K&. K& E&. E& self! key!) (ite (not (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& $ TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView/contents (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. self!))) key!)) (core!result.Result./Err (Poly%lib!kv.kvimpl_t.KvError. lib!kv.kvimpl_t.KvError./KeyNotFound)) (let ((old_index_entry$ (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (vstd!map.impl&%0.index.? K&. K& $ TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView/contents (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. self!)) key!)))) (let ((tmp%%$ (lib!kv.volatile.volatilespec_t.impl&%1.get_node_view.? K&. K& E&. E& self! key! (I (Sub (lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry/list_len (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. old_index_entry$))) 1))))) (ite (and (is-core!result.Result./Ok_ tmp%%$) (is-tuple%2./tuple%2_ (%Poly%tuple%2. (core!result.Result./Ok/0 (%Poly%core!result.Result. (Poly%core!result.Result. tmp%%$)))))) (let ((range$ (%Poly%tuple%2. (tuple%2./tuple%2/0 (%Poly%tuple%2. (core!result.Result./Ok/0 (%Poly%core!result.Result. (Poly%core!result.Result. tmp%%$)))))))) (let ((old_node_view$ (%Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. (tuple%2./tuple%2/1 (%Poly%tuple%2. (core!result.Result./Ok/0 (%Poly%core!result.Result. (Poly%core!result.Result. tmp%%$)))))))) (let ((new_node_view$ (lib!kv.volatile.volatilespec_t.impl&%0.append_entry.? K&. K& E&. E& (Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. old_node_view$)))) (ite (is-core!result.Result./Ok_ new_node_view$) (let ((new_node_view$1 (%Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. (core!result.Result./Ok/0 (%Poly%core!result.Result. (Poly%core!result.Result. new_node_view$)))))) (let ((new_index_entry$ (lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry (%I (I (lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry/item_offset (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. old_index_entry$))))) (%Poly%vstd!map.Map<tuple%2<int./int.>./lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.>. (vstd!map.impl&%0.insert.? $ (TYPE%tuple%2. $ INT $ INT) $ TYPE%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. (Poly%vstd!map.Map<tuple%2<int./int.>./lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.>. (lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry/list_node_offsets (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. old_index_entry$)))) (Poly%tuple%2. range$) (Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. new_node_view$1))) (%I (I (Add (lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry/list_len (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. old_index_entry$))) 1)))))) (core!result.Result./Ok (Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. (lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView (vstd!map.impl&%0.insert.? K&. K& $ TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView/contents (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. self!)) key! (Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. new_index_entry$)) (%I (I (lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView/list_entries_per_node (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. self!))))))))) (let ((e$ (%Poly%lib!kv.kvimpl_t.KvError. (core!result.Result./Err/0 (%Poly%core!result.Result. (Poly%core!result.Result. new_node_view$)))))) (core!result.Result./Err (Poly%lib!kv.kvimpl_t.KvError. e$))))))) (let ((e$ (%Poly%lib!kv.kvimpl_t.KvError. (core!result.Result./Err/0 (%Poly%core!result.Result. (Poly%core!result.Result. tmp%%$)))))) (core!result.Result./Err (Poly%lib!kv.kvimpl_t.KvError. e$)))))))) :pattern ((lib!kv.volatile.volatilespec_t.impl&%1.append_to_list.? K&. K& E&. E& self! key!)) ))))
(assert (forall ((K&. Dcr) (K& Type) (E&. Dcr) (E& Type) (self! Poly) (key! Poly)) (! (=> (and (has_type self! (TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. K&. K&)) (has_type key! K&)) (has_type (Poly%core!result.Result. (lib!kv.volatile.volatilespec_t.impl&%1.append_to_list.? K&. K& E&. E& self! key!)) (TYPE%core!result.Result. $ (TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. K&. K&) $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&)))) :pattern ((lib!kv.volatile.volatilespec_t.impl&%1.append_to_list.? K&. K& E&. E& self! key!)) )))
(set-info :comment ";; Function-Specs lib::kv::volatile::volatileimpl_v::VolatileKvIndex::append_to_list")
(declare-fun req%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.append_to_list. (Dcr Type Dcr Type Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%19 Bool)
(declare-const %%global_location_label%%20 Bool)
(declare-const %%global_location_label%%21 Bool)
(assert (forall ((Self%&. Dcr) (Self%& Type) (K&. Dcr) (K& Type) (E&. Dcr) (E& Type) (pre%self! Poly) (key! Poly)) (! (= (req%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.append_to_list. Self%&. Self%& K&. K& E&. E& pre%self! key!) (and (=> %%global_location_label%%19 (%B (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.valid.? Self%&. Self%& K&. K& E&. E& pre%self!))) (=> %%global_location_label%%20 (lib!kv.volatile.volatilespec_t.impl&%1.contains_key.? K&. K& (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? Self%&. Self%& K&. K& E&. E& pre%self!) key!)) (=> %%global_location_label%%21 (let ((tmp%%$ (%Poly%tuple%2. (core!result.Result./Ok/0 (%Poly%core!result.Result. (Poly%core!result.Result. (lib!kv.volatile.volatilespec_t.impl&%1.get_node_view.? K&. K& E&. E& (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? Self%&. Self%& K&. K& E&. E& pre%self!) key! (I (Sub (lib!kv.volatile.volatilespec_t.impl&%1.list_len.? K&. K& (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? Self%&. Self%& K&. K& E&. E& pre%self!) key!) 1))))))))) (let ((node_view$ (%Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$)))))) (lib!kv.volatile.volatilespec_t.impl&%0.has_free_space.? (Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. node_view$))))))) :pattern ((req%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.append_to_list. Self%&. Self%& K&. K& E&. E& pre%self! key!)) )))
(declare-fun ens%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.append_to_list. (Dcr Type Dcr Type Dcr Type Poly Poly Poly Poly) Bool)
(assert (forall ((Self%&. Dcr) (Self%& Type) (K&. Dcr) (K& Type) (E&. Dcr) (E& Type) (pre%self! Poly) (self! Poly) (key! Poly) (result! Poly)) (! (= (ens%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.append_to_list. Self%&. Self%& K&. K& E&. E& pre%self! self! key! result!) (and (has_type result! (TYPE%core!result.Result. $ TYPE%tuple%0. $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) (has_type self! Self%&) (%B (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.valid.? Self%&. Self%& K&. K& E&. E& self!)) (let ((spec_result$ (lib!kv.volatile.volatilespec_t.impl&%1.append_to_list.? K&. K& E&. E& (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? Self%&. Self%& K&. K& E&. E& pre%self!) key!))) (let ((tmp%%$ (tuple%2./tuple%2 result! (Poly%core!result.Result. spec_result$)))) (ite (and (and (is-tuple%2./tuple%2_ tmp%%$) (and (is-core!result.Result./Ok_ (%Poly%core!result.Result. (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))) (is-tuple%0./tuple%0_ (%Poly%tuple%0. (core!result.Result./Ok/0 (%Poly%core!result.Result. (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))))))) (is-core!result.Result./Ok_ (%Poly%core!result.Result. (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$)))))) (let ((new_state$ (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. (core!result.Result./Ok/0 (%Poly%core!result.Result. (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$)))))))) (= (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? Self%&. Self%& K&. K& E&. E& self!)) new_state$)) (and (not (and (and (is-tuple%2./tuple%2_ tmp%%$) (and (is-core!result.Result./Ok_ (%Poly%core!result.Result. (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))) (is-tuple%0./tuple%0_ (%Poly%tuple%0. (core!result.Result./Ok/0 (%Poly%core!result.Result. (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))))))) (is-core!result.Result./Err_ (%Poly%core!result.Result. (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))))) (and (and (and (is-tuple%2./tuple%2_ tmp%%$) (and (is-core!result.Result./Err_ (%Poly%core!result.Result. (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))) (is-lib!kv.kvimpl_t.KvError./KeyNotFound_ (%Poly%lib!kv.kvimpl_t.KvError. (core!result.Result./Err/0 (%Poly%core!result.Result. (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))))))) (and (is-core!result.Result./Err_ (%Poly%core!result.Result. (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))) (is-lib!kv.kvimpl_t.KvError./KeyNotFound_ (%Poly%lib!kv.kvimpl_t.KvError. (core!result.Result./Err/0 (%Poly%core!result.Result. (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))))))) (and (not (lib!kv.volatile.volatilespec_t.impl&%1.contains_key.? K&. K& (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? Self%&. Self%& K&. K& E&. E& pre%self!) key!)) (= (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? Self%&. Self%& K&. K& E&. E& self!) (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? Self%&. Self%& K&. K& E&. E& pre%self!)))))))))) :pattern ((ens%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.append_to_list. Self%&. Self%& K&. K& E&. E& pre%self! self! key! result!)) )))
(set-info :comment ";; Function-Specs lib::kv::volatile::volatileimpl_v::VolatileKvIndex::get")
(declare-fun req%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.get. (Dcr Type Dcr Type Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%22 Bool)
(assert (forall ((Self%&. Dcr) (Self%& Type) (K&. Dcr) (K& Type) (E&. Dcr) (E& Type) (self! Poly) (key! Poly)) (! (= (req%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.get. Self%&. Self%& K&. K& E&. E& self! key!) (=> %%global_location_label%%22 (%B (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.valid.? Self%&. Self%& K&. K& E&. E& self!)))) :pattern ((req%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.get. Self%&. Self%& K&. K& E&. E& self! key!)) )))
(declare-fun ens%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.get. (Dcr Type Dcr Type Dcr Type Poly Poly Poly) Bool)
(assert (forall ((Self%&. Dcr) (Self%& Type) (K&. Dcr) (K& Type) (E&. Dcr) (E& Type) (self! Poly) (key! Poly) (result! Poly)) (! (= (ens%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.get. Self%&. Self%& K&. K& E&. E& self! key! result!) (and (has_type result! (TYPE%core!option.Option. $ (UINT 64))) (ite (is-core!option.Option./Some_ (%Poly%core!option.Option. result!)) (let ((offset$ (%I (core!option.Option./Some/0 (%Poly%core!option.Option. result!))))) (let ((tmp%%$ (lib!kv.volatile.volatilespec_t.impl&%1.spec_index.? K&. K& (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? Self%&. Self%& K&. K& E&. E& self!) key!))) (and (is-core!option.Option./Some_ tmp%%$) (let ((val$ (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. tmp%%$)))))) (= offset$ (lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry/item_offset (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. val$)))))))) (is-core!option.Option./None_ (lib!kv.volatile.volatilespec_t.impl&%1.spec_index.? K&. K& (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? Self%&. Self%& K&. K& E&. E& self!) key!))))) :pattern ((ens%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.get. Self%&. Self%& K&. K& E&. E& self! key! result!)) )))
(set-info :comment ";; Function-Specs lib::kv::volatile::volatileimpl_v::VolatileKvIndex::get_entry_location_by_index")
(declare-fun req%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.get_entry_location_by_index. (Dcr Type Dcr Type Dcr Type Poly Poly Poly) Bool)
(declare-const %%global_location_label%%23 Bool)
(assert (forall ((Self%&. Dcr) (Self%& Type) (K&. Dcr) (K& Type) (E&. Dcr) (E& Type) (self! Poly) (key! Poly) (idx! Poly)) (! (= (req%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.get_entry_location_by_index. Self%&. Self%& K&. K& E&. E& self! key! idx!) (=> %%global_location_label%%23 (%B (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.valid.? Self%&. Self%& K&. K& E&. E& self!)))) :pattern ((req%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.get_entry_location_by_index. Self%&. Self%& K&. K& E&. E& self! key! idx!)) )))
(declare-fun ens%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.get_entry_location_by_index. (Dcr Type Dcr Type Dcr Type Poly Poly Poly Poly) Bool)
(define-fun is-lib!kv.kvimpl_t.KvError./IndexOutOfRange_ ((c lib!kv.kvimpl_t.KvError.)) Bool ((_ is lib!kv.kvimpl_t.KvError./IndexOutOfRange) c))
(assert (forall ((Self%&. Dcr) (Self%& Type) (K&. Dcr) (K& Type) (E&. Dcr) (E& Type) (self! Poly) (key! Poly) (idx! Poly) (result! Poly)) (! (= (ens%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.get_entry_location_by_index. Self%&. Self%& K&. K& E&. E& self! key! idx! result!) (and (has_type result! (TYPE%core!result.Result. $ (UINT 64) $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) (ite (is-core!result.Result./Ok_ (%Poly%core!result.Result. result!)) (let ((offset$ (%I (core!result.Result./Ok/0 (%Poly%core!result.Result. result!))))) (let ((tmp%%$ (lib!kv.volatile.volatilespec_t.impl&%1.spec_index.? K&. K& (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? Self%&. Self%& K&. K& E&. E& self!) key!))) (and (is-core!option.Option./Some_ tmp%%$) (let ((entry$ (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. tmp%%$)))))) true)))) (ite (and (is-core!result.Result./Err_ (%Poly%core!result.Result. result!)) (is-lib!kv.kvimpl_t.KvError./KeyNotFound_ (%Poly%lib!kv.kvimpl_t.KvError. (core!result.Result./Err/0 (%Poly%core!result.Result. result!))))) (not (lib!kv.volatile.volatilespec_t.impl&%1.contains_key.? K&. K& (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? Self%&. Self%& K&. K& E&. E& self!) key!)) (and (and (is-core!result.Result./Err_ (%Poly%core!result.Result. result!)) (is-lib!kv.kvimpl_t.KvError./IndexOutOfRange_ (%Poly%lib!kv.kvimpl_t.KvError. (core!result.Result./Err/0 (%Poly%core!result.Result. result!))))) (let ((tmp%%$ (lib!kv.volatile.volatilespec_t.impl&%1.spec_index.? K&. K& (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? Self%&. Self%& K&. K& E&. E& self!) key!))) (and (is-core!option.Option./Some_ tmp%%$) (let ((entry$ (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. tmp%%$)))))) (>= (%I idx!) (vstd!map.impl&%0.len.? $ (TYPE%tuple%2. $ INT $ INT) $ TYPE%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. (Poly%vstd!map.Map<tuple%2<int./int.>./lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.>. (lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry/list_node_offsets (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. entry$)))))))))))))) :pattern ((ens%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.get_entry_location_by_index. Self%&. Self%& K&. K& E&. E& self! key! idx! result!)) )))
(set-info :comment ";; Function-Axioms lib::kv::volatile::volatilespec_t::VolatileKvIndexView::get_node_offset")
(assert (fuel_bool_default fuel%lib!kv.volatile.volatilespec_t.impl&%1.get_node_offset.))
(assert (=> (fuel_bool fuel%lib!kv.volatile.volatilespec_t.impl&%1.get_node_offset.) (forall ((K&. Dcr) (K& Type) (E&. Dcr) (E& Type) (self! Poly) (key! Poly) (index! Poly)) (! (= (lib!kv.volatile.volatilespec_t.impl&%1.get_node_offset.? K&. K& E&. E& self! key! index!) (let ((tmp%%$ (lib!kv.volatile.volatilespec_t.impl&%1.get_node_view.? K&. K& E&. E& self! key! index!))) (ite (and (is-core!result.Result./Ok_ tmp%%$) (is-tuple%2./tuple%2_ (%Poly%tuple%2. (core!result.Result./Ok/0 (%Poly%core!result.Result. (Poly%core!result.Result. tmp%%$)))))) (let ((node_view$ (%Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. (tuple%2./tuple%2/1 (%Poly%tuple%2. (core!result.Result./Ok/0 (%Poly%core!result.Result. (Poly%core!result.Result. tmp%%$)))))))) (core!result.Result./Ok (I (lib!kv.volatile.volatilespec_t.ListNodeIndexEntry./ListNodeIndexEntry/physical_offset (%Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. (Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. node_view$)))))) (let ((e$ (%Poly%lib!kv.kvimpl_t.KvError. (core!result.Result./Err/0 (%Poly%core!result.Result. (Poly%core!result.Result. tmp%%$)))))) (core!result.Result./Err (Poly%lib!kv.kvimpl_t.KvError. e$)))))) :pattern ((lib!kv.volatile.volatilespec_t.impl&%1.get_node_offset.? K&. K& E&. E& self! key! index!)) ))))
(assert (forall ((K&. Dcr) (K& Type) (E&. Dcr) (E& Type) (self! Poly) (key! Poly) (index! Poly)) (! (=> (and (has_type self! (TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. K&. K&)) (has_type key! K&) (has_type index! INT)) (has_type (Poly%core!result.Result. (lib!kv.volatile.volatilespec_t.impl&%1.get_node_offset.? K&. K& E&. E& self! key! index!)) (TYPE%core!result.Result. $ INT $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&)))) :pattern ((lib!kv.volatile.volatilespec_t.impl&%1.get_node_offset.? K&. K& E&. E& self! key! index!)) )))
(set-info :comment ";; Function-Specs lib::kv::volatile::volatileimpl_v::VolatileKvIndex::get_node_offset")
(declare-fun req%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.get_node_offset. (Dcr Type Dcr Type Dcr Type Poly Poly Poly) Bool)
(declare-const %%global_location_label%%24 Bool)
(assert (forall ((Self%&. Dcr) (Self%& Type) (K&. Dcr) (K& Type) (E&. Dcr) (E& Type) (self! Poly) (key! Poly) (idx! Poly)) (! (= (req%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.get_node_offset. Self%&. Self%& K&. K& E&. E& self! key! idx!) (=> %%global_location_label%%24 (%B (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.valid.? Self%&. Self%& K&. K& E&. E& self!)))) :pattern ((req%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.get_node_offset. Self%&. Self%& K&. K& E&. E& self! key! idx!)) )))
(declare-fun ens%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.get_node_offset. (Dcr Type Dcr Type Dcr Type Poly Poly Poly Poly) Bool)
(assert (forall ((Self%&. Dcr) (Self%& Type) (K&. Dcr) (K& Type) (E&. Dcr) (E& Type) (self! Poly) (key! Poly) (idx! Poly) (result! Poly)) (! (= (ens%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.get_node_offset. Self%&. Self%& K&. K& E&. E& self! key! idx! result!) (and (has_type result! (TYPE%core!result.Result. $ (UINT 64) $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) (let ((spec_result$ (lib!kv.volatile.volatilespec_t.impl&%1.get_node_offset.? K&. K& E&. E& (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? Self%&. Self%& K&. K& E&. E& self!) key! idx!))) (let ((tmp%%$ (tuple%2./tuple%2 result! (Poly%core!result.Result. spec_result$)))) (ite (and (and (is-tuple%2./tuple%2_ tmp%%$) (is-core!result.Result./Ok_ (%Poly%core!result.Result. (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$)))))) (is-core!result.Result./Ok_ (%Poly%core!result.Result. (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$)))))) (let ((node_offset$ (%I (core!result.Result./Ok/0 (%Poly%core!result.Result. (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$)))))))) (let ((spec_offset$ (%I (core!result.Result./Ok/0 (%Poly%core!result.Result. (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$)))))))) (= node_offset$ spec_offset$))) (ite (and (and (is-tuple%2./tuple%2_ tmp%%$) (and (is-core!result.Result./Err_ (%Poly%core!result.Result. (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))) (is-lib!kv.kvimpl_t.KvError./KeyNotFound_ (%Poly%lib!kv.kvimpl_t.KvError. (core!result.Result./Err/0 (%Poly%core!result.Result. (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))))))) (and (is-core!result.Result./Err_ (%Poly%core!result.Result. (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))) (is-lib!kv.kvimpl_t.KvError./KeyNotFound_ (%Poly%lib!kv.kvimpl_t.KvError. (core!result.Result./Err/0 (%Poly%core!result.Result. (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))))))) (not (lib!kv.volatile.volatilespec_t.impl&%1.contains_key.? K&. K& (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? Self%&. Self%& K&. K& E&. E& self!) key!)) (and (and (and (is-tuple%2./tuple%2_ tmp%%$) (and (is-core!result.Result./Err_ (%Poly%core!result.Result. (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))) (is-lib!kv.kvimpl_t.KvError./IndexOutOfRange_ (%Poly%lib!kv.kvimpl_t.KvError. (core!result.Result./Err/0 (%Poly%core!result.Result. (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))))))) (and (is-core!result.Result./Err_ (%Poly%core!result.Result. (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))) (is-lib!kv.kvimpl_t.KvError./IndexOutOfRange_ (%Poly%lib!kv.kvimpl_t.KvError. (core!result.Result./Err/0 (%Poly%core!result.Result. (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))))))) (>= (%I idx!) (lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry/list_len (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. (lib!kv.volatile.volatilespec_t.impl&%1.spec_index.? K&. K& (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? Self%&. Self%& K&. K& E&. E& self!) key!)))))))))))))) :pattern ((ens%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.get_node_offset. Self%&. Self%& K&. K& E&. E& self! key! idx! result!)) )))
(set-info :comment ";; Function-Specs lib::kv::volatile::volatileimpl_v::VolatileKvIndex::remove")
(declare-fun req%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.remove. (Dcr Type Dcr Type Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%25 Bool)
(assert (forall ((Self%&. Dcr) (Self%& Type) (K&. Dcr) (K& Type) (E&. Dcr) (E& Type) (pre%self! Poly) (key! Poly)) (! (= (req%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.remove. Self%&. Self%& K&. K& E&. E& pre%self! key!) (=> %%global_location_label%%25 (%B (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.valid.? Self%&. Self%& K&. K& E&. E& pre%self!)))) :pattern ((req%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.remove. Self%&. Self%& K&. K& E&. E& pre%self! key!)) )))
(declare-fun ens%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.remove. (Dcr Type Dcr Type Dcr Type Poly Poly Poly Poly) Bool)
(assert (forall ((Self%&. Dcr) (Self%& Type) (K&. Dcr) (K& Type) (E&. Dcr) (E& Type) (pre%self! Poly) (self! Poly) (key! Poly) (result! Poly)) (! (= (ens%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.remove. Self%&. Self%& K&. K& E&. E& pre%self! self! key! result!) (and (has_type result! (TYPE%core!result.Result. $ (UINT 64) $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) (has_type self! Self%&) (%B (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.valid.? Self%&. Self%& K&. K& E&. E& self!)) (=> (is-core!result.Result./Ok_ (%Poly%core!result.Result. result!)) (let ((offset$ (%I (core!result.Result./Ok/0 (%Poly%core!result.Result. result!))))) (let ((tmp%%$ (lib!kv.volatile.volatilespec_t.impl&%1.spec_index.? K&. K& (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? Self%&. Self%& K&. K& E&. E& pre%self!) key!))) (and (is-core!option.Option./Some_ tmp%%$) (let ((entry$ (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. tmp%%$)))))) (and (= (lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry/item_offset (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. entry$))) offset$) (is-core!option.Option./None_ (lib!kv.volatile.volatilespec_t.impl&%1.spec_index.? K&. K& (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? Self%&. Self%& K&. K& E&. E& self!) key!)))))))))) :pattern ((ens%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.remove. Self%&. Self%& K&. K& E&. E& pre%self! self! key! result!)) )))
(set-info :comment ";; Function-Axioms vstd::set::impl&%0::new")
(assert (forall ((A&. Dcr) (A& Type) (F&. Dcr) (F& Type) (f! Poly)) (! (=> (has_type f! F&) (has_type (vstd!set.impl&%0.new.? A&. A& F&. F& f!) (TYPE%vstd!set.Set. A&. A&))) :pattern ((vstd!set.impl&%0.new.? A&. A& F&. F& f!)) )))
(set-info :comment ";; Function-Axioms vstd::map::impl&%0::remove")
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self! Poly) (key! Poly)) (! (=> (and (has_type self! (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type key! K&)) (has_type (vstd!map.impl&%0.remove.? K&. K& V&. V& self! key!) (TYPE%vstd!map.Map. K&. K& V&. V&))) :pattern ((vstd!map.impl&%0.remove.? K&. K& V&. V& self! key!)) )))
(set-info :comment ";; Function-Axioms vstd::set::impl&%0::mk_map")
(assert (forall ((A&. Dcr) (A& Type) (V&. Dcr) (V& Type) (F&. Dcr) (F& Type) (self! Poly) (f! Poly)) (! (=> (and (has_type self! (TYPE%vstd!set.Set. A&. A&)) (has_type f! F&)) (has_type (vstd!set.impl&%0.mk_map.? A&. A& V&. V& F&. F& self! f!) (TYPE%vstd!map.Map. A&. A& V&. V&))) :pattern ((vstd!set.impl&%0.mk_map.? A&. A& V&. V& F&. F& self! f!)) )))
(set-info :comment ";; Function-Axioms vstd::map::impl&%0::new")
(assert (fuel_bool_default fuel%vstd!map.impl&%0.new.))
(assert (=> (fuel_bool fuel%vstd!map.impl&%0.new.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (impl%2&. Dcr) (impl%2& Type) (impl%3&. Dcr) (impl%3& Type) (fk! Poly) (fv! Poly)) (! (= (vstd!map.impl&%0.new.? K&. K& V&. V& impl%2&. impl%2& impl%3&. impl%3& fk! fv!) (vstd!set.impl&%0.mk_map.? K&. K& V&. V& impl%3&. impl%3& (vstd!set.impl&%0.new.? K&. K& impl%2&. impl%2& fk!) fv!)) :pattern ((vstd!map.impl&%0.new.? K&. K& V&. V& impl%2&. impl%2& impl%3&. impl%3& fk! fv!)) ))))
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (impl%2&. Dcr) (impl%2& Type) (impl%3&. Dcr) (impl%3& Type) (fk! Poly) (fv! Poly)) (! (=> (and (has_type fk! impl%2&) (has_type fv! impl%3&)) (has_type (vstd!map.impl&%0.new.? K&. K& V&. V& impl%2&. impl%2& impl%3&. impl%3& fk! fv!) (TYPE%vstd!map.Map. K&. K& V&. V&))) :pattern ((vstd!map.impl&%0.new.? K&. K& V&. V& impl%2&. impl%2& impl%3&. impl%3& fk! fv!)) )))
(set-info :comment ";; Function-Axioms vstd::map_lib::impl&%0::remove_keys")
(assert (fuel_bool_default fuel%vstd!map_lib.impl&%0.remove_keys.))
(declare-fun %%lambda%%0 (Dcr Type Poly Dcr Type Poly) %%Function%%)
(assert (forall ((%%hole%%0 Dcr) (%%hole%%1 Type) (%%hole%%2 Poly) (%%hole%%3 Dcr) (%%hole%%4 Type) (%%hole%%5 Poly) (k$ Poly)) (! (= (%%apply%%0 (%%lambda%%0 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5) k$) (B (and (vstd!set.impl&%0.contains.? %%hole%%0 %%hole%%1 %%hole%%2 k$) (not (vstd!set.impl&%0.contains.? %%hole%%3 %%hole%%4 %%hole%%5 k$))))) :pattern ((%%apply%%0 (%%lambda%%0 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5) k$)))))
(declare-fun %%lambda%%1 (Dcr Type Dcr Type Poly) %%Function%%)
(assert (forall ((%%hole%%0 Dcr) (%%hole%%1 Type) (%%hole%%2 Dcr) (%%hole%%3 Type) (%%hole%%4 Poly) (k$ Poly)) (! (= (%%apply%%0 (%%lambda%%1 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4) k$) (vstd!map.impl&%0.index.? %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 k$)) :pattern ((%%apply%%0 (%%lambda%%1 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4) k$)))))
(assert (=> (fuel_bool fuel%vstd!map_lib.impl&%0.remove_keys.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self! Poly) (keys! Poly)) (! (= (vstd!map_lib.impl&%0.remove_keys.? K&. K& V&. V& self! keys!) (vstd!map.impl&%0.new.? K&. K& V&. V& $ (TYPE%fun%1. K&. K& $ BOOL) $ (TYPE%fun%1. K&. K& V&. V&) (Poly%fun%1. (mk_fun (%%lambda%%0 K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& self!) K&. K& keys!))) (Poly%fun%1. (mk_fun (%%lambda%%1 K&. K& V&. V& self!))))) :pattern ((vstd!map_lib.impl&%0.remove_keys.? K&. K& V&. V& self! keys!)) ))))
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self! Poly) (keys! Poly)) (! (=> (and (has_type self! (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type keys! (TYPE%vstd!set.Set. K&. K&))) (has_type (vstd!map_lib.impl&%0.remove_keys.? K&. K& V&. V& self! keys!) (TYPE%vstd!map.Map. K&. K& V&. V&))) :pattern ((vstd!map_lib.impl&%0.remove_keys.? K&. K& V&. V& self! keys!)) )))
(set-info :comment ";; Function-Axioms lib::kv::volatile::volatilespec_t::VolatileKvIndexView::trim_list")
(assert (fuel_bool_default fuel%lib!kv.volatile.volatilespec_t.impl&%1.trim_list.))
(declare-fun %%lambda%%2 (Int Dcr Type Poly) %%Function%%)
(assert (forall ((%%hole%%0 Int) (%%hole%%1 Dcr) (%%hole%%2 Type) (%%hole%%3 Poly) (k$ Poly)) (! (= (%%apply%%0 (%%lambda%%2 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3) k$) (B (let ((i$ (%I (tuple%2./tuple%2/0 (%Poly%tuple%2. k$))))) (let ((j$ (%I (tuple%2./tuple%2/1 (%Poly%tuple%2. k$))))) (and (and (<= i$ j$) (< j$ %%hole%%0)) (vstd!set.impl&%0.contains.? %%hole%%1 %%hole%%2 %%hole%%3 (Poly%tuple%2. (tuple%2./tuple%2 (I i$) (I j$))))))))) :pattern ((%%apply%%0 (%%lambda%%2 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3) k$)))))
(declare-fun %%lambda%%3 (Int Int Dcr Type Poly) %%Function%%)
(assert (forall ((%%hole%%0 Int) (%%hole%%1 Int) (%%hole%%2 Dcr) (%%hole%%3 Type) (%%hole%%4 Poly) (k$ Poly)) (! (= (%%apply%%0 (%%lambda%%3 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4) k$) (B (let ((i$ (%I (tuple%2./tuple%2/0 (%Poly%tuple%2. k$))))) (let ((j$ (%I (tuple%2./tuple%2/1 (%Poly%tuple%2. k$))))) (vstd!set.impl&%0.contains.? %%hole%%2 %%hole%%3 %%hole%%4 (Poly%tuple%2. (tuple%2./tuple%2 (I (Add i$ %%hole%%0)) (I (Add j$ %%hole%%1))))))))) :pattern ((%%apply%%0 (%%lambda%%3 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4) k$)))))
(declare-fun %%lambda%%4 (Dcr Type Dcr Type Poly) %%Function%%)
(assert (forall ((%%hole%%0 Dcr) (%%hole%%1 Type) (%%hole%%2 Dcr) (%%hole%%3 Type) (%%hole%%4 Poly) (k$ Poly)) (! (= (%%apply%%0 (%%lambda%%4 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4) k$) (Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. (let ((i$ (%I (tuple%2./tuple%2/0 (%Poly%tuple%2. k$))))) (let ((j$ (%I (tuple%2./tuple%2/1 (%Poly%tuple%2. k$))))) (let ((entry$1 (%Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. (vstd!map.impl&%0.index.? %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 (Poly%tuple%2. (tuple%2./tuple%2 (I i$) (I j$))))))) (lib!kv.volatile.volatilespec_t.ListNodeIndexEntry./ListNodeIndexEntry (%I (I i$)) (%I (I (lib!kv.volatile.volatilespec_t.ListNodeIndexEntry./ListNodeIndexEntry/live_index (%Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. (Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. entry$1))))) (%I (I (lib!kv.volatile.volatilespec_t.ListNodeIndexEntry./ListNodeIndexEntry/physical_offset (%Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. (Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. entry$1))))) (%I (I (lib!kv.volatile.volatilespec_t.ListNodeIndexEntry./ListNodeIndexEntry/free_entries (%Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. (Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. entry$1))))))))))) :pattern ((%%apply%%0 (%%lambda%%4 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4) k$)))))
(assert (=> (fuel_bool fuel%lib!kv.volatile.volatilespec_t.impl&%1.trim_list.) (forall ((K&. Dcr) (K& Type) (E&. Dcr) (E& Type) (self! Poly) (key! Poly) (trim_length! Poly)) (! (= (lib!kv.volatile.volatilespec_t.impl&%1.trim_list.? K&. K& E&. E& self! key! trim_length!) (ite (not (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& $ TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView/contents (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. self!))) key!)) (core!result.Result./Err (Poly%lib!kv.kvimpl_t.KvError. lib!kv.kvimpl_t.KvError./KeyNotFound)) (let ((entry$ (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (vstd!map.impl&%0.index.? K&. K& $ TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView/contents (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. self!)) key!)))) (let ((nodes_to_remove$ (%Poly%vstd!set.Set<tuple%2<int./int.>.>. (vstd!set.impl&%0.new.? $ (TYPE%tuple%2. $ INT $ INT) $ (TYPE%fun%1. $ (TYPE%tuple%2. $ INT $ INT) $ BOOL) (Poly%fun%1. (mk_fun (%%lambda%%2 (%I trim_length!) $ (TYPE%tuple%2. $ INT $ INT) (vstd!map.impl&%0.dom.? $ (TYPE%tuple%2. $ INT $ INT) $ TYPE%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. (Poly%vstd!map.Map<tuple%2<int./int.>./lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.>. (lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry/list_node_offsets (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. entry$)))))))))))) (let ((tmp%%$ (lib!kv.volatile.volatilespec_t.impl&%1.get_node_view.? K&. K& E&. E& self! key! trim_length!))) (ite (and (is-core!result.Result./Ok_ tmp%%$) (is-tuple%2./tuple%2_ (%Poly%tuple%2. (core!result.Result./Ok/0 (%Poly%core!result.Result. (Poly%core!result.Result. tmp%%$)))))) (let ((range_key$ (%Poly%tuple%2. (tuple%2./tuple%2/0 (%Poly%tuple%2. (core!result.Result./Ok/0 (%Poly%core!result.Result. (Poly%core!result.Result. tmp%%$)))))))) (let ((node_to_trim_internally$ (%Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. (tuple%2./tuple%2/1 (%Poly%tuple%2. (core!result.Result./Ok/0 (%Poly%core!result.Result. (Poly%core!result.Result. tmp%%$)))))))) (let ((internal_trim_size$ (Sub (%I trim_length!) (lib!kv.volatile.volatilespec_t.ListNodeIndexEntry./ListNodeIndexEntry/start_index (%Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. (Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. node_to_trim_internally$)))))) (let ((trimmed_entry$ (lib!kv.volatile.volatilespec_t.ListNodeIndexEntry./ListNodeIndexEntry (%I (I 0)) (%I (I (Add (lib!kv.volatile.volatilespec_t.ListNodeIndexEntry./ListNodeIndexEntry/live_index (%Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. (Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. node_to_trim_internally$))) internal_trim_size$))) (%I (I (lib!kv.volatile.volatilespec_t.ListNodeIndexEntry./ListNodeIndexEntry/physical_offset (%Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. (Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. node_to_trim_internally$))))) (%I (I (Add (lib!kv.volatile.volatilespec_t.ListNodeIndexEntry./ListNodeIndexEntry/free_entries (%Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. (Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. node_to_trim_internally$))) internal_trim_size$)))))) (let ((new_node_map$ (%Poly%vstd!map.Map<tuple%2<int./int.>./lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.>. (vstd!map.impl&%0.remove.? $ (TYPE%tuple%2. $ INT $ INT) $ TYPE%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. (vstd!map_lib.impl&%0.remove_keys.? $ (TYPE%tuple%2. $ INT $ INT) $ TYPE%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. (Poly%vstd!map.Map<tuple%2<int./int.>./lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.>. (lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry/list_node_offsets (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. entry$)))) (Poly%vstd!set.Set<tuple%2<int./int.>.>. nodes_to_remove$)) (Poly%tuple%2. range_key$))))) (let ((shifted_node_map$ (%Poly%vstd!map.Map<tuple%2<int./int.>./lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.>. (vstd!map.impl&%0.new.? $ (TYPE%tuple%2. $ INT $ INT) $ TYPE%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. $ (TYPE%fun%1. $ (TYPE%tuple%2. $ INT $ INT) $ BOOL) $ (TYPE%fun%1. $ (TYPE%tuple%2. $ INT $ INT) $ TYPE%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.) (Poly%fun%1. (mk_fun (%%lambda%%3 (%I trim_length!) (%I trim_length!) $ (TYPE%tuple%2. $ INT $ INT) (vstd!map.impl&%0.dom.? $ (TYPE%tuple%2. $ INT $ INT) $ TYPE%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. (Poly%vstd!map.Map<tuple%2<int./int.>./lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.>. new_node_map$))))) (Poly%fun%1. (mk_fun (%%lambda%%4 $ (TYPE%tuple%2. $ INT $ INT) $ TYPE%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. (Poly%vstd!map.Map<tuple%2<int./int.>./lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.>. new_node_map$)))))))) (let ((final_node_map$ (%Poly%vstd!map.Map<tuple%2<int./int.>./lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.>. (vstd!map.impl&%0.insert.? $ (TYPE%tuple%2. $ INT $ INT) $ TYPE%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. (Poly%vstd!map.Map<tuple%2<int./int.>./lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.>. shifted_node_map$) (Poly%tuple%2. range_key$) (Poly%lib!kv.volatile.volatilespec_t.ListNodeIndexEntry. trimmed_entry$))))) (core!result.Result./Ok (Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. (lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView (vstd!map.impl&%0.insert.? K&. K& $ TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView/contents (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. self!)) key! (Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry (%I (I (lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry/item_offset (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. entry$))))) (%Poly%vstd!map.Map<tuple%2<int./int.>./lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.>. (Poly%vstd!map.Map<tuple%2<int./int.>./lib!kv.volatile.volatilespec_t.ListNodeIndexEntry.>. final_node_map$)) (%I (I (Sub (lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry/list_len (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. entry$))) (%I trim_length!))))))) (%I (I (lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView/list_entries_per_node (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. self!)))))))))))))) (let ((e$ (%Poly%lib!kv.kvimpl_t.KvError. (core!result.Result./Err/0 (%Poly%core!result.Result. (Poly%core!result.Result. tmp%%$)))))) (core!result.Result./Err (Poly%lib!kv.kvimpl_t.KvError. e$))))))))) :pattern ((lib!kv.volatile.volatilespec_t.impl&%1.trim_list.? K&. K& E&. E& self! key! trim_length!)) ))))
(assert (forall ((K&. Dcr) (K& Type) (E&. Dcr) (E& Type) (self! Poly) (key! Poly) (trim_length! Poly)) (! (=> (and (has_type self! (TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. K&. K&)) (has_type key! K&) (has_type trim_length! INT)) (has_type (Poly%core!result.Result. (lib!kv.volatile.volatilespec_t.impl&%1.trim_list.? K&. K& E&. E& self! key! trim_length!)) (TYPE%core!result.Result. $ (TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. K&. K&) $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&)))) :pattern ((lib!kv.volatile.volatilespec_t.impl&%1.trim_list.? K&. K& E&. E& self! key! trim_length!)) )))
(set-info :comment ";; Function-Specs lib::kv::volatile::volatileimpl_v::VolatileKvIndex::trim_list")
(declare-fun req%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.trim_list. (Dcr Type Dcr Type Dcr Type Poly Poly Poly) Bool)
(declare-const %%global_location_label%%26 Bool)
(assert (forall ((Self%&. Dcr) (Self%& Type) (K&. Dcr) (K& Type) (E&. Dcr) (E& Type) (pre%self! Poly) (key! Poly) (trim_length! Poly)) (! (= (req%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.trim_list. Self%&. Self%& K&. K& E&. E& pre%self! key! trim_length!) (=> %%global_location_label%%26 (%B (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.valid.? Self%&. Self%& K&. K& E&. E& pre%self!)))) :pattern ((req%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.trim_list. Self%&. Self%& K&. K& E&. E& pre%self! key! trim_length!)) )))
(declare-fun ens%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.trim_list. (Dcr Type Dcr Type Dcr Type Poly Poly Poly Poly Poly) Bool)
(assert (forall ((Self%&. Dcr) (Self%& Type) (K&. Dcr) (K& Type) (E&. Dcr) (E& Type) (pre%self! Poly) (self! Poly) (key! Poly) (trim_length! Poly) (result! Poly)) (! (= (ens%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.trim_list. Self%&. Self%& K&. K& E&. E& pre%self! self! key! trim_length! result!) (and (has_type result! (TYPE%core!result.Result. $ TYPE%tuple%0. $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) (has_type self! Self%&) (%B (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.valid.? Self%&. Self%& K&. K& E&. E& self!)) (let ((spec_result$ (lib!kv.volatile.volatilespec_t.impl&%1.trim_list.? K&. K& E&. E& (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? Self%&. Self%& K&. K& E&. E& pre%self!) key! trim_length!))) (let ((tmp%%$ (tuple%2./tuple%2 result! (Poly%core!result.Result. spec_result$)))) (ite (and (and (is-tuple%2./tuple%2_ tmp%%$) (and (is-core!result.Result./Ok_ (%Poly%core!result.Result. (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))) (is-tuple%0./tuple%0_ (%Poly%tuple%0. (core!result.Result./Ok/0 (%Poly%core!result.Result. (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))))))) (is-core!result.Result./Ok_ (%Poly%core!result.Result. (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$)))))) (let ((spec_self$ (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. (core!result.Result./Ok/0 (%Poly%core!result.Result. (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$)))))))) (= (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? Self%&. Self%& K&. K& E&. E& self!)) spec_self$)) (ite (and (and (is-tuple%2./tuple%2_ tmp%%$) (and (is-core!result.Result./Err_ (%Poly%core!result.Result. (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))) (is-lib!kv.kvimpl_t.KvError./KeyNotFound_ (%Poly%lib!kv.kvimpl_t.KvError. (core!result.Result./Err/0 (%Poly%core!result.Result. (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))))))) (and (is-core!result.Result./Err_ (%Poly%core!result.Result. (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))) (is-lib!kv.kvimpl_t.KvError./KeyNotFound_ (%Poly%lib!kv.kvimpl_t.KvError. (core!result.Result./Err/0 (%Poly%core!result.Result. (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))))))) (and (not (lib!kv.volatile.volatilespec_t.impl&%1.contains_key.? K&. K& (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? Self%&. Self%& K&. K& E&. E& pre%self!) key!)) (= (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? Self%&. Self%& K&. K& E&. E& self!) (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? Self%&. Self%& K&. K& E&. E& pre%self!))) (and (and (and (is-tuple%2./tuple%2_ tmp%%$) (and (is-core!result.Result./Err_ (%Poly%core!result.Result. (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))) (is-lib!kv.kvimpl_t.KvError./IndexOutOfRange_ (%Poly%lib!kv.kvimpl_t.KvError. (core!result.Result./Err/0 (%Poly%core!result.Result. (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))))))) (and (is-core!result.Result./Err_ (%Poly%core!result.Result. (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))) (is-lib!kv.kvimpl_t.KvError./IndexOutOfRange_ (%Poly%lib!kv.kvimpl_t.KvError. (core!result.Result./Err/0 (%Poly%core!result.Result. (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))))))) (and (and (lib!kv.volatile.volatilespec_t.impl&%1.contains_key.? K&. K& (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? Self%&. Self%& K&. K& E&. E& pre%self!) key!) (<= (lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry/list_len (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. (lib!kv.volatile.volatilespec_t.impl&%1.spec_index.? K&. K& (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? Self%&. Self%& K&. K& E&. E& pre%self!) key!)))))) (%I trim_length!))) (= (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? Self%&. Self%& K&. K& E&. E& self!) (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? Self%&. Self%& K&. K& E&. E& pre%self!)))))))))) :pattern ((ens%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.trim_list. Self%&. Self%& K&. K& E&. E& pre%self! self! key! trim_length! result!)) )))
(set-info :comment ";; Function-Axioms lib::kv::volatile::volatilespec_t::VolatileKvIndexView::keys")
(assert (fuel_bool_default fuel%lib!kv.volatile.volatilespec_t.impl&%1.keys.))
(assert (=> (fuel_bool fuel%lib!kv.volatile.volatilespec_t.impl&%1.keys.) (forall ((K&. Dcr) (K& Type) (self! Poly)) (! (= (lib!kv.volatile.volatilespec_t.impl&%1.keys.? K&. K& self!) (vstd!map.impl&%0.dom.? K&. K& $ TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView/contents (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. self!)))) :pattern ((lib!kv.volatile.volatilespec_t.impl&%1.keys.? K&. K& self!)) ))))
(assert (forall ((K&. Dcr) (K& Type) (self! Poly)) (! (=> (has_type self! (TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. K&. K&)) (has_type (lib!kv.volatile.volatilespec_t.impl&%1.keys.? K&. K& self!) (TYPE%vstd!set.Set. K&. K&))) :pattern ((lib!kv.volatile.volatilespec_t.impl&%1.keys.? K&. K& self!)) )))
(set-info :comment ";; Function-Axioms vstd::seq_lib::impl&%0::contains")
(assert (fuel_bool_default fuel%vstd!seq_lib.impl&%0.contains.))
(assert (=> (fuel_bool fuel%vstd!seq_lib.impl&%0.contains.) (forall ((A&. Dcr) (A& Type) (self! Poly) (needle! Poly)) (! (= (vstd!seq_lib.impl&%0.contains.? A&. A& self! needle!) (exists ((i$ Poly)) (! (and (has_type i$ INT) (and (and (<= 0 (%I i$)) (< (%I i$) (vstd!seq.Seq.len.? A&. A& self!))) (= (vstd!seq.Seq.index.? A&. A& self! i$) needle!))) :pattern ((vstd!seq.Seq.index.? A&. A& self! i$)) ))) :pattern ((vstd!seq_lib.impl&%0.contains.? A&. A& self! needle!)) ))))
(set-info :comment ";; Function-Axioms vstd::seq_lib::impl&%0::to_set")
(assert (fuel_bool_default fuel%vstd!seq_lib.impl&%0.to_set.))
(declare-fun %%lambda%%5 (Dcr Type Poly) %%Function%%)
(assert (forall ((%%hole%%0 Dcr) (%%hole%%1 Type) (%%hole%%2 Poly) (a$ Poly)) (! (= (%%apply%%0 (%%lambda%%5 %%hole%%0 %%hole%%1 %%hole%%2) a$) (B (vstd!seq_lib.impl&%0.contains.? %%hole%%0 %%hole%%1 %%hole%%2 a$))) :pattern ((%%apply%%0 (%%lambda%%5 %%hole%%0 %%hole%%1 %%hole%%2) a$)))))
(assert (=> (fuel_bool fuel%vstd!seq_lib.impl&%0.to_set.) (forall ((A&. Dcr) (A& Type) (self! Poly)) (! (= (vstd!seq_lib.impl&%0.to_set.? A&. A& self!) (vstd!set.impl&%0.new.? A&. A& $ (TYPE%fun%1. A&. A& $ BOOL) (Poly%fun%1. (mk_fun (%%lambda%%5 A&. A& self!))))) :pattern ((vstd!seq_lib.impl&%0.to_set.? A&. A& self!)) ))))
(assert (forall ((A&. Dcr) (A& Type) (self! Poly)) (! (=> (has_type self! (TYPE%vstd!seq.Seq. A&. A&)) (has_type (vstd!seq_lib.impl&%0.to_set.? A&. A& self!) (TYPE%vstd!set.Set. A&. A&))) :pattern ((vstd!seq_lib.impl&%0.to_set.? A&. A& self!)) )))
(set-info :comment ";; Function-Specs lib::kv::volatile::volatileimpl_v::VolatileKvIndex::get_keys")
(declare-fun req%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.get_keys. (Dcr Type Dcr Type Dcr Type Poly) Bool)
(declare-const %%global_location_label%%27 Bool)
(assert (forall ((Self%&. Dcr) (Self%& Type) (K&. Dcr) (K& Type) (E&. Dcr) (E& Type) (self! Poly)) (! (= (req%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.get_keys. Self%&. Self%& K&. K& E&. E& self!) (=> %%global_location_label%%27 (%B (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.valid.? Self%&. Self%& K&. K& E&. E& self!)))) :pattern ((req%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.get_keys. Self%&. Self%& K&. K& E&. E& self!)) )))
(declare-fun ens%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.get_keys. (Dcr Type Dcr Type Dcr Type Poly Poly) Bool)
(assert (forall ((Self%&. Dcr) (Self%& Type) (K&. Dcr) (K& Type) (E&. Dcr) (E& Type) (self! Poly) (result! Poly)) (! (= (ens%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.get_keys. Self%&. Self%& K&. K& E&. E& self! result!) (and (has_type result! (TYPE%alloc!vec.Vec. K&. K& $ ALLOCATOR_GLOBAL)) (= (lib!kv.volatile.volatilespec_t.impl&%1.keys.? K&. K& (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? Self%&. Self%& K&. K& E&. E& self!)) (vstd!seq_lib.impl&%0.to_set.? K&. K& (vstd!view.View.view.? $ (TYPE%alloc!vec.Vec. K&. K& $ ALLOCATOR_GLOBAL) result!))))) :pattern ((ens%lib!kv.volatile.volatileimpl_v.VolatileKvIndex.get_keys. Self%&. Self%& K&. K& E&. E& self! result!)) )))
(set-info :comment ";; Function-Specs core::result::impl&%26::branch")
(declare-fun ens%core!result.impl&%26.branch. (Dcr Type Dcr Type core!result.Result. core!ops.control_flow.ControlFlow.) Bool)
(assert (forall ((T&. Dcr) (T& Type) (E&. Dcr) (E& Type) (result! core!result.Result.) (cf! core!ops.control_flow.ControlFlow.)) (! (= (ens%core!result.impl&%26.branch. T&. T& E&. E& result! cf!) (and (has_type (Poly%core!ops.control_flow.ControlFlow. cf!) (TYPE%core!ops.control_flow.ControlFlow. $ (TYPE%core!result.Result. $ TYPE%core!convert.Infallible. E&. E&) T&. T&)) (= cf! (ite (is-core!result.Result./Ok_ result!) (let ((v$ (core!result.Result./Ok/0 (%Poly%core!result.Result. (Poly%core!result.Result. result!))))) (core!ops.control_flow.ControlFlow./Continue v$)) (let ((e$ (core!result.Result./Err/0 (%Poly%core!result.Result. (Poly%core!result.Result. result!))))) (core!ops.control_flow.ControlFlow./Break (Poly%core!result.Result. (core!result.Result./Err e$)))))))) :pattern ((ens%core!result.impl&%26.branch. T&. T& E&. E& result! cf!)) )))
(set-info :comment ";; Broadcast vstd::std_specs::control_flow::spec_from_blanket_identity")
(assert (=> (fuel_bool fuel%vstd!std_specs.control_flow.spec_from_blanket_identity.) (forall ((T&. Dcr) (T& Type) (t! Poly) (s! Poly)) (! (=> (and (has_type t! T&) (has_type s! T&)) (=> (vstd!std_specs.control_flow.spec_from.? T&. T& T&. T& t! s!) (= t! s!))) :pattern ((vstd!std_specs.control_flow.spec_from.? T&. T& T&. T& t! s!)) ))))
(set-info :comment ";; Function-Specs core::result::impl&%27::from_residual")
(declare-fun ens%core!result.impl&%27.from_residual. (Dcr Type Dcr Type Dcr Type core!result.Result. core!result.Result.) Bool)
(assert (forall ((T&. Dcr) (T& Type) (E&. Dcr) (E& Type) (F&. Dcr) (F& Type) (result! core!result.Result.) (result2! core!result.Result.)) (! (= (ens%core!result.impl&%27.from_residual. T&. T& E&. E& F&. F& result! result2!) (and (has_type (Poly%core!result.Result. result2!) (TYPE%core!result.Result. T&. T& F&. F&)) (let ((tmp%%$ (tuple%2./tuple%2 (Poly%core!result.Result. result!) (Poly%core!result.Result. result2!)))) (and (and (and (is-tuple%2./tuple%2_ tmp%%$) (is-core!result.Result./Err_ (%Poly%core!result.Result. (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$)))))) (is-core!result.Result./Err_ (%Poly%core!result.Result. (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$)))))) (let ((e$ (core!result.Result./Err/0 (%Poly%core!result.Result. (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))))) (let ((e2$ (core!result.Result./Err/0 (%Poly%core!result.Result. (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))))) (vstd!std_specs.control_flow.spec_from.? F&. F& E&. E& e$ e2$))))))) :pattern ((ens%core!result.impl&%27.from_residual. T&. T& E&. E& F&. F& result! result2!)) )))
(set-info :comment ";; Function-Axioms vstd::std_specs::option::is_some")
(assert (fuel_bool_default fuel%vstd!std_specs.option.is_some.))
(assert (=> (fuel_bool fuel%vstd!std_specs.option.is_some.) (forall ((T&. Dcr) (T& Type) (option! Poly)) (! (= (vstd!std_specs.option.is_some.? T&. T& option!) (is-core!option.Option./Some_ (%Poly%core!option.Option. option!))) :pattern ((vstd!std_specs.option.is_some.? T&. T& option!)) ))))
(set-info :comment ";; Function-Specs core::option::impl&%0::is_some")
(declare-fun ens%core!option.impl&%0.is_some. (Dcr Type core!option.Option. Bool) Bool)
(assert (forall ((T&. Dcr) (T& Type) (option! core!option.Option.) (b! Bool)) (! (= (ens%core!option.impl&%0.is_some. T&. T& option! b!) (= b! (is-core!option.Option./Some_ option!))) :pattern ((ens%core!option.impl&%0.is_some. T&. T& option! b!)) )))
(set-info :comment ";; Broadcast vstd::map::axiom_map_index_decreases_finite")
(assert (=> (fuel_bool fuel%vstd!map.axiom_map_index_decreases_finite.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m! Poly) (key! Poly)) (! (=> (and (has_type m! (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type key! K&)) (=> (and (vstd!set.impl&%0.finite.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m!)) (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m!) key!)) (height_lt (height (vstd!map.impl&%0.index.? K&. K& V&. V& m! key!)) (height m!)))) :pattern ((height (vstd!map.impl&%0.index.? K&. K& V&. V& m! key!))) ))))
(set-info :comment ";; Broadcast vstd::map::axiom_map_index_decreases_infinite")
(assert (=> (fuel_bool fuel%vstd!map.axiom_map_index_decreases_infinite.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m! Poly) (key! Poly)) (! (=> (and (has_type m! (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type key! K&)) (=> (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m!) key!) (height_lt (height (vstd!map.impl&%0.index.? K&. K& V&. V& m! key!)) (height (fun_from_recursive_field m!))))) :pattern ((height (vstd!map.impl&%0.index.? K&. K& V&. V& m! key!))) ))))
(set-info :comment ";; Function-Axioms vstd::set::impl&%0::empty")
(assert (forall ((A&. Dcr) (A& Type)) (! (has_type (vstd!set.impl&%0.empty.? A&. A&) (TYPE%vstd!set.Set. A&. A&)) :pattern ((vstd!set.impl&%0.empty.? A&. A&)) )))
(set-info :comment ";; Broadcast vstd::map::axiom_map_empty")
(assert (=> (fuel_bool fuel%vstd!map.axiom_map_empty.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type)) (! (= (vstd!map.impl&%0.dom.? K&. K& V&. V& (vstd!map.impl&%0.empty.? K&. K& V&. V&)) (vstd!set.impl&%0.empty.? K&. K&)) :pattern ((vstd!map.impl&%0.dom.? K&. K& V&. V& (vstd!map.impl&%0.empty.? K&. K& V&. V&))) ))))
(set-info :comment ";; Function-Axioms vstd::set::impl&%0::insert")
(assert (forall ((A&. Dcr) (A& Type) (self! Poly) (a! Poly)) (! (=> (and (has_type self! (TYPE%vstd!set.Set. A&. A&)) (has_type a! A&)) (has_type (vstd!set.impl&%0.insert.? A&. A& self! a!) (TYPE%vstd!set.Set. A&. A&))) :pattern ((vstd!set.impl&%0.insert.? A&. A& self! a!)) )))
(set-info :comment ";; Broadcast vstd::map::axiom_map_insert_domain")
(assert (=> (fuel_bool fuel%vstd!map.axiom_map_insert_domain.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m! Poly) (key! Poly) (value! Poly)) (! (=> (and (has_type m! (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type key! K&) (has_type value! V&)) (= (vstd!map.impl&%0.dom.? K&. K& V&. V& (vstd!map.impl&%0.insert.? K&. K& V&. V& m! key! value!)) (vstd!set.impl&%0.insert.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m!) key!))) :pattern ((vstd!map.impl&%0.dom.? K&. K& V&. V& (vstd!map.impl&%0.insert.? K&. K& V&. V& m! key! value!))) ))))
(set-info :comment ";; Broadcast vstd::map::axiom_map_insert_same")
(assert (=> (fuel_bool fuel%vstd!map.axiom_map_insert_same.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m! Poly) (key! Poly) (value! Poly)) (! (=> (and (has_type m! (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type key! K&) (has_type value! V&)) (= (vstd!map.impl&%0.index.? K&. K& V&. V& (vstd!map.impl&%0.insert.? K&. K& V&. V& m! key! value!) key!) value!)) :pattern ((vstd!map.impl&%0.index.? K&. K& V&. V& (vstd!map.impl&%0.insert.? K&. K& V&. V& m! key! value!) key!)) ))))
(set-info :comment ";; Broadcast vstd::map::axiom_map_insert_different")
(assert (=> (fuel_bool fuel%vstd!map.axiom_map_insert_different.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m! Poly) (key1! Poly) (key2! Poly) (value! Poly)) (! (=> (and (has_type m! (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type key1! K&) (has_type key2! K&) (has_type value! V&)) (=> (and (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m!) key1!) (not (= key1! key2!))) (= (vstd!map.impl&%0.index.? K&. K& V&. V& (vstd!map.impl&%0.insert.? K&. K& V&. V& m! key2! value!) key1!) (vstd!map.impl&%0.index.? K&. K& V&. V& m! key1!)))) :pattern ((vstd!map.impl&%0.index.? K&. K& V&. V& (vstd!map.impl&%0.insert.? K&. K& V&. V& m! key2! value!) key1!)) ))))
(set-info :comment ";; Function-Axioms vstd::set::impl&%0::remove")
(assert (forall ((A&. Dcr) (A& Type) (self! Poly) (a! Poly)) (! (=> (and (has_type self! (TYPE%vstd!set.Set. A&. A&)) (has_type a! A&)) (has_type (vstd!set.impl&%0.remove.? A&. A& self! a!) (TYPE%vstd!set.Set. A&. A&))) :pattern ((vstd!set.impl&%0.remove.? A&. A& self! a!)) )))
(set-info :comment ";; Broadcast vstd::map::axiom_map_remove_domain")
(assert (=> (fuel_bool fuel%vstd!map.axiom_map_remove_domain.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m! Poly) (key! Poly)) (! (=> (and (has_type m! (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type key! K&)) (= (vstd!map.impl&%0.dom.? K&. K& V&. V& (vstd!map.impl&%0.remove.? K&. K& V&. V& m! key!)) (vstd!set.impl&%0.remove.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m!) key!))) :pattern ((vstd!map.impl&%0.dom.? K&. K& V&. V& (vstd!map.impl&%0.remove.? K&. K& V&. V& m! key!))) ))))
(set-info :comment ";; Broadcast vstd::map::axiom_map_remove_different")
(assert (=> (fuel_bool fuel%vstd!map.axiom_map_remove_different.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m! Poly) (key1! Poly) (key2! Poly)) (! (=> (and (has_type m! (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type key1! K&) (has_type key2! K&)) (=> (and (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m!) key1!) (not (= key1! key2!))) (= (vstd!map.impl&%0.index.? K&. K& V&. V& (vstd!map.impl&%0.remove.? K&. K& V&. V& m! key2!) key1!) (vstd!map.impl&%0.index.? K&. K& V&. V& m! key1!)))) :pattern ((vstd!map.impl&%0.index.? K&. K& V&. V& (vstd!map.impl&%0.remove.? K&. K& V&. V& m! key2!) key1!)) ))))
(set-info :comment ";; Broadcast vstd::map::axiom_map_ext_equal")
(assert (=> (fuel_bool fuel%vstd!map.axiom_map_ext_equal.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m1! Poly) (m2! Poly)) (! (=> (and (has_type m1! (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type m2! (TYPE%vstd!map.Map. K&. K& V&. V&))) (= (ext_eq false (TYPE%vstd!map.Map. K&. K& V&. V&) m1! m2!) (and (ext_eq false (TYPE%vstd!set.Set. K&. K&) (vstd!map.impl&%0.dom.? K&. K& V&. V& m1!) (vstd!map.impl&%0.dom.? K&. K& V&. V& m2!)) (forall ((k$ Poly)) (! (=> (has_type k$ K&) (=> (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m1!) k$) (= (vstd!map.impl&%0.index.? K&. K& V&. V& m1! k$) (vstd!map.impl&%0.index.? K&. K& V&. V& m2! k$)))) :pattern ((vstd!map.impl&%0.index.? K&. K& V&. V& m1! k$)) :pattern ((vstd!map.impl&%0.index.? K&. K& V&. V& m2! k$)) ))))) :pattern ((ext_eq false (TYPE%vstd!map.Map. K&. K& V&. V&) m1! m2!)) ))))
(set-info :comment ";; Broadcast vstd::map::axiom_map_ext_equal_deep")
(assert (=> (fuel_bool fuel%vstd!map.axiom_map_ext_equal_deep.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m1! Poly) (m2! Poly)) (! (=> (and (has_type m1! (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type m2! (TYPE%vstd!map.Map. K&. K& V&. V&))) (= (ext_eq true (TYPE%vstd!map.Map. K&. K& V&. V&) m1! m2!) (and (ext_eq true (TYPE%vstd!set.Set. K&. K&) (vstd!map.impl&%0.dom.? K&. K& V&. V& m1!) (vstd!map.impl&%0.dom.? K&. K& V&. V& m2!)) (forall ((k$ Poly)) (! (=> (has_type k$ K&) (=> (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m1!) k$) (ext_eq true V& (vstd!map.impl&%0.index.? K&. K& V&. V& m1! k$) (vstd!map.impl&%0.index.? K&. K& V&. V& m2! k$)))) :pattern ((vstd!map.impl&%0.index.? K&. K& V&. V& m1! k$)) :pattern ((vstd!map.impl&%0.index.? K&. K& V&. V& m2! k$)) ))))) :pattern ((ext_eq true (TYPE%vstd!map.Map. K&. K& V&. V&) m1! m2!)) ))))
(set-info :comment ";; Function-Specs vstd::seq::Seq::update")
(declare-fun req%vstd!seq.Seq.update. (Dcr Type Poly Poly Poly) Bool)
(declare-const %%global_location_label%%28 Bool)
(assert (forall ((A&. Dcr) (A& Type) (self! Poly) (i! Poly) (a! Poly)) (! (= (req%vstd!seq.Seq.update. A&. A& self! i! a!) (=> %%global_location_label%%28 (and (<= 0 (%I i!)) (< (%I i!) (vstd!seq.Seq.len.? A&. A& self!))))) :pattern ((req%vstd!seq.Seq.update. A&. A& self! i! a!)) )))
(set-info :comment ";; Function-Axioms vstd::seq::Seq::update")
(assert (forall ((A&. Dcr) (A& Type) (self! Poly) (i! Poly) (a! Poly)) (! (=> (and (has_type self! (TYPE%vstd!seq.Seq. A&. A&)) (has_type i! INT) (has_type a! A&)) (has_type (vstd!seq.Seq.update.? A&. A& self! i! a!) (TYPE%vstd!seq.Seq. A&. A&))) :pattern ((vstd!seq.Seq.update.? A&. A& self! i! a!)) )))
(set-info :comment ";; Function-Axioms vstd::raw_ptr::view_reverse_for_eq")
(assert (forall ((T&. Dcr) (T& Type) (data! Poly)) (! (=> (has_type data! TYPE%vstd!raw_ptr.PtrData.) (has_type (vstd!raw_ptr.view_reverse_for_eq.? T&. T& data!) (PTR T&. T&))) :pattern ((vstd!raw_ptr.view_reverse_for_eq.? T&. T& data!)) )))
(set-info :comment ";; Broadcast vstd::raw_ptr::ptrs_mut_eq")
(assert (=> (fuel_bool fuel%vstd!raw_ptr.ptrs_mut_eq.) (forall ((T&. Dcr) (T& Type) (a! Poly)) (! (=> (has_type a! (PTR T&. T&)) (= (vstd!raw_ptr.view_reverse_for_eq.? T&. T& (vstd!view.View.view.? $ (PTR T&. T&) a!)) a!)) :pattern ((vstd!view.View.view.? $ (PTR T&. T&) a!)) ))))
(set-info :comment ";; Broadcast vstd::seq::axiom_seq_index_decreases")
(assert (=> (fuel_bool fuel%vstd!seq.axiom_seq_index_decreases.) (forall ((A&. Dcr) (A& Type) (s! Poly) (i! Poly)) (! (=> (and (has_type s! (TYPE%vstd!seq.Seq. A&. A&)) (has_type i! INT)) (=> (and (<= 0 (%I i!)) (< (%I i!) (vstd!seq.Seq.len.? A&. A& s!))) (height_lt (height (vstd!seq.Seq.index.? A&. A& s! i!)) (height s!)))) :pattern ((height (vstd!seq.Seq.index.? A&. A& s! i!))) ))))
(set-info :comment ";; Broadcast vstd::seq::axiom_seq_subrange_decreases")
(assert (=> (fuel_bool fuel%vstd!seq.axiom_seq_subrange_decreases.) (forall ((A&. Dcr) (A& Type) (s! Poly) (i! Poly) (j! Poly)) (! (=> (and (has_type s! (TYPE%vstd!seq.Seq. A&. A&)) (has_type i! INT) (has_type j! INT)) (=> (and (and (and (<= 0 (%I i!)) (<= (%I i!) (%I j!))) (<= (%I j!) (vstd!seq.Seq.len.? A&. A& s!))) (< (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! i! j!)) (vstd!seq.Seq.len.? A&. A& s!))) (height_lt (height (vstd!seq.Seq.subrange.? A&. A& s! i! j!)) (height s!)))) :pattern ((height (vstd!seq.Seq.subrange.? A&. A& s! i! j!))) ))))
(set-info :comment ";; Broadcast vstd::seq::axiom_seq_empty")
(assert (=> (fuel_bool fuel%vstd!seq.axiom_seq_empty.) (forall ((A&. Dcr) (A& Type)) (! (= (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.empty.? A&. A&)) 0) :pattern ((vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.empty.? A&. A&))) ))))
(set-info :comment ";; Broadcast vstd::seq::axiom_seq_push_len")
(assert (=> (fuel_bool fuel%vstd!seq.axiom_seq_push_len.) (forall ((A&. Dcr) (A& Type) (s! Poly) (a! Poly)) (! (=> (and (has_type s! (TYPE%vstd!seq.Seq. A&. A&)) (has_type a! A&)) (= (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.push.? A&. A& s! a!)) (nClip (Add (vstd!seq.Seq.len.? A&. A& s!) 1)))) :pattern ((vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.push.? A&. A& s! a!))) ))))
(set-info :comment ";; Broadcast vstd::seq::axiom_seq_push_index_same")
(assert (=> (fuel_bool fuel%vstd!seq.axiom_seq_push_index_same.) (forall ((A&. Dcr) (A& Type) (s! Poly) (a! Poly) (i! Poly)) (! (=> (and (has_type s! (TYPE%vstd!seq.Seq. A&. A&)) (has_type a! A&) (has_type i! INT)) (=> (= (%I i!) (vstd!seq.Seq.len.? A&. A& s!)) (= (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.push.? A&. A& s! a!) i!) a!))) :pattern ((vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.push.? A&. A& s! a!) i!)) ))))
(set-info :comment ";; Broadcast vstd::seq::axiom_seq_push_index_different")
(assert (=> (fuel_bool fuel%vstd!seq.axiom_seq_push_index_different.) (forall ((A&. Dcr) (A& Type) (s! Poly) (a! Poly) (i! Poly)) (! (=> (and (has_type s! (TYPE%vstd!seq.Seq. A&. A&)) (has_type a! A&) (has_type i! INT)) (=> (and (<= 0 (%I i!)) (< (%I i!) (vstd!seq.Seq.len.? A&. A& s!))) (= (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.push.? A&. A& s! a!) i!) (vstd!seq.Seq.index.? A&. A& s! i!)))) :pattern ((vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.push.? A&. A& s! a!) i!)) ))))
(set-info :comment ";; Broadcast vstd::seq::axiom_seq_update_len")
(assert (=> (fuel_bool fuel%vstd!seq.axiom_seq_update_len.) (forall ((A&. Dcr) (A& Type) (s! Poly) (i! Poly) (a! Poly)) (! (=> (and (has_type s! (TYPE%vstd!seq.Seq. A&. A&)) (has_type i! INT) (has_type a! A&)) (=> (and (<= 0 (%I i!)) (< (%I i!) (vstd!seq.Seq.len.? A&. A& s!))) (= (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.update.? A&. A& s! i! a!)) (vstd!seq.Seq.len.? A&. A& s!)))) :pattern ((vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.update.? A&. A& s! i! a!))) ))))
(set-info :comment ";; Broadcast vstd::seq::axiom_seq_update_same")
(assert (=> (fuel_bool fuel%vstd!seq.axiom_seq_update_same.) (forall ((A&. Dcr) (A& Type) (s! Poly) (i! Poly) (a! Poly)) (! (=> (and (has_type s! (TYPE%vstd!seq.Seq. A&. A&)) (has_type i! INT) (has_type a! A&)) (=> (and (<= 0 (%I i!)) (< (%I i!) (vstd!seq.Seq.len.? A&. A& s!))) (= (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.update.? A&. A& s! i! a!) i!) a!))) :pattern ((vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.update.? A&. A& s! i! a!) i!)) ))))
(set-info :comment ";; Broadcast vstd::seq::axiom_seq_update_different")
(assert (=> (fuel_bool fuel%vstd!seq.axiom_seq_update_different.) (forall ((A&. Dcr) (A& Type) (s! Poly) (i1! Poly) (i2! Poly) (a! Poly)) (! (=> (and (has_type s! (TYPE%vstd!seq.Seq. A&. A&)) (has_type i1! INT) (has_type i2! INT) (has_type a! A&)) (=> (and (and (and (<= 0 (%I i1!)) (< (%I i1!) (vstd!seq.Seq.len.? A&. A& s!))) (and (<= 0 (%I i2!)) (< (%I i2!) (vstd!seq.Seq.len.? A&. A& s!)))) (not (= i1! i2!))) (= (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.update.? A&. A& s! i2! a!) i1!) (vstd!seq.Seq.index.? A&. A& s! i1!)))) :pattern ((vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.update.? A&. A& s! i2! a!) i1!)) ))))
(set-info :comment ";; Broadcast vstd::seq::axiom_seq_ext_equal")
(assert (=> (fuel_bool fuel%vstd!seq.axiom_seq_ext_equal.) (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly)) (! (=> (and (has_type s1! (TYPE%vstd!seq.Seq. A&. A&)) (has_type s2! (TYPE%vstd!seq.Seq. A&. A&))) (= (ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) (and (= (vstd!seq.Seq.len.? A&. A& s1!) (vstd!seq.Seq.len.? A&. A& s2!)) (forall ((i$ Poly)) (! (=> (has_type i$ INT) (=> (and (<= 0 (%I i$)) (< (%I i$) (vstd!seq.Seq.len.? A&. A& s1!))) (= (vstd!seq.Seq.index.? A&. A& s1! i$) (vstd!seq.Seq.index.? A&. A& s2! i$)))) :pattern ((vstd!seq.Seq.index.? A&. A& s1! i$)) :pattern ((vstd!seq.Seq.index.? A&. A& s2! i$)) ))))) :pattern ((ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1! s2!)) ))))
(set-info :comment ";; Broadcast vstd::seq::axiom_seq_ext_equal_deep")
(assert (=> (fuel_bool fuel%vstd!seq.axiom_seq_ext_equal_deep.) (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly)) (! (=> (and (has_type s1! (TYPE%vstd!seq.Seq. A&. A&)) (has_type s2! (TYPE%vstd!seq.Seq. A&. A&))) (= (ext_eq true (TYPE%vstd!seq.Seq. A&. A&) s1! s2!) (and (= (vstd!seq.Seq.len.? A&. A& s1!) (vstd!seq.Seq.len.? A&. A& s2!)) (forall ((i$ Poly)) (! (=> (has_type i$ INT) (=> (and (<= 0 (%I i$)) (< (%I i$) (vstd!seq.Seq.len.? A&. A& s1!))) (ext_eq true A& (vstd!seq.Seq.index.? A&. A& s1! i$) (vstd!seq.Seq.index.? A&. A& s2! i$)))) :pattern ((vstd!seq.Seq.index.? A&. A& s1! i$)) :pattern ((vstd!seq.Seq.index.? A&. A& s2! i$)) ))))) :pattern ((ext_eq true (TYPE%vstd!seq.Seq. A&. A&) s1! s2!)) ))))
(set-info :comment ";; Broadcast vstd::seq::axiom_seq_subrange_len")
(assert (=> (fuel_bool fuel%vstd!seq.axiom_seq_subrange_len.) (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly)) (! (=> (and (has_type s! (TYPE%vstd!seq.Seq. A&. A&)) (has_type j! INT) (has_type k! INT)) (=> (and (and (<= 0 (%I j!)) (<= (%I j!) (%I k!))) (<= (%I k!) (vstd!seq.Seq.len.? A&. A& s!))) (= (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!)) (Sub (%I k!) (%I j!))))) :pattern ((vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!))) ))))
(set-info :comment ";; Broadcast vstd::seq::axiom_seq_subrange_index")
(assert (=> (fuel_bool fuel%vstd!seq.axiom_seq_subrange_index.) (forall ((A&. Dcr) (A& Type) (s! Poly) (j! Poly) (k! Poly) (i! Poly)) (! (=> (and (has_type s! (TYPE%vstd!seq.Seq. A&. A&)) (has_type j! INT) (has_type k! INT) (has_type i! INT)) (=> (and (and (and (<= 0 (%I j!)) (<= (%I j!) (%I k!))) (<= (%I k!) (vstd!seq.Seq.len.? A&. A& s!))) (and (<= 0 (%I i!)) (< (%I i!) (Sub (%I k!) (%I j!))))) (= (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!) (vstd!seq.Seq.index.? A&. A& s! (I (Add (%I i!) (%I j!))))))) :pattern ((vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s! j! k!) i!)) ))))
(set-info :comment ";; Broadcast vstd::seq_lib::seq_to_set_is_finite")
(assert (=> (fuel_bool fuel%vstd!seq_lib.seq_to_set_is_finite.) (forall ((A&. Dcr) (A& Type) (seq! Poly)) (! (=> (has_type seq! (TYPE%vstd!seq.Seq. A&. A&)) (vstd!set.impl&%0.finite.? A&. A& (vstd!seq_lib.impl&%0.to_set.? A&. A& seq!))) :pattern ((vstd!set.impl&%0.finite.? A&. A& (vstd!seq_lib.impl&%0.to_set.? A&. A& seq!))) ))))
(set-info :comment ";; Broadcast vstd::set::axiom_set_empty")
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_empty.) (forall ((A&. Dcr) (A& Type) (a! Poly)) (! (=> (has_type a! A&) (not (vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.empty.? A&. A&) a!))) :pattern ((vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.empty.? A&. A&) a!)) ))))
(set-info :comment ";; Broadcast vstd::set::axiom_set_new")
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_new.) (forall ((A&. Dcr) (A& Type) (f! Poly) (a! Poly)) (! (=> (and (has_type f! (TYPE%fun%1. A&. A& $ BOOL)) (has_type a! A&)) (= (vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.new.? A&. A& $ (TYPE%fun%1. A&. A& $ BOOL) f!) a!) (%B (%%apply%%0 (%Poly%fun%1. f!) a!)))) :pattern ((vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.new.? A&. A& $ (TYPE%fun%1. A&. A& $ BOOL) f!) a!)) ))))
(set-info :comment ";; Broadcast vstd::set::axiom_set_insert_same")
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_insert_same.) (forall ((A&. Dcr) (A& Type) (s! Poly) (a! Poly)) (! (=> (and (has_type s! (TYPE%vstd!set.Set. A&. A&)) (has_type a! A&)) (vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.insert.? A&. A& s! a!) a!)) :pattern ((vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.insert.? A&. A& s! a!) a!)) ))))
(set-info :comment ";; Broadcast vstd::set::axiom_set_insert_different")
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_insert_different.) (forall ((A&. Dcr) (A& Type) (s! Poly) (a1! Poly) (a2! Poly)) (! (=> (and (has_type s! (TYPE%vstd!set.Set. A&. A&)) (has_type a1! A&) (has_type a2! A&)) (=> (not (= a1! a2!)) (= (vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.insert.? A&. A& s! a2!) a1!) (vstd!set.impl&%0.contains.? A&. A& s! a1!)))) :pattern ((vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.insert.? A&. A& s! a2!) a1!)) ))))
(set-info :comment ";; Broadcast vstd::set::axiom_set_remove_same")
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_remove_same.) (forall ((A&. Dcr) (A& Type) (s! Poly) (a! Poly)) (! (=> (and (has_type s! (TYPE%vstd!set.Set. A&. A&)) (has_type a! A&)) (not (vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.remove.? A&. A& s! a!) a!))) :pattern ((vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.remove.? A&. A& s! a!) a!)) ))))
(set-info :comment ";; Broadcast vstd::set::axiom_set_remove_insert")
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_remove_insert.) (forall ((A&. Dcr) (A& Type) (s! Poly) (a! Poly)) (! (=> (and (has_type s! (TYPE%vstd!set.Set. A&. A&)) (has_type a! A&)) (=> (vstd!set.impl&%0.contains.? A&. A& s! a!) (= (vstd!set.impl&%0.insert.? A&. A& (vstd!set.impl&%0.remove.? A&. A& s! a!) a!) s!))) :pattern ((vstd!set.impl&%0.remove.? A&. A& s! a!)) ))))
(set-info :comment ";; Broadcast vstd::set::axiom_set_remove_different")
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_remove_different.) (forall ((A&. Dcr) (A& Type) (s! Poly) (a1! Poly) (a2! Poly)) (! (=> (and (has_type s! (TYPE%vstd!set.Set. A&. A&)) (has_type a1! A&) (has_type a2! A&)) (=> (not (= a1! a2!)) (= (vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.remove.? A&. A& s! a2!) a1!) (vstd!set.impl&%0.contains.? A&. A& s! a1!)))) :pattern ((vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.remove.? A&. A& s! a2!) a1!)) ))))
(set-info :comment ";; Broadcast vstd::set::axiom_set_ext_equal")
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_ext_equal.) (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly)) (! (=> (and (has_type s1! (TYPE%vstd!set.Set. A&. A&)) (has_type s2! (TYPE%vstd!set.Set. A&. A&))) (= (ext_eq false (TYPE%vstd!set.Set. A&. A&) s1! s2!) (forall ((a$ Poly)) (! (=> (has_type a$ A&) (= (vstd!set.impl&%0.contains.? A&. A& s1! a$) (vstd!set.impl&%0.contains.? A&. A& s2! a$))) :pattern ((vstd!set.impl&%0.contains.? A&. A& s1! a$)) :pattern ((vstd!set.impl&%0.contains.? A&. A& s2! a$)) )))) :pattern ((ext_eq false (TYPE%vstd!set.Set. A&. A&) s1! s2!)) ))))
(set-info :comment ";; Broadcast vstd::set::axiom_set_ext_equal_deep")
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_ext_equal_deep.) (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly)) (! (=> (and (has_type s1! (TYPE%vstd!set.Set. A&. A&)) (has_type s2! (TYPE%vstd!set.Set. A&. A&))) (= (ext_eq true (TYPE%vstd!set.Set. A&. A&) s1! s2!) (ext_eq false (TYPE%vstd!set.Set. A&. A&) s1! s2!))) :pattern ((ext_eq true (TYPE%vstd!set.Set. A&. A&) s1! s2!)) ))))
(set-info :comment ";; Broadcast vstd::set::axiom_mk_map_domain")
(assert (=> (fuel_bool fuel%vstd!set.axiom_mk_map_domain.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (s! Poly) (f! Poly)) (! (=> (and (has_type s! (TYPE%vstd!set.Set. K&. K&)) (has_type f! (TYPE%fun%1. K&. K& V&. V&))) (= (vstd!map.impl&%0.dom.? K&. K& V&. V& (vstd!set.impl&%0.mk_map.? K&. K& V&. V& $ (TYPE%fun%1. K&. K& V&. V&) s! f!)) s!)) :pattern ((vstd!map.impl&%0.dom.? K&. K& V&. V& (vstd!set.impl&%0.mk_map.? K&. K& V&. V& $ (TYPE%fun%1. K&. K& V&. V&) s! f!))) ))))
(set-info :comment ";; Broadcast vstd::set::axiom_mk_map_index")
(assert (=> (fuel_bool fuel%vstd!set.axiom_mk_map_index.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (s! Poly) (f! Poly) (key! Poly)) (! (=> (and (has_type s! (TYPE%vstd!set.Set. K&. K&)) (has_type f! (TYPE%fun%1. K&. K& V&. V&)) (has_type key! K&)) (=> (vstd!set.impl&%0.contains.? K&. K& s! key!) (= (vstd!map.impl&%0.index.? K&. K& V&. V& (vstd!set.impl&%0.mk_map.? K&. K& V&. V& $ (TYPE%fun%1. K&. K& V&. V&) s! f!) key!) (%%apply%%0 (%Poly%fun%1. f!) key!)))) :pattern ((vstd!map.impl&%0.index.? K&. K& V&. V& (vstd!set.impl&%0.mk_map.? K&. K& V&. V& $ (TYPE%fun%1. K&. K& V&. V&) s! f!) key!)) ))))
(set-info :comment ";; Broadcast vstd::set::axiom_set_empty_finite")
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_empty_finite.) (forall ((A&. Dcr) (A& Type)) (! (vstd!set.impl&%0.finite.? A&. A& (vstd!set.impl&%0.empty.? A&. A&)) :pattern ((vstd!set.impl&%0.finite.? A&. A& (vstd!set.impl&%0.empty.? A&. A&))) ))))
(set-info :comment ";; Broadcast vstd::set::axiom_set_insert_finite")
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_insert_finite.) (forall ((A&. Dcr) (A& Type) (s! Poly) (a! Poly)) (! (=> (and (has_type s! (TYPE%vstd!set.Set. A&. A&)) (has_type a! A&)) (=> (vstd!set.impl&%0.finite.? A&. A& s!) (vstd!set.impl&%0.finite.? A&. A& (vstd!set.impl&%0.insert.? A&. A& s! a!)))) :pattern ((vstd!set.impl&%0.finite.? A&. A& (vstd!set.impl&%0.insert.? A&. A& s! a!))) ))))
(set-info :comment ";; Broadcast vstd::set::axiom_set_remove_finite")
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_remove_finite.) (forall ((A&. Dcr) (A& Type) (s! Poly) (a! Poly)) (! (=> (and (has_type s! (TYPE%vstd!set.Set. A&. A&)) (has_type a! A&)) (=> (vstd!set.impl&%0.finite.? A&. A& s!) (vstd!set.impl&%0.finite.? A&. A& (vstd!set.impl&%0.remove.? A&. A& s! a!)))) :pattern ((vstd!set.impl&%0.finite.? A&. A& (vstd!set.impl&%0.remove.? A&. A& s! a!))) ))))
(set-info :comment ";; Broadcast vstd::set::axiom_set_empty_len")
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_empty_len.) (forall ((A&. Dcr) (A& Type)) (! (= (vstd!set.impl&%0.len.? A&. A& (vstd!set.impl&%0.empty.? A&. A&)) 0) :pattern ((vstd!set.impl&%0.len.? A&. A& (vstd!set.impl&%0.empty.? A&. A&))) ))))
(set-info :comment ";; Broadcast vstd::set::axiom_set_insert_len")
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_insert_len.) (forall ((A&. Dcr) (A& Type) (s! Poly) (a! Poly)) (! (=> (and (has_type s! (TYPE%vstd!set.Set. A&. A&)) (has_type a! A&)) (=> (vstd!set.impl&%0.finite.? A&. A& s!) (= (vstd!set.impl&%0.len.? A&. A& (vstd!set.impl&%0.insert.? A&. A& s! a!)) (Add (vstd!set.impl&%0.len.? A&. A& s!) (ite (vstd!set.impl&%0.contains.? A&. A& s! a!) 0 1))))) :pattern ((vstd!set.impl&%0.len.? A&. A& (vstd!set.impl&%0.insert.? A&. A& s! a!))) ))))
(set-info :comment ";; Broadcast vstd::set::axiom_set_remove_len")
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_remove_len.) (forall ((A&. Dcr) (A& Type) (s! Poly) (a! Poly)) (! (=> (and (has_type s! (TYPE%vstd!set.Set. A&. A&)) (has_type a! A&)) (=> (vstd!set.impl&%0.finite.? A&. A& s!) (= (vstd!set.impl&%0.len.? A&. A& s!) (Add (vstd!set.impl&%0.len.? A&. A& (vstd!set.impl&%0.remove.? A&. A& s! a!)) (ite (vstd!set.impl&%0.contains.? A&. A& s! a!) 1 0))))) :pattern ((vstd!set.impl&%0.len.? A&. A& (vstd!set.impl&%0.remove.? A&. A& s! a!))) ))))
(set-info :comment ";; Broadcast vstd::set::axiom_set_contains_len")
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_contains_len.) (forall ((A&. Dcr) (A& Type) (s! Poly) (a! Poly)) (! (=> (and (has_type s! (TYPE%vstd!set.Set. A&. A&)) (has_type a! A&)) (=> (and (vstd!set.impl&%0.finite.? A&. A& s!) (vstd!set.impl&%0.contains.? A&. A& s! a!)) (not (= (vstd!set.impl&%0.len.? A&. A& s!) 0)))) :pattern ((vstd!set.impl&%0.contains.? A&. A& s! a!) (vstd!set.impl&%0.len.? A&. A& s!)) ))))
(set-info :comment ";; Broadcast vstd::set_lib::axiom_is_empty")
(assert (=> (fuel_bool fuel%vstd!set_lib.axiom_is_empty.) (forall ((A&. Dcr) (A& Type) (s! Poly)) (! (=> (has_type s! (TYPE%vstd!set.Set. A&. A&)) (=> (and (vstd!set.impl&%0.finite.? A&. A& s!) (not (vstd!set_lib.impl&%0.is_empty.? A&. A& s!))) (exists ((a$ Poly)) (! (and (has_type a$ A&) (vstd!set.impl&%0.contains.? A&. A& s! a$)) :pattern ((vstd!set.impl&%0.contains.? A&. A& s! a$)) )))) :pattern ((vstd!set_lib.impl&%0.is_empty.? A&. A& s!)) ))))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%lib!pmem.traits_t.UnsafeSpecPmSized. $ (UINT 64)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%lib!pmem.pmcopy_t.SpecPmSized. $ (UINT 64)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%lib!pmem.traits_t.PmSized. $ (UINT 64)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%lib!pmem.traits_t.PmSafe. $ (UINT 64)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%lib!pmem.pmcopy_t.PmCopy. $ (UINT 64)))
(set-info :comment ";; Function-Axioms vstd::raw_ptr::impl&%4::view")
(assert (fuel_bool_default fuel%vstd!raw_ptr.impl&%4.view.))
(assert (=> (fuel_bool fuel%vstd!raw_ptr.impl&%4.view.) (forall ((T&. Dcr) (T& Type) (self! Poly)) (! (= (vstd!view.View.view.? (CONST_PTR $) (PTR T&. T&) self!) (vstd!view.View.view.? $ (PTR T&. T&) self!)) :pattern ((vstd!view.View.view.? (CONST_PTR $) (PTR T&. T&) self!)) ))))
(set-info :comment ";; Function-Axioms vstd::view::impl&%0::view")
(assert (fuel_bool_default fuel%vstd!view.impl&%0.view.))
(assert (=> (fuel_bool fuel%vstd!view.impl&%0.view.) (forall ((A&. Dcr) (A& Type) (self! Poly)) (! (=> (tr_bound%vstd!view.View. A&. A&) (= (vstd!view.View.view.? (REF A&.) A& self!) (vstd!view.View.view.? A&. A& self!))) :pattern ((vstd!view.View.view.? (REF A&.) A& self!)) ))))
(set-info :comment ";; Function-Axioms vstd::view::impl&%2::view")
(assert (fuel_bool_default fuel%vstd!view.impl&%2.view.))
(assert (=> (fuel_bool fuel%vstd!view.impl&%2.view.) (forall ((A&. Dcr) (A& Type) (self! Poly)) (! (=> (tr_bound%vstd!view.View. A&. A&) (= (vstd!view.View.view.? (BOX $ ALLOCATOR_GLOBAL A&.) A& self!) (vstd!view.View.view.? A&. A& self!))) :pattern ((vstd!view.View.view.? (BOX $ ALLOCATOR_GLOBAL A&.) A& self!)) ))))
(set-info :comment ";; Function-Axioms vstd::view::impl&%4::view")
(assert (fuel_bool_default fuel%vstd!view.impl&%4.view.))
(assert (=> (fuel_bool fuel%vstd!view.impl&%4.view.) (forall ((A&. Dcr) (A& Type) (self! Poly)) (! (=> (tr_bound%vstd!view.View. A&. A&) (= (vstd!view.View.view.? (RC $ ALLOCATOR_GLOBAL A&.) A& self!) (vstd!view.View.view.? A&. A& self!))) :pattern ((vstd!view.View.view.? (RC $ ALLOCATOR_GLOBAL A&.) A& self!)) ))))
(set-info :comment ";; Function-Axioms vstd::view::impl&%6::view")
(assert (fuel_bool_default fuel%vstd!view.impl&%6.view.))
(assert (=> (fuel_bool fuel%vstd!view.impl&%6.view.) (forall ((A&. Dcr) (A& Type) (self! Poly)) (! (=> (tr_bound%vstd!view.View. A&. A&) (= (vstd!view.View.view.? (ARC $ ALLOCATOR_GLOBAL A&.) A& self!) (vstd!view.View.view.? A&. A& self!))) :pattern ((vstd!view.View.view.? (ARC $ ALLOCATOR_GLOBAL A&.) A& self!)) ))))
(set-info :comment ";; Function-Axioms vstd::view::impl&%10::view")
(assert (fuel_bool_default fuel%vstd!view.impl&%10.view.))
(assert (=> (fuel_bool fuel%vstd!view.impl&%10.view.) (forall ((self! Poly)) (! (= (vstd!view.View.view.? $ TYPE%tuple%0. self!) self!) :pattern ((vstd!view.View.view.? $ TYPE%tuple%0. self!)) ))))
(set-info :comment ";; Function-Axioms vstd::view::impl&%12::view")
(assert (fuel_bool_default fuel%vstd!view.impl&%12.view.))
(assert (=> (fuel_bool fuel%vstd!view.impl&%12.view.) (forall ((self! Poly)) (! (= (vstd!view.View.view.? $ BOOL self!) self!) :pattern ((vstd!view.View.view.? $ BOOL self!)) ))))
(set-info :comment ";; Function-Axioms vstd::view::impl&%14::view")
(assert (fuel_bool_default fuel%vstd!view.impl&%14.view.))
(assert (=> (fuel_bool fuel%vstd!view.impl&%14.view.) (forall ((self! Poly)) (! (= (vstd!view.View.view.? $ (UINT 8) self!) self!) :pattern ((vstd!view.View.view.? $ (UINT 8) self!)) ))))
(set-info :comment ";; Function-Axioms vstd::view::impl&%20::view")
(assert (fuel_bool_default fuel%vstd!view.impl&%20.view.))
(assert (=> (fuel_bool fuel%vstd!view.impl&%20.view.) (forall ((self! Poly)) (! (= (vstd!view.View.view.? $ (UINT 64) self!) self!) :pattern ((vstd!view.View.view.? $ (UINT 64) self!)) ))))
(set-info :comment ";; Function-Axioms vstd::view::impl&%22::view")
(assert (fuel_bool_default fuel%vstd!view.impl&%22.view.))
(assert (=> (fuel_bool fuel%vstd!view.impl&%22.view.) (forall ((self! Poly)) (! (= (vstd!view.View.view.? $ (UINT 128) self!) self!) :pattern ((vstd!view.View.view.? $ (UINT 128) self!)) ))))
(set-info :comment ";; Function-Axioms vstd::view::impl&%24::view")
(assert (fuel_bool_default fuel%vstd!view.impl&%24.view.))
(assert (=> (fuel_bool fuel%vstd!view.impl&%24.view.) (forall ((self! Poly)) (! (= (vstd!view.View.view.? $ (UINT SZ) self!) self!) :pattern ((vstd!view.View.view.? $ (UINT SZ) self!)) ))))
(set-info :comment ";; Function-Axioms vstd::view::impl&%42::view")
(assert (fuel_bool_default fuel%vstd!view.impl&%42.view.))
(assert (=> (fuel_bool fuel%vstd!view.impl&%42.view.) (forall ((A0&. Dcr) (A0& Type) (A1&. Dcr) (A1& Type) (self! Poly)) (! (=> (and (tr_bound%vstd!view.View. A0&. A0&) (tr_bound%vstd!view.View. A1&. A1&)) (= (vstd!view.View.view.? $ (TYPE%tuple%2. A0&. A0& A1&. A1&) self!) (Poly%tuple%2. (tuple%2./tuple%2 (vstd!view.View.view.? A0&. A0& (tuple%2./tuple%2/0 (%Poly%tuple%2. self!))) (vstd!view.View.view.? A1&. A1& (tuple%2./tuple%2/1 (%Poly%tuple%2. self!))))))) :pattern ((vstd!view.View.view.? $ (TYPE%tuple%2. A0&. A0& A1&. A1&) self!)) ))))
(set-info :comment ";; Function-Axioms vstd::view::impl&%44::view")
(assert (fuel_bool_default fuel%vstd!view.impl&%44.view.))
(assert (=> (fuel_bool fuel%vstd!view.impl&%44.view.) (forall ((A0&. Dcr) (A0& Type) (A1&. Dcr) (A1& Type) (A2&. Dcr) (A2& Type) (self! Poly)) (! (=> (and (tr_bound%vstd!view.View. A0&. A0&) (tr_bound%vstd!view.View. A1&. A1&) (tr_bound%vstd!view.View. A2&. A2&)) (= (vstd!view.View.view.? $ (TYPE%tuple%3. A0&. A0& A1&. A1& A2&. A2&) self!) (Poly%tuple%3. (tuple%3./tuple%3 (vstd!view.View.view.? A0&. A0& (tuple%3./tuple%3/0 (%Poly%tuple%3. self!))) (vstd!view.View.view.? A1&. A1& (tuple%3./tuple%3/1 (%Poly%tuple%3. self!))) (vstd!view.View.view.? A2&. A2& (tuple%3./tuple%3/2 (%Poly%tuple%3. self!))))))) :pattern ((vstd!view.View.view.? $ (TYPE%tuple%3. A0&. A0& A1&. A1& A2&. A2&) self!)) ))))
(set-info :comment ";; Function-Axioms lib::kv::durable::durablespec_t::DurableKvStoreView::matches_volatile_index")
(assert (fuel_bool_default fuel%lib!kv.durable.durablespec_t.impl&%2.matches_volatile_index.))
(assert (=> (fuel_bool fuel%lib!kv.durable.durablespec_t.impl&%2.matches_volatile_index.) (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly) (volatile_index! Poly)) (! (= (lib!kv.durable.durablespec_t.impl&%2.matches_volatile_index.? K&. K& I&. I& L&. L& E&. E& self! volatile_index!) (and (and (and (and (and (= (lib!kv.durable.durablespec_t.impl&%2.len.? K&. K& I&. I& L&. L& E&. E& self!) (lib!kv.volatile.volatilespec_t.impl&%1.len.? K&. K& volatile_index!)) (vstd!set.impl&%0.finite.? $ INT (vstd!map.impl&%0.dom.? $ INT $ (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. K&. K& I&. I& L&. L&) (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/contents (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. self!))))) (vstd!set.impl&%0.finite.? K&. K& (vstd!map.impl&%0.dom.? K&. K& $ TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (lib!kv.volatile.volatilespec_t.VolatileKvIndexView./VolatileKvIndexView/contents (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. volatile_index!))))) (lib!kv.durable.durablespec_t.impl&%2.valid.? K&. K& I&. I& L&. L& E&. E& self!)) (forall ((k$ Poly)) (! (=> (has_type k$ K&) (=> (lib!kv.volatile.volatilespec_t.impl&%1.contains_key.? K&. K& volatile_index! k$) (let ((indexed_offset$ (lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry/item_offset (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. (lib!kv.volatile.volatilespec_t.impl&%1.spec_index.? K&. K& volatile_index! k$)))))))) (and (vstd!set.impl&%0.contains.? $ INT (vstd!map.impl&%0.dom.? $ INT K&. K& (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/index_to_key_map (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. self!))) (I indexed_offset$)) (= (vstd!map.impl&%0.index.? $ INT K&. K& (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/index_to_key_map (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. self!)) (I indexed_offset$)) k$))))) :pattern ((lib!kv.volatile.volatilespec_t.impl&%1.contains_key.? K&. K& volatile_index! k$)) ))) (forall ((i$ Poly)) (! (=> (has_type i$ INT) (=> (lib!kv.durable.durablespec_t.impl&%2.contains_key.? K&. K& I&. I& L&. L& E&. E& self! i$) (and (and (vstd!set.impl&%0.contains.? $ INT (vstd!map.impl&%0.dom.? $ INT K&. K& (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/index_to_key_map (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. self!))) i$) (lib!kv.volatile.volatilespec_t.impl&%1.contains_key.? K&. K& volatile_index! (vstd!map.impl&%0.index.? $ INT K&. K& (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/index_to_key_map (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. self!)) i$))) (= (lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry/item_offset (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. (lib!kv.volatile.volatilespec_t.impl&%1.spec_index.? K&. K& volatile_index! (vstd!map.impl&%0.index.? $ INT K&. K& (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/index_to_key_map (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. self!)) i$))))))) (%I i$))))) :pattern ((vstd!set.impl&%0.contains.? $ INT (vstd!map.impl&%0.dom.? $ INT K&. K& (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/index_to_key_map (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. self!))) i$)) )))) :pattern ((lib!kv.durable.durablespec_t.impl&%2.matches_volatile_index.? K&. K& I&. I& L&. L& E&. E& self! volatile_index!)) ))))
(set-info :comment ";; Function-Axioms lib::kv::kvspec_t::AbstractKvStoreState::construct_view_contents")
(assert (fuel_bool_default fuel%lib!kv.kvspec_t.impl&%2.construct_view_contents.))
(declare-fun %%lambda%%6 (Dcr Type Poly) %%Function%%)
(assert (forall ((%%hole%%0 Dcr) (%%hole%%1 Type) (%%hole%%2 Poly) (k$ Poly)) (! (= (%%apply%%0 (%%lambda%%6 %%hole%%0 %%hole%%1 %%hole%%2) k$) (B (lib!kv.volatile.volatilespec_t.impl&%1.contains_key.? %%hole%%0 %%hole%%1 %%hole%%2 k$))) :pattern ((%%apply%%0 (%%lambda%%6 %%hole%%0 %%hole%%1 %%hole%%2) k$)))))
(declare-fun %%lambda%%7 (Dcr Type Poly Dcr Type Dcr Type Dcr Type Dcr Type Poly Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type) %%Function%%)
(assert (forall ((%%hole%%0 Dcr) (%%hole%%1 Type) (%%hole%%2 Poly) (%%hole%%3 Dcr) (%%hole%%4 Type) (%%hole%%5 Dcr) (%%hole%%6 Type) (%%hole%%7 Dcr) (%%hole%%8 Type) (%%hole%%9 Dcr) (%%hole%%10 Type) (%%hole%%11 Poly) (%%hole%%12 Dcr) (%%hole%%13 Type) (%%hole%%14 Dcr) (%%hole%%15 Type) (%%hole%%16 Dcr) (%%hole%%17 Type) (%%hole%%18 Dcr) (%%hole%%19 Type) (%%hole%%20 Dcr) (%%hole%%21 Type) (%%hole%%22 Dcr) (%%hole%%23 Type) (k$ Poly)) (! (= (%%apply%%0 (%%lambda%%7 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5 %%hole%%6 %%hole%%7 %%hole%%8 %%hole%%9 %%hole%%10 %%hole%%11 %%hole%%12 %%hole%%13 %%hole%%14 %%hole%%15 %%hole%%16 %%hole%%17 %%hole%%18 %%hole%%19 %%hole%%20 %%hole%%21 %%hole%%22 %%hole%%23) k$) (Poly%tuple%2. (let ((index_entry$ (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. (lib!kv.volatile.volatilespec_t.impl&%1.spec_index.? %%hole%%0 %%hole%%1 %%hole%%2 k$))))))) (let ((durable_entry$ (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. (lib!kv.durable.durablespec_t.impl&%2.spec_index.? %%hole%%3 %%hole%%4 %%hole%%5 %%hole%%6 %%hole%%7 %%hole%%8 %%hole%%9 %%hole%%10 %%hole%%11 (I (lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry./VolatileKvIndexEntry/item_offset (%Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. (Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexEntry. index_entry$))))))))))) (tuple%2./tuple%2 (lib!kv.durable.durablespec_t.impl&%1.item.? %%hole%%12 %%hole%%13 %%hole%%14 %%hole%%15 %%hole%%16 %%hole%%17 (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. durable_entry$)) (lib!kv.durable.durablespec_t.DurableKvStoreList./DurableKvStoreList/list (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (Poly%lib!kv.durable.durablespec_t.DurableKvStoreList. (lib!kv.durable.durablespec_t.impl&%1.list.? %%hole%%18 %%hole%%19 %%hole%%20 %%hole%%21 %%hole%%22 %%hole%%23 (Poly%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. durable_entry$)))))))))) :pattern ((%%apply%%0 (%%lambda%%7 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5 %%hole%%6 %%hole%%7 %%hole%%8 %%hole%%9 %%hole%%10 %%hole%%11 %%hole%%12 %%hole%%13 %%hole%%14 %%hole%%15 %%hole%%16 %%hole%%17 %%hole%%18 %%hole%%19 %%hole%%20 %%hole%%21 %%hole%%22 %%hole%%23) k$)))))
(assert (=> (fuel_bool fuel%lib!kv.kvspec_t.impl&%2.construct_view_contents.) (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (volatile_store_state! Poly) (durable_store_state! Poly)) (! (= (lib!kv.kvspec_t.impl&%2.construct_view_contents.? K&. K& I&. I& L&. L& E&. E& volatile_store_state! durable_store_state!) (vstd!map.impl&%0.new.? K&. K& $ (TYPE%tuple%2. I&. I& $ (TYPE%vstd!seq.Seq. L&. L&)) $ (TYPE%fun%1. K&. K& $ BOOL) $ (TYPE%fun%1. K&. K& $ (TYPE%tuple%2. I&. I& $ (TYPE%vstd!seq.Seq. L&. L&))) (Poly%fun%1. (mk_fun (%%lambda%%6 K&. K& volatile_store_state!))) (Poly%fun%1. (mk_fun (%%lambda%%7 K&. K& volatile_store_state! K&. K& I&. I& L&. L& E&. E& durable_store_state! K&. K& I&. I& L&. L& K&. K& I&. I& L&. L&))))) :pattern ((lib!kv.kvspec_t.impl&%2.construct_view_contents.? K&. K& I&. I& L&. L& E&. E& volatile_store_state! durable_store_state!)) ))))
(assert (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (volatile_store_state! Poly) (durable_store_state! Poly)) (! (=> (and (has_type volatile_store_state! (TYPE%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. K&. K&)) (has_type durable_store_state! (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreView. K&. K& I&. I& L&. L& E&. E&))) (has_type (lib!kv.kvspec_t.impl&%2.construct_view_contents.? K&. K& I&. I& L&. L& E&. E& volatile_store_state! durable_store_state!) (TYPE%vstd!map.Map. K&. K& $ (TYPE%tuple%2. I&. I& $ (TYPE%vstd!seq.Seq. L&. L&))))) :pattern ((lib!kv.kvspec_t.impl&%2.construct_view_contents.? K&. K& I&. I& L&. L& E&. E& volatile_store_state! durable_store_state!)) )))
(set-info :comment ";; Function-Axioms lib::kv::kvimpl_v::UntrustedKvStoreImpl::view")
(assert (fuel_bool_default fuel%lib!kv.kvimpl_v.impl&%0.view.))
(assert (=> (fuel_bool fuel%lib!kv.kvimpl_v.impl&%0.view.) (forall ((PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (D&. Dcr) (D& Type) (V&. Dcr) (V& Type) (E&. Dcr) (E& Type) (self! Poly)) (! (= (lib!kv.kvimpl_v.impl&%0.view.? PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& self!) (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState (%I (I (lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/id (%Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. self!)))) (lib!kv.kvspec_t.impl&%2.construct_view_contents.? K&. K& I&. I& L&. L& E&. E& (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? V&. V& K&. K& E&. E& (lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/volatile_index (%Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. self!))) (lib!kv.durable.durableimpl_v.DurableKvStore.view.? D&. D& PM&. PM& K&. K& I&. I& L&. L& E&. E& (lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/durable_store (%Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. self!)))) (%Poly%core!option.Option. (Poly%core!option.Option. core!option.Option./None)))) :pattern ((lib!kv.kvimpl_v.impl&%0.view.? PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& self!)) ))))
(assert (forall ((PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (D&. Dcr) (D& Type) (V&. Dcr) (V& Type) (E&. Dcr) (E& Type) (self! Poly)) (! (=> (has_type self! (TYPE%lib!kv.kvimpl_v.UntrustedKvStoreImpl. PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E&)) (has_type (Poly%lib!kv.kvspec_t.AbstractKvStoreState. (lib!kv.kvimpl_v.impl&%0.view.? PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& self!)) (TYPE%lib!kv.kvspec_t.AbstractKvStoreState. K&. K& I&. I& L&. L& E&. E&))) :pattern ((lib!kv.kvimpl_v.impl&%0.view.? PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& self!)) )))
(set-info :comment ";; Function-Axioms lib::kv::kvimpl_v::UntrustedKvStoreImpl::valid")
(assert (fuel_bool_default fuel%lib!kv.kvimpl_v.impl&%0.valid.))
(assert (=> (fuel_bool fuel%lib!kv.kvimpl_v.impl&%0.valid.) (forall ((PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (D&. Dcr) (D& Type) (V&. Dcr) (V& Type) (E&. Dcr) (E& Type) (self! Poly)) (! (= (lib!kv.kvimpl_v.impl&%0.valid.? PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& self!) (and (and (lib!kv.durable.durablespec_t.impl&%2.matches_volatile_index.? K&. K& I&. I& L&. L& E&. E& (lib!kv.durable.durableimpl_v.DurableKvStore.view.? D&. D& PM&. PM& K&. K& I&. I& L&. L& E&. E& (lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/durable_store (%Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. self!))) (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? V&. V& K&. K& E&. E& (lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/volatile_index (%Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. self!)))) (%B (lib!kv.durable.durableimpl_v.DurableKvStore.valid.? D&. D& PM&. PM& K&. K& I&. I& L&. L& E&. E& (lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/durable_store (%Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. self!))))) (%B (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.valid.? V&. V& K&. K& E&. E& (lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/volatile_index (%Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. self!)))))) :pattern ((lib!kv.kvimpl_v.impl&%0.valid.? PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& self!)) ))))
(set-info :comment ";; Function-Axioms lib::kv::kvimpl_v::UntrustedKvStoreImpl::recover")
(assert (fuel_bool_default fuel%lib!kv.kvimpl_v.impl&%0.recover.))
(assert (=> (fuel_bool fuel%lib!kv.kvimpl_v.impl&%0.recover.) (forall ((PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (D&. Dcr) (D& Type) (V&. Dcr) (V& Type) (E&. Dcr) (E& Type) (mems! Poly) (kv_id! Poly)) (! (= (lib!kv.kvimpl_v.impl&%0.recover.? PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& mems! kv_id!) core!option.Option./None) :pattern ((lib!kv.kvimpl_v.impl&%0.recover.? PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& mems! kv_id!)) ))))
(assert (forall ((PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (D&. Dcr) (D& Type) (V&. Dcr) (V& Type) (E&. Dcr) (E& Type) (mems! Poly) (kv_id! Poly)) (! (=> (and (has_type mems! (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ (UINT 8)))) (has_type kv_id! (UINT 128))) (has_type (Poly%core!option.Option. (lib!kv.kvimpl_v.impl&%0.recover.? PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& mems! kv_id!)) (TYPE%core!option.Option. $ (TYPE%lib!kv.kvspec_t.AbstractKvStoreState. K&. K& I&. I& L&. L& E&. E&)))) :pattern ((lib!kv.kvimpl_v.impl&%0.recover.? PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& mems! kv_id!)) )))
(set-info :comment ";; Function-Axioms lib::kv::kvspec_t::AbstractKvStoreState::spec_index")
(assert (fuel_bool_default fuel%lib!kv.kvspec_t.impl&%2.spec_index.))
(assert (=> (fuel_bool fuel%lib!kv.kvspec_t.impl&%2.spec_index.) (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly) (key! Poly)) (! (= (lib!kv.kvspec_t.impl&%2.spec_index.? K&. K& I&. I& L&. L& E&. E& self! key!) (ite (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& $ (TYPE%tuple%2. I&. I& $ (TYPE%vstd!seq.Seq. L&. L&)) (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/contents (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. self!))) key!) (core!option.Option./Some (vstd!map.impl&%0.index.? K&. K& $ (TYPE%tuple%2. I&. I& $ (TYPE%vstd!seq.Seq. L&. L&)) (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/contents (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. self!)) key!)) core!option.Option./None)) :pattern ((lib!kv.kvspec_t.impl&%2.spec_index.? K&. K& I&. I& L&. L& E&. E& self! key!)) ))))
(assert (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly) (key! Poly)) (! (=> (and (has_type self! (TYPE%lib!kv.kvspec_t.AbstractKvStoreState. K&. K& I&. I& L&. L& E&. E&)) (has_type key! K&)) (has_type (Poly%core!option.Option. (lib!kv.kvspec_t.impl&%2.spec_index.? K&. K& I&. I& L&. L& E&. E& self! key!)) (TYPE%core!option.Option. $ (TYPE%tuple%2. I&. I& $ (TYPE%vstd!seq.Seq. L&. L&))))) :pattern ((lib!kv.kvspec_t.impl&%2.spec_index.? K&. K& I&. I& L&. L& E&. E& self! key!)) )))
(set-info :comment ";; Function-Axioms lib::kv::kvspec_t::AbstractKvStoreState::empty")
(assert (fuel_bool_default fuel%lib!kv.kvspec_t.impl&%2.empty.))
(assert (=> (fuel_bool fuel%lib!kv.kvspec_t.impl&%2.empty.) (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly)) (! (= (lib!kv.kvspec_t.impl&%2.empty.? K&. K& I&. I& L&. L& E&. E& self!) (vstd!set_lib.impl&%0.is_empty.? K&. K& (vstd!map.impl&%0.dom.? K&. K& $ (TYPE%tuple%2. I&. I& $ (TYPE%vstd!seq.Seq. L&. L&)) (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/contents (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. self!))))) :pattern ((lib!kv.kvspec_t.impl&%2.empty.? K&. K& I&. I& L&. L& E&. E& self!)) ))))
(set-info :comment ";; Function-Axioms lib::kv::kvspec_t::AbstractKvStoreState::create")
(assert (fuel_bool_default fuel%lib!kv.kvspec_t.impl&%2.create.))
(assert (=> (fuel_bool fuel%lib!kv.kvspec_t.impl&%2.create.) (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly) (key! Poly) (item! Poly)) (! (= (lib!kv.kvspec_t.impl&%2.create.? K&. K& I&. I& L&. L& E&. E& self! key! item!) (ite (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& $ (TYPE%tuple%2. I&. I& $ (TYPE%vstd!seq.Seq. L&. L&)) (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/contents (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. self!))) key!) (core!result.Result./Err (Poly%lib!kv.kvimpl_t.KvError. lib!kv.kvimpl_t.KvError./KeyAlreadyExists)) (core!result.Result./Ok (Poly%lib!kv.kvspec_t.AbstractKvStoreState. (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState (%I (I (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/id (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. self!)))) (vstd!map.impl&%0.insert.? K&. K& $ (TYPE%tuple%2. I&. I& $ (TYPE%vstd!seq.Seq. L&. L&)) (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/contents (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. self!)) key! (Poly%tuple%2. (tuple%2./tuple%2 item! (vstd!seq.Seq.empty.? L&. L&)))) (%Poly%core!option.Option. (Poly%core!option.Option. core!option.Option./None))))))) :pattern ((lib!kv.kvspec_t.impl&%2.create.? K&. K& I&. I& L&. L& E&. E& self! key! item!)) ))))
(assert (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly) (key! Poly) (item! Poly)) (! (=> (and (has_type self! (TYPE%lib!kv.kvspec_t.AbstractKvStoreState. K&. K& I&. I& L&. L& E&. E&)) (has_type key! K&) (has_type item! I&)) (has_type (Poly%core!result.Result. (lib!kv.kvspec_t.impl&%2.create.? K&. K& I&. I& L&. L& E&. E& self! key! item!)) (TYPE%core!result.Result. $ (TYPE%lib!kv.kvspec_t.AbstractKvStoreState. K&. K& I&. I& L&. L& E&. E&) $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&)))) :pattern ((lib!kv.kvspec_t.impl&%2.create.? K&. K& I&. I& L&. L& E&. E& self! key! item!)) )))
(set-info :comment ";; Function-Axioms lib::kv::kvspec_t::AbstractKvStoreState::read_item_and_list")
(assert (fuel_bool_default fuel%lib!kv.kvspec_t.impl&%2.read_item_and_list.))
(assert (=> (fuel_bool fuel%lib!kv.kvspec_t.impl&%2.read_item_and_list.) (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly) (key! Poly)) (! (= (lib!kv.kvspec_t.impl&%2.read_item_and_list.? K&. K& I&. I& L&. L& E&. E& self! key!) (ite (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& $ (TYPE%tuple%2. I&. I& $ (TYPE%vstd!seq.Seq. L&. L&)) (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/contents (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. self!))) key!) (core!option.Option./Some (vstd!map.impl&%0.index.? K&. K& $ (TYPE%tuple%2. I&. I& $ (TYPE%vstd!seq.Seq. L&. L&)) (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/contents (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. self!)) key!)) core!option.Option./None)) :pattern ((lib!kv.kvspec_t.impl&%2.read_item_and_list.? K&. K& I&. I& L&. L& E&. E& self! key!)) ))))
(assert (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly) (key! Poly)) (! (=> (and (has_type self! (TYPE%lib!kv.kvspec_t.AbstractKvStoreState. K&. K& I&. I& L&. L& E&. E&)) (has_type key! K&)) (has_type (Poly%core!option.Option. (lib!kv.kvspec_t.impl&%2.read_item_and_list.? K&. K& I&. I& L&. L& E&. E& self! key!)) (TYPE%core!option.Option. $ (TYPE%tuple%2. I&. I& $ (TYPE%vstd!seq.Seq. L&. L&))))) :pattern ((lib!kv.kvspec_t.impl&%2.read_item_and_list.? K&. K& I&. I& L&. L& E&. E& self! key!)) )))
(set-info :comment ";; Function-Axioms lib::kv::kvspec_t::AbstractKvStoreState::read_list_entry_at_index")
(assert (fuel_bool_default fuel%lib!kv.kvspec_t.impl&%2.read_list_entry_at_index.))
(assert (=> (fuel_bool fuel%lib!kv.kvspec_t.impl&%2.read_list_entry_at_index.) (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly) (key! Poly) (idx! Poly)) (! (= (lib!kv.kvspec_t.impl&%2.read_list_entry_at_index.? K&. K& I&. I& L&. L& E&. E& self! key! idx!) (ite (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& $ (TYPE%tuple%2. I&. I& $ (TYPE%vstd!seq.Seq. L&. L&)) (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/contents (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. self!))) key!) (let ((tmp%%$ (%Poly%tuple%2. (vstd!map.impl&%0.index.? K&. K& $ (TYPE%tuple%2. I&. I& $ (TYPE%vstd!seq.Seq. L&. L&)) (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/contents (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. self!)) key!)))) (let ((offset$ (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))) (let ((list$ (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))) (ite (> (vstd!seq.Seq.len.? L&. L& list$) (%I idx!)) (core!result.Result./Ok (vstd!seq.Seq.index.? L&. L& list$ idx!)) (core!result.Result./Err (Poly%lib!kv.kvimpl_t.KvError. lib!kv.kvimpl_t.KvError./IndexOutOfRange)))))) (core!result.Result./Err (Poly%lib!kv.kvimpl_t.KvError. lib!kv.kvimpl_t.KvError./KeyNotFound)))) :pattern ((lib!kv.kvspec_t.impl&%2.read_list_entry_at_index.? K&. K& I&. I& L&. L& E&. E& self! key! idx!)) ))))
(assert (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly) (key! Poly) (idx! Poly)) (! (=> (and (has_type self! (TYPE%lib!kv.kvspec_t.AbstractKvStoreState. K&. K& I&. I& L&. L& E&. E&)) (has_type key! K&) (has_type idx! INT)) (has_type (Poly%core!result.Result. (lib!kv.kvspec_t.impl&%2.read_list_entry_at_index.? K&. K& I&. I& L&. L& E&. E& self! key! idx!)) (TYPE%core!result.Result. L&. L& $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&)))) :pattern ((lib!kv.kvspec_t.impl&%2.read_list_entry_at_index.? K&. K& I&. I& L&. L& E&. E& self! key! idx!)) )))
(set-info :comment ";; Function-Axioms lib::kv::kvspec_t::AbstractKvStoreState::update_item")
(assert (fuel_bool_default fuel%lib!kv.kvspec_t.impl&%2.update_item.))
(assert (=> (fuel_bool fuel%lib!kv.kvspec_t.impl&%2.update_item.) (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly) (key! Poly) (new_item! Poly)) (! (= (lib!kv.kvspec_t.impl&%2.update_item.? K&. K& I&. I& L&. L& E&. E& self! key! new_item!) (let ((val$ (lib!kv.kvspec_t.impl&%2.read_item_and_list.? K&. K& I&. I& L&. L& E&. E& self! key!))) (ite (and (is-core!option.Option./Some_ val$) (is-tuple%2./tuple%2_ (%Poly%tuple%2. (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. val$)))))) (let ((old_item$ (tuple%2./tuple%2/0 (%Poly%tuple%2. (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. val$))))))) (let ((pages$ (tuple%2./tuple%2/1 (%Poly%tuple%2. (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. val$))))))) (core!result.Result./Ok (Poly%lib!kv.kvspec_t.AbstractKvStoreState. (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState (%I (I (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/id (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. self!)))) (vstd!map.impl&%0.insert.? K&. K& $ (TYPE%tuple%2. I&. I& $ (TYPE%vstd!seq.Seq. L&. L&)) (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/contents (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. self!)) key! (Poly%tuple%2. (tuple%2./tuple%2 new_item! pages$))) (%Poly%core!option.Option. (Poly%core!option.Option. core!option.Option./None))))))) (core!result.Result./Err (Poly%lib!kv.kvimpl_t.KvError. lib!kv.kvimpl_t.KvError./KeyNotFound))))) :pattern ((lib!kv.kvspec_t.impl&%2.update_item.? K&. K& I&. I& L&. L& E&. E& self! key! new_item!)) ))))
(assert (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly) (key! Poly) (new_item! Poly)) (! (=> (and (has_type self! (TYPE%lib!kv.kvspec_t.AbstractKvStoreState. K&. K& I&. I& L&. L& E&. E&)) (has_type key! K&) (has_type new_item! I&)) (has_type (Poly%core!result.Result. (lib!kv.kvspec_t.impl&%2.update_item.? K&. K& I&. I& L&. L& E&. E& self! key! new_item!)) (TYPE%core!result.Result. $ (TYPE%lib!kv.kvspec_t.AbstractKvStoreState. K&. K& I&. I& L&. L& E&. E&) $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&)))) :pattern ((lib!kv.kvspec_t.impl&%2.update_item.? K&. K& I&. I& L&. L& E&. E& self! key! new_item!)) )))
(set-info :comment ";; Function-Axioms lib::kv::kvspec_t::AbstractKvStoreState::delete")
(assert (fuel_bool_default fuel%lib!kv.kvspec_t.impl&%2.delete.))
(assert (=> (fuel_bool fuel%lib!kv.kvspec_t.impl&%2.delete.) (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly) (key! Poly)) (! (= (lib!kv.kvspec_t.impl&%2.delete.? K&. K& I&. I& L&. L& E&. E& self! key!) (ite (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& $ (TYPE%tuple%2. I&. I& $ (TYPE%vstd!seq.Seq. L&. L&)) (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/contents (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. self!))) key!) (core!result.Result./Ok (Poly%lib!kv.kvspec_t.AbstractKvStoreState. (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState (%I (I (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/id (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. self!)))) (vstd!map.impl&%0.remove.? K&. K& $ (TYPE%tuple%2. I&. I& $ (TYPE%vstd!seq.Seq. L&. L&)) (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/contents (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. self!)) key!) (%Poly%core!option.Option. (Poly%core!option.Option. core!option.Option./None))))) (core!result.Result./Err (Poly%lib!kv.kvimpl_t.KvError. lib!kv.kvimpl_t.KvError./KeyNotFound)))) :pattern ((lib!kv.kvspec_t.impl&%2.delete.? K&. K& I&. I& L&. L& E&. E& self! key!)) ))))
(assert (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly) (key! Poly)) (! (=> (and (has_type self! (TYPE%lib!kv.kvspec_t.AbstractKvStoreState. K&. K& I&. I& L&. L& E&. E&)) (has_type key! K&)) (has_type (Poly%core!result.Result. (lib!kv.kvspec_t.impl&%2.delete.? K&. K& I&. I& L&. L& E&. E& self! key!)) (TYPE%core!result.Result. $ (TYPE%lib!kv.kvspec_t.AbstractKvStoreState. K&. K& I&. I& L&. L& E&. E&) $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&)))) :pattern ((lib!kv.kvspec_t.impl&%2.delete.? K&. K& I&. I& L&. L& E&. E& self! key!)) )))
(set-info :comment ";; Function-Axioms lib::kv::kvspec_t::AbstractKvStoreState::append_to_list")
(assert (fuel_bool_default fuel%lib!kv.kvspec_t.impl&%2.append_to_list.))
(assert (=> (fuel_bool fuel%lib!kv.kvspec_t.impl&%2.append_to_list.) (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly) (key! Poly) (new_list_entry! Poly)) (! (= (lib!kv.kvspec_t.impl&%2.append_to_list.? K&. K& I&. I& L&. L& E&. E& self! key! new_list_entry!) (let ((result$ (lib!kv.kvspec_t.impl&%2.read_item_and_list.? K&. K& I&. I& L&. L& E&. E& self! key!))) (ite (and (is-core!option.Option./Some_ result$) (is-tuple%2./tuple%2_ (%Poly%tuple%2. (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. result$)))))) (let ((item$ (tuple%2./tuple%2/0 (%Poly%tuple%2. (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. result$))))))) (let ((pages$ (tuple%2./tuple%2/1 (%Poly%tuple%2. (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. result$))))))) (core!result.Result./Ok (Poly%lib!kv.kvspec_t.AbstractKvStoreState. (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState (%I (I (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/id (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. self!)))) (vstd!map.impl&%0.insert.? K&. K& $ (TYPE%tuple%2. I&. I& $ (TYPE%vstd!seq.Seq. L&. L&)) (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/contents (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. self!)) key! (Poly%tuple%2. (tuple%2./tuple%2 item$ (vstd!seq.Seq.push.? L&. L& pages$ new_list_entry!)))) (%Poly%core!option.Option. (Poly%core!option.Option. core!option.Option./None))))))) (core!result.Result./Err (Poly%lib!kv.kvimpl_t.KvError. lib!kv.kvimpl_t.KvError./KeyNotFound))))) :pattern ((lib!kv.kvspec_t.impl&%2.append_to_list.? K&. K& I&. I& L&. L& E&. E& self! key! new_list_entry!)) ))))
(assert (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly) (key! Poly) (new_list_entry! Poly)) (! (=> (and (has_type self! (TYPE%lib!kv.kvspec_t.AbstractKvStoreState. K&. K& I&. I& L&. L& E&. E&)) (has_type key! K&) (has_type new_list_entry! L&)) (has_type (Poly%core!result.Result. (lib!kv.kvspec_t.impl&%2.append_to_list.? K&. K& I&. I& L&. L& E&. E& self! key! new_list_entry!)) (TYPE%core!result.Result. $ (TYPE%lib!kv.kvspec_t.AbstractKvStoreState. K&. K& I&. I& L&. L& E&. E&) $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&)))) :pattern ((lib!kv.kvspec_t.impl&%2.append_to_list.? K&. K& I&. I& L&. L& E&. E& self! key! new_list_entry!)) )))
(set-info :comment ";; Function-Axioms lib::kv::kvspec_t::AbstractKvStoreState::append_to_list_and_update_item")
(assert (fuel_bool_default fuel%lib!kv.kvspec_t.impl&%2.append_to_list_and_update_item.))
(assert (=> (fuel_bool fuel%lib!kv.kvspec_t.impl&%2.append_to_list_and_update_item.) (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly) (key! Poly) (new_list_entry! Poly) (new_item! Poly)) (! (= (lib!kv.kvspec_t.impl&%2.append_to_list_and_update_item.? K&. K& I&. I& L&. L& E&. E& self! key! new_list_entry! new_item!) (let ((result$ (lib!kv.kvspec_t.impl&%2.read_item_and_list.? K&. K& I&. I& L&. L& E&. E& self! key!))) (ite (and (is-core!option.Option./Some_ result$) (is-tuple%2./tuple%2_ (%Poly%tuple%2. (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. result$)))))) (let ((item$ (tuple%2./tuple%2/0 (%Poly%tuple%2. (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. result$))))))) (let ((pages$ (tuple%2./tuple%2/1 (%Poly%tuple%2. (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. result$))))))) (core!result.Result./Ok (Poly%lib!kv.kvspec_t.AbstractKvStoreState. (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState (%I (I (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/id (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. self!)))) (vstd!map.impl&%0.insert.? K&. K& $ (TYPE%tuple%2. I&. I& $ (TYPE%vstd!seq.Seq. L&. L&)) (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/contents (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. self!)) key! (Poly%tuple%2. (tuple%2./tuple%2 new_item! (vstd!seq.Seq.push.? L&. L& pages$ new_list_entry!)))) (%Poly%core!option.Option. (Poly%core!option.Option. core!option.Option./None))))))) (core!result.Result./Err (Poly%lib!kv.kvimpl_t.KvError. lib!kv.kvimpl_t.KvError./KeyNotFound))))) :pattern ((lib!kv.kvspec_t.impl&%2.append_to_list_and_update_item.? K&. K& I&. I& L&. L& E&. E& self! key! new_list_entry! new_item!)) ))))
(assert (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly) (key! Poly) (new_list_entry! Poly) (new_item! Poly)) (! (=> (and (has_type self! (TYPE%lib!kv.kvspec_t.AbstractKvStoreState. K&. K& I&. I& L&. L& E&. E&)) (has_type key! K&) (has_type new_list_entry! L&) (has_type new_item! I&)) (has_type (Poly%core!result.Result. (lib!kv.kvspec_t.impl&%2.append_to_list_and_update_item.? K&. K& I&. I& L&. L& E&. E& self! key! new_list_entry! new_item!)) (TYPE%core!result.Result. $ (TYPE%lib!kv.kvspec_t.AbstractKvStoreState. K&. K& I&. I& L&. L& E&. E&) $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&)))) :pattern ((lib!kv.kvspec_t.impl&%2.append_to_list_and_update_item.? K&. K& I&. I& L&. L& E&. E& self! key! new_list_entry! new_item!)) )))
(set-info :comment ";; Function-Axioms lib::kv::kvspec_t::AbstractKvStoreState::update_list_entry_at_index")
(assert (fuel_bool_default fuel%lib!kv.kvspec_t.impl&%2.update_list_entry_at_index.))
(assert (=> (fuel_bool fuel%lib!kv.kvspec_t.impl&%2.update_list_entry_at_index.) (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly) (key! Poly) (idx! Poly) (new_list_entry! Poly)) (! (= (lib!kv.kvspec_t.impl&%2.update_list_entry_at_index.? K&. K& I&. I& L&. L& E&. E& self! key! idx! new_list_entry!) (let ((result$ (lib!kv.kvspec_t.impl&%2.read_item_and_list.? K&. K& I&. I& L&. L& E&. E& self! key!))) (ite (and (is-core!option.Option./Some_ result$) (is-tuple%2./tuple%2_ (%Poly%tuple%2. (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. result$)))))) (let ((item$ (tuple%2./tuple%2/0 (%Poly%tuple%2. (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. result$))))))) (let ((pages$ (tuple%2./tuple%2/1 (%Poly%tuple%2. (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. result$))))))) (let ((pages$1 (vstd!seq.Seq.update.? L&. L& pages$ idx! new_list_entry!))) (core!result.Result./Ok (Poly%lib!kv.kvspec_t.AbstractKvStoreState. (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState (%I (I (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/id (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. self!)))) (vstd!map.impl&%0.insert.? K&. K& $ (TYPE%tuple%2. I&. I& $ (TYPE%vstd!seq.Seq. L&. L&)) (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/contents (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. self!)) key! (Poly%tuple%2. (tuple%2./tuple%2 item$ pages$1))) (%Poly%core!option.Option. (Poly%core!option.Option. core!option.Option./None)))))))) (core!result.Result./Err (Poly%lib!kv.kvimpl_t.KvError. lib!kv.kvimpl_t.KvError./KeyNotFound))))) :pattern ((lib!kv.kvspec_t.impl&%2.update_list_entry_at_index.? K&. K& I&. I& L&. L& E&. E& self! key! idx! new_list_entry!)) ))))
(assert (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly) (key! Poly) (idx! Poly) (new_list_entry! Poly)) (! (=> (and (has_type self! (TYPE%lib!kv.kvspec_t.AbstractKvStoreState. K&. K& I&. I& L&. L& E&. E&)) (has_type key! K&) (has_type idx! (UINT SZ)) (has_type new_list_entry! L&)) (has_type (Poly%core!result.Result. (lib!kv.kvspec_t.impl&%2.update_list_entry_at_index.? K&. K& I&. I& L&. L& E&. E& self! key! idx! new_list_entry!)) (TYPE%core!result.Result. $ (TYPE%lib!kv.kvspec_t.AbstractKvStoreState. K&. K& I&. I& L&. L& E&. E&) $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&)))) :pattern ((lib!kv.kvspec_t.impl&%2.update_list_entry_at_index.? K&. K& I&. I& L&. L& E&. E& self! key! idx! new_list_entry!)) )))
(set-info :comment ";; Function-Axioms lib::kv::kvspec_t::AbstractKvStoreState::update_entry_at_index_and_item")
(assert (fuel_bool_default fuel%lib!kv.kvspec_t.impl&%2.update_entry_at_index_and_item.))
(assert (=> (fuel_bool fuel%lib!kv.kvspec_t.impl&%2.update_entry_at_index_and_item.) (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly) (key! Poly) (idx! Poly) (new_list_entry! Poly) (new_item! Poly)) (! (= (lib!kv.kvspec_t.impl&%2.update_entry_at_index_and_item.? K&. K& I&. I& L&. L& E&. E& self! key! idx! new_list_entry! new_item!) (let ((result$ (lib!kv.kvspec_t.impl&%2.read_item_and_list.? K&. K& I&. I& L&. L& E&. E& self! key!))) (ite (and (is-core!option.Option./Some_ result$) (is-tuple%2./tuple%2_ (%Poly%tuple%2. (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. result$)))))) (let ((item$ (tuple%2./tuple%2/0 (%Poly%tuple%2. (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. result$))))))) (let ((pages$ (tuple%2./tuple%2/1 (%Poly%tuple%2. (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. result$))))))) (let ((pages$1 (vstd!seq.Seq.update.? L&. L& pages$ idx! new_list_entry!))) (core!result.Result./Ok (Poly%lib!kv.kvspec_t.AbstractKvStoreState. (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState (%I (I (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/id (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. self!)))) (vstd!map.impl&%0.insert.? K&. K& $ (TYPE%tuple%2. I&. I& $ (TYPE%vstd!seq.Seq. L&. L&)) (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/contents (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. self!)) key! (Poly%tuple%2. (tuple%2./tuple%2 new_item! pages$1))) (%Poly%core!option.Option. (Poly%core!option.Option. core!option.Option./None)))))))) (core!result.Result./Err (Poly%lib!kv.kvimpl_t.KvError. lib!kv.kvimpl_t.KvError./KeyNotFound))))) :pattern ((lib!kv.kvspec_t.impl&%2.update_entry_at_index_and_item.? K&. K& I&. I& L&. L& E&. E& self! key! idx! new_list_entry! new_item!)) ))))
(assert (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly) (key! Poly) (idx! Poly) (new_list_entry! Poly) (new_item! Poly)) (! (=> (and (has_type self! (TYPE%lib!kv.kvspec_t.AbstractKvStoreState. K&. K& I&. I& L&. L& E&. E&)) (has_type key! K&) (has_type idx! (UINT SZ)) (has_type new_list_entry! L&) (has_type new_item! I&)) (has_type (Poly%core!result.Result. (lib!kv.kvspec_t.impl&%2.update_entry_at_index_and_item.? K&. K& I&. I& L&. L& E&. E& self! key! idx! new_list_entry! new_item!)) (TYPE%core!result.Result. $ (TYPE%lib!kv.kvspec_t.AbstractKvStoreState. K&. K& I&. I& L&. L& E&. E&) $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&)))) :pattern ((lib!kv.kvspec_t.impl&%2.update_entry_at_index_and_item.? K&. K& I&. I& L&. L& E&. E& self! key! idx! new_list_entry! new_item!)) )))
(set-info :comment ";; Function-Axioms lib::kv::kvspec_t::AbstractKvStoreState::trim_list")
(assert (fuel_bool_default fuel%lib!kv.kvspec_t.impl&%2.trim_list.))
(assert (=> (fuel_bool fuel%lib!kv.kvspec_t.impl&%2.trim_list.) (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly) (key! Poly) (trim_length! Poly)) (! (= (lib!kv.kvspec_t.impl&%2.trim_list.? K&. K& I&. I& L&. L& E&. E& self! key! trim_length!) (let ((result$ (lib!kv.kvspec_t.impl&%2.read_item_and_list.? K&. K& I&. I& L&. L& E&. E& self! key!))) (ite (and (is-core!option.Option./Some_ result$) (is-tuple%2./tuple%2_ (%Poly%tuple%2. (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. result$)))))) (let ((item$ (tuple%2./tuple%2/0 (%Poly%tuple%2. (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. result$))))))) (let ((pages$ (tuple%2./tuple%2/1 (%Poly%tuple%2. (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. result$))))))) (let ((pages$1 (vstd!seq.Seq.subrange.? L&. L& pages$ trim_length! (I (vstd!seq.Seq.len.? L&. L& pages$))))) (core!result.Result./Ok (Poly%lib!kv.kvspec_t.AbstractKvStoreState. (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState (%I (I (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/id (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. self!)))) (vstd!map.impl&%0.insert.? K&. K& $ (TYPE%tuple%2. I&. I& $ (TYPE%vstd!seq.Seq. L&. L&)) (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/contents (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. self!)) key! (Poly%tuple%2. (tuple%2./tuple%2 item$ pages$1))) (%Poly%core!option.Option. (Poly%core!option.Option. core!option.Option./None)))))))) (core!result.Result./Err (Poly%lib!kv.kvimpl_t.KvError. lib!kv.kvimpl_t.KvError./KeyNotFound))))) :pattern ((lib!kv.kvspec_t.impl&%2.trim_list.? K&. K& I&. I& L&. L& E&. E& self! key! trim_length!)) ))))
(assert (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly) (key! Poly) (trim_length! Poly)) (! (=> (and (has_type self! (TYPE%lib!kv.kvspec_t.AbstractKvStoreState. K&. K& I&. I& L&. L& E&. E&)) (has_type key! K&) (has_type trim_length! INT)) (has_type (Poly%core!result.Result. (lib!kv.kvspec_t.impl&%2.trim_list.? K&. K& I&. I& L&. L& E&. E& self! key! trim_length!)) (TYPE%core!result.Result. $ (TYPE%lib!kv.kvspec_t.AbstractKvStoreState. K&. K& I&. I& L&. L& E&. E&) $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&)))) :pattern ((lib!kv.kvspec_t.impl&%2.trim_list.? K&. K& I&. I& L&. L& E&. E& self! key! trim_length!)) )))
(set-info :comment ";; Function-Axioms lib::kv::kvspec_t::AbstractKvStoreState::trim_list_and_update_item")
(assert (fuel_bool_default fuel%lib!kv.kvspec_t.impl&%2.trim_list_and_update_item.))
(assert (=> (fuel_bool fuel%lib!kv.kvspec_t.impl&%2.trim_list_and_update_item.) (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly) (key! Poly) (trim_length! Poly) (new_item! Poly)) (! (= (lib!kv.kvspec_t.impl&%2.trim_list_and_update_item.? K&. K& I&. I& L&. L& E&. E& self! key! trim_length! new_item!) (let ((result$ (lib!kv.kvspec_t.impl&%2.read_item_and_list.? K&. K& I&. I& L&. L& E&. E& self! key!))) (ite (and (is-core!option.Option./Some_ result$) (is-tuple%2./tuple%2_ (%Poly%tuple%2. (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. result$)))))) (let ((item$ (tuple%2./tuple%2/0 (%Poly%tuple%2. (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. result$))))))) (let ((pages$ (tuple%2./tuple%2/1 (%Poly%tuple%2. (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. result$))))))) (let ((pages$1 (vstd!seq.Seq.subrange.? L&. L& pages$ trim_length! (I (vstd!seq.Seq.len.? L&. L& pages$))))) (core!result.Result./Ok (Poly%lib!kv.kvspec_t.AbstractKvStoreState. (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState (%I (I (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/id (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. self!)))) (vstd!map.impl&%0.insert.? K&. K& $ (TYPE%tuple%2. I&. I& $ (TYPE%vstd!seq.Seq. L&. L&)) (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/contents (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. self!)) key! (Poly%tuple%2. (tuple%2./tuple%2 new_item! pages$1))) (%Poly%core!option.Option. (Poly%core!option.Option. core!option.Option./None)))))))) (core!result.Result./Err (Poly%lib!kv.kvimpl_t.KvError. lib!kv.kvimpl_t.KvError./KeyNotFound))))) :pattern ((lib!kv.kvspec_t.impl&%2.trim_list_and_update_item.? K&. K& I&. I& L&. L& E&. E& self! key! trim_length! new_item!)) ))))
(assert (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly) (key! Poly) (trim_length! Poly) (new_item! Poly)) (! (=> (and (has_type self! (TYPE%lib!kv.kvspec_t.AbstractKvStoreState. K&. K& I&. I& L&. L& E&. E&)) (has_type key! K&) (has_type trim_length! INT) (has_type new_item! I&)) (has_type (Poly%core!result.Result. (lib!kv.kvspec_t.impl&%2.trim_list_and_update_item.? K&. K& I&. I& L&. L& E&. E& self! key! trim_length! new_item!)) (TYPE%core!result.Result. $ (TYPE%lib!kv.kvspec_t.AbstractKvStoreState. K&. K& I&. I& L&. L& E&. E&) $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&)))) :pattern ((lib!kv.kvspec_t.impl&%2.trim_list_and_update_item.? K&. K& I&. I& L&. L& E&. E& self! key! trim_length! new_item!)) )))
(set-info :comment ";; Function-Axioms lib::kv::kvspec_t::AbstractKvStoreState::get_keys")
(assert (fuel_bool_default fuel%lib!kv.kvspec_t.impl&%2.get_keys.))
(assert (=> (fuel_bool fuel%lib!kv.kvspec_t.impl&%2.get_keys.) (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly)) (! (= (lib!kv.kvspec_t.impl&%2.get_keys.? K&. K& I&. I& L&. L& E&. E& self!) (vstd!map.impl&%0.dom.? K&. K& $ (TYPE%tuple%2. I&. I& $ (TYPE%vstd!seq.Seq. L&. L&)) (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/contents (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. self!)))) :pattern ((lib!kv.kvspec_t.impl&%2.get_keys.? K&. K& I&. I& L&. L& E&. E& self!)) ))))
(assert (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (self! Poly)) (! (=> (has_type self! (TYPE%lib!kv.kvspec_t.AbstractKvStoreState. K&. K& I&. I& L&. L& E&. E&)) (has_type (lib!kv.kvspec_t.impl&%2.get_keys.? K&. K& I&. I& L&. L& E&. E& self!) (TYPE%vstd!set.Set. K&. K&))) :pattern ((lib!kv.kvspec_t.impl&%2.get_keys.? K&. K& I&. I& L&. L& E&. E& self!)) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%lib!pmem.traits_t.PmSafe. $ (UINT 128)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type)) (! (tr_bound%vstd!view.View. $ (PTR T&. T&)) :pattern ((tr_bound%vstd!view.View. $ (PTR T&. T&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type)) (! (tr_bound%vstd!view.View. (CONST_PTR $) (PTR T&. T&)) :pattern ((tr_bound%vstd!view.View. (CONST_PTR $) (PTR T&. T&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type)) (! (tr_bound%vstd!view.View. $ (SLICE T&. T&)) :pattern ((tr_bound%vstd!view.View. $ (SLICE T&. T&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((A&. Dcr) (A& Type)) (! (=> (tr_bound%vstd!view.View. A&. A&) (tr_bound%vstd!view.View. (REF A&.) A&)) :pattern ((tr_bound%vstd!view.View. (REF A&.) A&)) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((A&. Dcr) (A& Type)) (! (=> (tr_bound%vstd!view.View. A&. A&) (tr_bound%vstd!view.View. (BOX $ ALLOCATOR_GLOBAL A&.) A&)) :pattern ((tr_bound%vstd!view.View. (BOX $ ALLOCATOR_GLOBAL A&.) A&)) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((A&. Dcr) (A& Type)) (! (=> (tr_bound%vstd!view.View. A&. A&) (tr_bound%vstd!view.View. (RC $ ALLOCATOR_GLOBAL A&.) A&)) :pattern ((tr_bound%vstd!view.View. (RC $ ALLOCATOR_GLOBAL A&.) A&)) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((A&. Dcr) (A& Type)) (! (=> (tr_bound%vstd!view.View. A&. A&) (tr_bound%vstd!view.View. (ARC $ ALLOCATOR_GLOBAL A&.) A&)) :pattern ((tr_bound%vstd!view.View. (ARC $ ALLOCATOR_GLOBAL A&.) A&)) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type) (A&. Dcr) (A& Type)) (! (=> (tr_bound%core!alloc.Allocator. A&. A&) (tr_bound%vstd!view.View. $ (TYPE%alloc!vec.Vec. T&. T& A&. A&))) :pattern ((tr_bound%vstd!view.View. $ (TYPE%alloc!vec.Vec. T&. T& A&. A&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%vstd!view.View. $ TYPE%tuple%0.))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%vstd!view.View. $ BOOL))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%vstd!view.View. $ (UINT 8)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%vstd!view.View. $ (UINT 64)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%vstd!view.View. $ (UINT 128)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%vstd!view.View. $ (UINT SZ)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((A0&. Dcr) (A0& Type) (A1&. Dcr) (A1& Type)) (! (=> (and (tr_bound%vstd!view.View. A0&. A0&) (tr_bound%vstd!view.View. A1&. A1&)) (tr_bound%vstd!view.View. $ (TYPE%tuple%2. A0&. A0& A1&. A1&))) :pattern ((tr_bound%vstd!view.View. $ (TYPE%tuple%2. A0&. A0& A1&. A1&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((A0&. Dcr) (A0& Type) (A1&. Dcr) (A1& Type) (A2&. Dcr) (A2& Type)) (! (=> (and (tr_bound%vstd!view.View. A0&. A0&) (tr_bound%vstd!view.View. A1&. A1&) (tr_bound%vstd!view.View. A2&. A2&)) (tr_bound%vstd!view.View. $ (TYPE%tuple%3. A0&. A0& A1&. A1& A2&. A2&))) :pattern ((tr_bound%vstd!view.View. $ (TYPE%tuple%3. A0&. A0& A1&. A1& A2&. A2&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type)) (! (tr_bound%vstd!std_specs.option.OptionAdditionalFns. $ (TYPE%core!option.Option. T&. T&) T&. T&) :pattern ((tr_bound%vstd!std_specs.option.OptionAdditionalFns. $ (TYPE%core!option.Option. T&. T&) T&. T&)) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type) (E&. Dcr) (E& Type)) (! (tr_bound%vstd!std_specs.result.ResultAdditionalSpecFns. $ (TYPE%core!result.Result. T&. T& E&. E&) T&. T& E&. E&) :pattern ((tr_bound%vstd!std_specs.result.ResultAdditionalSpecFns. $ (TYPE%core!result.Result. T&. T& E&. E&) T&. T& E&. E&)) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((V&. Dcr) (V& Type) (U&. Dcr) (U& Type) (T&. Dcr) (T& Type)) (! (=> (and (tr_bound%core!cmp.PartialEq. V&. V& V&. V&) (tr_bound%core!cmp.PartialEq. U&. U& U&. U&) (tr_bound%core!cmp.PartialEq. T&. T& T&. T&)) (tr_bound%core!cmp.PartialEq. $ (TYPE%tuple%3. V&. V& U&. U& T&. T&) $ (TYPE%tuple%3. V&. V& U&. U& T&. T&))) :pattern ((tr_bound%core!cmp.PartialEq. $ (TYPE%tuple%3. V&. V& U&. U& T&. T&) $ (TYPE%tuple%3. V&. V& U&. U& T&. T&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((V&. Dcr) (V& Type) (U&. Dcr) (U& Type) (T&. Dcr) (T& Type)) (! (=> (and (tr_bound%core!cmp.Eq. V&. V&) (tr_bound%core!cmp.Eq. U&. U&) (tr_bound%core!cmp.Eq. T&. T&)) (tr_bound%core!cmp.Eq. $ (TYPE%tuple%3. V&. V& U&. U& T&. T&))) :pattern ((tr_bound%core!cmp.Eq. $ (TYPE%tuple%3. V&. V& U&. U& T&. T&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((U&. Dcr) (U& Type) (T&. Dcr) (T& Type)) (! (=> (and (tr_bound%core!cmp.PartialEq. U&. U& U&. U&) (tr_bound%core!cmp.PartialEq. T&. T& T&. T&)) (tr_bound%core!cmp.PartialEq. $ (TYPE%tuple%2. U&. U& T&. T&) $ (TYPE%tuple%2. U&. U& T&. T&))) :pattern ((tr_bound%core!cmp.PartialEq. $ (TYPE%tuple%2. U&. U& T&. T&) $ (TYPE%tuple%2. U&. U& T&. T&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((U&. Dcr) (U& Type) (T&. Dcr) (T& Type)) (! (=> (and (tr_bound%core!cmp.Eq. U&. U&) (tr_bound%core!cmp.Eq. T&. T&)) (tr_bound%core!cmp.Eq. $ (TYPE%tuple%2. U&. U& T&. T&))) :pattern ((tr_bound%core!cmp.Eq. $ (TYPE%tuple%2. U&. U& T&. T&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!cmp.PartialEq. $ BOOL $ BOOL))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!cmp.Eq. $ BOOL))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!cmp.PartialEq. $ (UINT SZ) $ (UINT SZ)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!cmp.Eq. $ (UINT SZ)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!cmp.PartialEq. $ (UINT 8) $ (UINT 8)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!cmp.Eq. $ (UINT 8)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type)) (! (=> (tr_bound%core!cmp.PartialEq. T&. T& T&. T&) (tr_bound%core!cmp.PartialEq. $ (TYPE%core!option.Option. T&. T&) $ (TYPE%core!option.Option. T&. T&))) :pattern ((tr_bound%core!cmp.PartialEq. $ (TYPE%core!option.Option. T&. T&) $ (TYPE%core!option.Option. T&. T&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type)) (! (=> (tr_bound%core!cmp.Eq. T&. T&) (tr_bound%core!cmp.Eq. $ (TYPE%core!option.Option. T&. T&))) :pattern ((tr_bound%core!cmp.Eq. $ (TYPE%core!option.Option. T&. T&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!cmp.PartialEq. $ (UINT 64) $ (UINT 64)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!cmp.Eq. $ (UINT 64)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((A&. Dcr) (A& Type) (B&. Dcr) (B& Type)) (! (=> (tr_bound%core!cmp.PartialEq. A&. A& B&. B&) (tr_bound%core!cmp.PartialEq. (REF A&.) A& (REF B&.) B&)) :pattern ((tr_bound%core!cmp.PartialEq. (REF A&.) A& (REF B&.) B&)) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((A&. Dcr) (A& Type)) (! (=> (tr_bound%core!cmp.Eq. A&. A&) (tr_bound%core!cmp.Eq. (REF A&.) A&)) :pattern ((tr_bound%core!cmp.Eq. (REF A&.) A&)) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((B&. Dcr) (B& Type) (C&. Dcr) (C& Type)) (! (=> (and (tr_bound%core!cmp.PartialEq. B&. B& B&. B&) (tr_bound%core!cmp.PartialEq. C&. C& C&. C&)) (tr_bound%core!cmp.PartialEq. $ (TYPE%core!ops.control_flow.ControlFlow. B&. B& C&. C&) $ (TYPE%core!ops.control_flow.ControlFlow. B&. B& C&. C&))) :pattern ((tr_bound%core!cmp.PartialEq. $ (TYPE%core!ops.control_flow.ControlFlow. B&. B& C&. C&) $ (TYPE%core!ops.control_flow.ControlFlow. B&. B& C&. C&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((B&. Dcr) (B& Type) (C&. Dcr) (C& Type)) (! (=> (and (tr_bound%core!cmp.Eq. B&. B&) (tr_bound%core!cmp.Eq. C&. C&)) (tr_bound%core!cmp.Eq. $ (TYPE%core!ops.control_flow.ControlFlow. B&. B& C&. C&))) :pattern ((tr_bound%core!cmp.Eq. $ (TYPE%core!ops.control_flow.ControlFlow. B&. B& C&. C&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type)) (! (tr_bound%core!cmp.PartialEq. $ (TYPE%core!marker.PhantomData. T&. T&) $ (TYPE%core!marker.PhantomData. T&. T&)) :pattern ((tr_bound%core!cmp.PartialEq. $ (TYPE%core!marker.PhantomData. T&. T&) $ (TYPE%core!marker.PhantomData. T&. T&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type)) (! (tr_bound%core!cmp.Eq. $ (TYPE%core!marker.PhantomData. T&. T&)) :pattern ((tr_bound%core!cmp.Eq. $ (TYPE%core!marker.PhantomData. T&. T&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!cmp.PartialEq. $ (UINT 128) $ (UINT 128)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!cmp.Eq. $ (UINT 128)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!cmp.PartialEq. $ TYPE%tuple%0. $ TYPE%tuple%0.))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!cmp.Eq. $ TYPE%tuple%0.))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!cmp.PartialEq. $ TYPE%core!convert.Infallible. $ TYPE%core!convert.Infallible.))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!cmp.Eq. $ TYPE%core!convert.Infallible.))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type)) (! (tr_bound%core!cmp.PartialEq. $ (PTR T&. T&) $ (PTR T&. T&)) :pattern ((tr_bound%core!cmp.PartialEq. $ (PTR T&. T&) $ (PTR T&. T&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type)) (! (tr_bound%core!cmp.Eq. $ (PTR T&. T&)) :pattern ((tr_bound%core!cmp.Eq. $ (PTR T&. T&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type) (U&. Dcr) (U& Type)) (! (=> (tr_bound%core!cmp.PartialEq. T&. T& U&. U&) (tr_bound%core!cmp.PartialEq. $ (SLICE T&. T&) $ (SLICE U&. U&))) :pattern ((tr_bound%core!cmp.PartialEq. $ (SLICE T&. T&) $ (SLICE U&. U&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type)) (! (=> (tr_bound%core!cmp.Eq. T&. T&) (tr_bound%core!cmp.Eq. $ (SLICE T&. T&))) :pattern ((tr_bound%core!cmp.Eq. $ (SLICE T&. T&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type)) (! (tr_bound%core!cmp.PartialEq. (CONST_PTR $) (PTR T&. T&) (CONST_PTR $) (PTR T&. T&)) :pattern ((tr_bound%core!cmp.PartialEq. (CONST_PTR $) (PTR T&. T&) (CONST_PTR $) (PTR T&. T&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type)) (! (tr_bound%core!cmp.Eq. (CONST_PTR $) (PTR T&. T&)) :pattern ((tr_bound%core!cmp.Eq. (CONST_PTR $) (PTR T&. T&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((X&. Dcr) (X& Type) (W&. Dcr) (W& Type) (V&. Dcr) (V& Type) (U&. Dcr) (U& Type) (T&. Dcr) (T& Type)) (! (=> (and (tr_bound%core!cmp.PartialEq. X&. X& X&. X&) (tr_bound%core!cmp.PartialEq. W&. W& W&. W&) (tr_bound%core!cmp.PartialEq. V&. V& V&. V&) (tr_bound%core!cmp.PartialEq. U&. U& U&. U&) (tr_bound%core!cmp.PartialEq. T&. T& T&. T&)) (tr_bound%core!cmp.PartialEq. $ (TYPE%tuple%5. X&. X& W&. W& V&. V& U&. U& T&. T&) $ (TYPE%tuple%5. X&. X& W&. W& V&. V& U&. U& T&. T&))) :pattern ((tr_bound%core!cmp.PartialEq. $ (TYPE%tuple%5. X&. X& W&. W& V&. V& U&. U& T&. T&) $ (TYPE%tuple%5. X&. X& W&. W& V&. V& U&. U& T&. T&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((X&. Dcr) (X& Type) (W&. Dcr) (W& Type) (V&. Dcr) (V& Type) (U&. Dcr) (U& Type) (T&. Dcr) (T& Type)) (! (=> (and (tr_bound%core!cmp.Eq. X&. X&) (tr_bound%core!cmp.Eq. W&. W&) (tr_bound%core!cmp.Eq. V&. V&) (tr_bound%core!cmp.Eq. U&. U&) (tr_bound%core!cmp.Eq. T&. T&)) (tr_bound%core!cmp.Eq. $ (TYPE%tuple%5. X&. X& W&. W& V&. V& U&. U& T&. T&))) :pattern ((tr_bound%core!cmp.Eq. $ (TYPE%tuple%5. X&. X& W&. W& V&. V& U&. U& T&. T&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type) (E&. Dcr) (E& Type)) (! (=> (and (tr_bound%core!cmp.PartialEq. T&. T& T&. T&) (tr_bound%core!cmp.PartialEq. E&. E& E&. E&)) (tr_bound%core!cmp.PartialEq. $ (TYPE%core!result.Result. T&. T& E&. E&) $ (TYPE%core!result.Result. T&. T& E&. E&))) :pattern ((tr_bound%core!cmp.PartialEq. $ (TYPE%core!result.Result. T&. T& E&. E&) $ (TYPE%core!result.Result. T&. T& E&. E&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type) (E&. Dcr) (E& Type)) (! (=> (and (tr_bound%core!cmp.Eq. T&. T&) (tr_bound%core!cmp.Eq. E&. E&)) (tr_bound%core!cmp.Eq. $ (TYPE%core!result.Result. T&. T& E&. E&))) :pattern ((tr_bound%core!cmp.Eq. $ (TYPE%core!result.Result. T&. T& E&. E&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type) (U&. Dcr) (U& Type) (A1&. Dcr) (A1& Type) (A2&. Dcr) (A2& Type)) (! (=> (and (tr_bound%core!alloc.Allocator. A1&. A1&) (tr_bound%core!alloc.Allocator. A2&. A2&) (tr_bound%core!cmp.PartialEq. T&. T& U&. U&)) (tr_bound%core!cmp.PartialEq. $ (TYPE%alloc!vec.Vec. T&. T& A1&. A1&) $ (TYPE%alloc!vec.Vec. U&. U& A2&. A2&))) :pattern ((tr_bound%core!cmp.PartialEq. $ (TYPE%alloc!vec.Vec. T&. T& A1&. A1&) $ (TYPE%alloc!vec.Vec. U&. U& A2&. A2&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type) (A&. Dcr) (A& Type)) (! (=> (and (tr_bound%core!cmp.Eq. T&. T&) (tr_bound%core!alloc.Allocator. A&. A&)) (tr_bound%core!cmp.Eq. $ (TYPE%alloc!vec.Vec. T&. T& A&. A&))) :pattern ((tr_bound%core!cmp.Eq. $ (TYPE%alloc!vec.Vec. T&. T& A&. A&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!fmt.Debug. $ (UINT 128)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((U&. Dcr) (U& Type) (T&. Dcr) (T& Type)) (! (=> (and (tr_bound%core!fmt.Debug. U&. U&) (tr_bound%core!fmt.Debug. T&. T&)) (tr_bound%core!fmt.Debug. $ (TYPE%tuple%2. U&. U& T&. T&))) :pattern ((tr_bound%core!fmt.Debug. $ (TYPE%tuple%2. U&. U& T&. T&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((B&. Dcr) (B& Type) (C&. Dcr) (C& Type)) (! (=> (and (tr_bound%core!fmt.Debug. B&. B&) (tr_bound%core!fmt.Debug. C&. C&)) (tr_bound%core!fmt.Debug. $ (TYPE%core!ops.control_flow.ControlFlow. B&. B& C&. C&))) :pattern ((tr_bound%core!fmt.Debug. $ (TYPE%core!ops.control_flow.ControlFlow. B&. B& C&. C&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type)) (! (tr_bound%core!fmt.Debug. $ (PTR T&. T&)) :pattern ((tr_bound%core!fmt.Debug. $ (PTR T&. T&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!fmt.Debug. $ TYPE%core!convert.Infallible.))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type)) (! (=> (tr_bound%core!fmt.Debug. T&. T&) (tr_bound%core!fmt.Debug. $ (TYPE%core!option.Option. T&. T&))) :pattern ((tr_bound%core!fmt.Debug. $ (TYPE%core!option.Option. T&. T&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!fmt.Debug. $ (UINT SZ)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type)) (! (=> (tr_bound%core!fmt.Debug. T&. T&) (tr_bound%core!fmt.Debug. (REF T&.) T&)) :pattern ((tr_bound%core!fmt.Debug. (REF T&.) T&)) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!fmt.Debug. $ (UINT 8)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!fmt.Debug. $ TYPE%tuple%0.))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((X&. Dcr) (X& Type) (W&. Dcr) (W& Type) (V&. Dcr) (V& Type) (U&. Dcr) (U& Type) (T&. Dcr) (T& Type)) (! (=> (and (tr_bound%core!fmt.Debug. X&. X&) (tr_bound%core!fmt.Debug. W&. W&) (tr_bound%core!fmt.Debug. V&. V&) (tr_bound%core!fmt.Debug. U&. U&) (tr_bound%core!fmt.Debug. T&. T&)) (tr_bound%core!fmt.Debug. $ (TYPE%tuple%5. X&. X& W&. W& V&. V& U&. U& T&. T&))) :pattern ((tr_bound%core!fmt.Debug. $ (TYPE%tuple%5. X&. X& W&. W& V&. V& U&. U& T&. T&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type)) (! (=> (tr_bound%core!fmt.Debug. T&. T&) (tr_bound%core!fmt.Debug. $ (SLICE T&. T&))) :pattern ((tr_bound%core!fmt.Debug. $ (SLICE T&. T&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type)) (! (tr_bound%core!fmt.Debug. (CONST_PTR $) (PTR T&. T&)) :pattern ((tr_bound%core!fmt.Debug. (CONST_PTR $) (PTR T&. T&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!fmt.Debug. $ BOOL))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type)) (! (tr_bound%core!fmt.Debug. $ (TYPE%core!marker.PhantomData. T&. T&)) :pattern ((tr_bound%core!fmt.Debug. $ (TYPE%core!marker.PhantomData. T&. T&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((V&. Dcr) (V& Type) (U&. Dcr) (U& Type) (T&. Dcr) (T& Type)) (! (=> (and (tr_bound%core!fmt.Debug. V&. V&) (tr_bound%core!fmt.Debug. U&. U&) (tr_bound%core!fmt.Debug. T&. T&)) (tr_bound%core!fmt.Debug. $ (TYPE%tuple%3. V&. V& U&. U& T&. T&))) :pattern ((tr_bound%core!fmt.Debug. $ (TYPE%tuple%3. V&. V& U&. U& T&. T&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!fmt.Debug. $ (UINT 64)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type) (E&. Dcr) (E& Type)) (! (=> (and (tr_bound%core!fmt.Debug. T&. T&) (tr_bound%core!fmt.Debug. E&. E&)) (tr_bound%core!fmt.Debug. $ (TYPE%core!result.Result. T&. T& E&. E&))) :pattern ((tr_bound%core!fmt.Debug. $ (TYPE%core!result.Result. T&. T& E&. E&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type) (A&. Dcr) (A& Type)) (! (=> (and (tr_bound%core!fmt.Debug. T&. T&) (tr_bound%core!alloc.Allocator. A&. A&)) (tr_bound%core!fmt.Debug. $ (TYPE%alloc!vec.Vec. T&. T& A&. A&))) :pattern ((tr_bound%core!fmt.Debug. $ (TYPE%alloc!vec.Vec. T&. T& A&. A&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!fmt.Debug. $ ALLOCATOR_GLOBAL))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((A&. Dcr) (A& Type)) (! (=> (tr_bound%core!alloc.Allocator. A&. A&) (tr_bound%core!alloc.Allocator. (REF A&.) A&)) :pattern ((tr_bound%core!alloc.Allocator. (REF A&.) A&)) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type) (U&. Dcr) (U& Type) (A&. Dcr) (A& Type)) (! (=> (and (tr_bound%core!alloc.Allocator. A&. A&) (tr_bound%core!cmp.PartialEq. T&. T& U&. U&)) (tr_bound%core!cmp.PartialEq. (REF $) (SLICE T&. T&) $ (TYPE%alloc!vec.Vec. U&. U& A&. A&))) :pattern ((tr_bound%core!cmp.PartialEq. (REF $) (SLICE T&. T&) $ (TYPE%alloc!vec.Vec. U&. U& A&. A&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type) (U&. Dcr) (U& Type) (A&. Dcr) (A& Type)) (! (=> (and (tr_bound%core!alloc.Allocator. A&. A&) (tr_bound%core!cmp.PartialEq. T&. T& U&. U&)) (tr_bound%core!cmp.PartialEq. $ (SLICE T&. T&) $ (TYPE%alloc!vec.Vec. U&. U& A&. A&))) :pattern ((tr_bound%core!cmp.PartialEq. $ (SLICE T&. T&) $ (TYPE%alloc!vec.Vec. U&. U& A&. A&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type) (U&. Dcr) (U& Type) (A&. Dcr) (A& Type)) (! (=> (and (tr_bound%core!alloc.Allocator. A&. A&) (tr_bound%core!cmp.PartialEq. T&. T& U&. U&)) (tr_bound%core!cmp.PartialEq. $ (TYPE%alloc!vec.Vec. T&. T& A&. A&) $ (SLICE U&. U&))) :pattern ((tr_bound%core!cmp.PartialEq. $ (TYPE%alloc!vec.Vec. T&. T& A&. A&) $ (SLICE U&. U&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type) (U&. Dcr) (U& Type) (A&. Dcr) (A& Type)) (! (=> (and (tr_bound%core!alloc.Allocator. A&. A&) (tr_bound%core!cmp.PartialEq. T&. T& U&. U&)) (tr_bound%core!cmp.PartialEq. $ (TYPE%alloc!vec.Vec. T&. T& A&. A&) (REF $) (SLICE U&. U&))) :pattern ((tr_bound%core!cmp.PartialEq. $ (TYPE%alloc!vec.Vec. T&. T& A&. A&) (REF $) (SLICE U&. U&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!clone.Clone. $ (UINT 128)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!clone.Clone. $ (UINT 64)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!clone.Clone. $ (UINT 8)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!clone.Clone. $ (UINT SZ)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type)) (! (tr_bound%core!convert.From. T&. T& T&. T&) :pattern ((tr_bound%core!convert.From. T&. T& T&. T&)) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!convert.From. $ (UINT 128) $ (UINT 64)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!convert.From. $ (UINT 128) $ BOOL))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!convert.From. $ (UINT 128) $ (UINT 8)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!convert.From. $ (UINT 8) $ BOOL))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!convert.From. $ (UINT 64) $ BOOL))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!convert.From. $ (UINT 64) $ (UINT 8)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type)) (! (tr_bound%core!convert.From. $ (TYPE%core!option.Option. (REF T&.) T&) (REF $) (TYPE%core!option.Option. T&. T&)) :pattern ((tr_bound%core!convert.From. $ (TYPE%core!option.Option. (REF T&.) T&) (REF $) (TYPE%core!option.Option. T&. T&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type)) (! (tr_bound%core!convert.From. $ (TYPE%core!option.Option. T&. T&) T&. T&) :pattern ((tr_bound%core!convert.From. $ (TYPE%core!option.Option. T&. T&) T&. T&)) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!convert.From. $ (UINT SZ) $ (UINT 8)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!convert.From. $ (UINT SZ) $ BOOL))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type)) (! (=> (tr_bound%core!clone.Clone. T&. T&) (tr_bound%core!convert.From. $ (TYPE%alloc!vec.Vec. T&. T& $ ALLOCATOR_GLOBAL) (REF $) (SLICE T&. T&))) :pattern ((tr_bound%core!convert.From. $ (TYPE%alloc!vec.Vec. T&. T& $ ALLOCATOR_GLOBAL) (REF $) (SLICE T&. T&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type)) (! (tr_bound%core!hash.Hash. $ (TYPE%core!marker.PhantomData. T&. T&)) :pattern ((tr_bound%core!hash.Hash. $ (TYPE%core!marker.PhantomData. T&. T&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!hash.Hash. $ TYPE%core!convert.Infallible.))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type)) (! (=> (tr_bound%core!hash.Hash. T&. T&) (tr_bound%core!hash.Hash. (REF T&.) T&)) :pattern ((tr_bound%core!hash.Hash. (REF T&.) T&)) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type) (B&. Dcr) (B& Type)) (! (=> (and (tr_bound%core!hash.Hash. T&. T&) (tr_bound%core!hash.Hash. B&. B&)) (tr_bound%core!hash.Hash. $ (TYPE%tuple%2. T&. T& B&. B&))) :pattern ((tr_bound%core!hash.Hash. $ (TYPE%tuple%2. T&. T& B&. B&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!hash.Hash. $ (UINT SZ)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type)) (! (=> (tr_bound%core!hash.Hash. T&. T&) (tr_bound%core!hash.Hash. $ (TYPE%core!option.Option. T&. T&))) :pattern ((tr_bound%core!hash.Hash. $ (TYPE%core!option.Option. T&. T&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!hash.Hash. $ (UINT 128)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!hash.Hash. $ BOOL))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type) (E&. Dcr) (E& Type)) (! (=> (and (tr_bound%core!hash.Hash. T&. T&) (tr_bound%core!hash.Hash. E&. E&)) (tr_bound%core!hash.Hash. $ (TYPE%core!result.Result. T&. T& E&. E&))) :pattern ((tr_bound%core!hash.Hash. $ (TYPE%core!result.Result. T&. T& E&. E&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type) (B&. Dcr) (B& Type) (C&. Dcr) (C& Type) (D&. Dcr) (D& Type) (E&. Dcr) (E& Type)) (! (=> (and (tr_bound%core!hash.Hash. T&. T&) (tr_bound%core!hash.Hash. B&. B&) (tr_bound%core!hash.Hash. C&. C&) (tr_bound%core!hash.Hash. D&. D&) (tr_bound%core!hash.Hash. E&. E&)) (tr_bound%core!hash.Hash. $ (TYPE%tuple%5. T&. T& B&. B& C&. C& D&. D& E&. E&))) :pattern ((tr_bound%core!hash.Hash. $ (TYPE%tuple%5. T&. T& B&. B& C&. C& D&. D& E&. E&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type)) (! (tr_bound%core!hash.Hash. (CONST_PTR $) (PTR T&. T&)) :pattern ((tr_bound%core!hash.Hash. (CONST_PTR $) (PTR T&. T&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!hash.Hash. $ (UINT 8)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!hash.Hash. $ (UINT 64)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!hash.Hash. $ TYPE%tuple%0.))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type) (B&. Dcr) (B& Type) (C&. Dcr) (C& Type)) (! (=> (and (tr_bound%core!hash.Hash. T&. T&) (tr_bound%core!hash.Hash. B&. B&) (tr_bound%core!hash.Hash. C&. C&)) (tr_bound%core!hash.Hash. $ (TYPE%tuple%3. T&. T& B&. B& C&. C&))) :pattern ((tr_bound%core!hash.Hash. $ (TYPE%tuple%3. T&. T& B&. B& C&. C&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((B&. Dcr) (B& Type) (C&. Dcr) (C& Type)) (! (=> (and (tr_bound%core!hash.Hash. B&. B&) (tr_bound%core!hash.Hash. C&. C&)) (tr_bound%core!hash.Hash. $ (TYPE%core!ops.control_flow.ControlFlow. B&. B& C&. C&))) :pattern ((tr_bound%core!hash.Hash. $ (TYPE%core!ops.control_flow.ControlFlow. B&. B& C&. C&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type)) (! (=> (tr_bound%core!hash.Hash. T&. T&) (tr_bound%core!hash.Hash. $ (SLICE T&. T&))) :pattern ((tr_bound%core!hash.Hash. $ (SLICE T&. T&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type)) (! (tr_bound%core!hash.Hash. $ (PTR T&. T&)) :pattern ((tr_bound%core!hash.Hash. $ (PTR T&. T&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type) (A&. Dcr) (A& Type)) (! (=> (and (tr_bound%core!hash.Hash. T&. T&) (tr_bound%core!alloc.Allocator. A&. A&)) (tr_bound%core!hash.Hash. $ (TYPE%alloc!vec.Vec. T&. T& A&. A&))) :pattern ((tr_bound%core!hash.Hash. $ (TYPE%alloc!vec.Vec. T&. T& A&. A&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type) (E&. Dcr) (E& Type)) (! (=> (and (tr_bound%core!clone.Clone. T&. T&) (tr_bound%core!clone.Clone. E&. E&)) (tr_bound%core!clone.Clone. $ (TYPE%core!result.Result. T&. T& E&. E&))) :pattern ((tr_bound%core!clone.Clone. $ (TYPE%core!result.Result. T&. T& E&. E&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type)) (! (tr_bound%core!clone.Clone. $ (TYPE%core!marker.PhantomData. T&. T&)) :pattern ((tr_bound%core!clone.Clone. $ (TYPE%core!marker.PhantomData. T&. T&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((B&. Dcr) (B& Type) (C&. Dcr) (C& Type)) (! (=> (and (tr_bound%core!clone.Clone. B&. B&) (tr_bound%core!clone.Clone. C&. C&)) (tr_bound%core!clone.Clone. $ (TYPE%core!ops.control_flow.ControlFlow. B&. B& C&. C&))) :pattern ((tr_bound%core!clone.Clone. $ (TYPE%core!ops.control_flow.ControlFlow. B&. B& C&. C&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!clone.Clone. $ TYPE%core!convert.Infallible.))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type)) (! (tr_bound%core!clone.Clone. (CONST_PTR $) (PTR T&. T&)) :pattern ((tr_bound%core!clone.Clone. (CONST_PTR $) (PTR T&. T&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type)) (! (tr_bound%core!clone.Clone. (REF T&.) T&) :pattern ((tr_bound%core!clone.Clone. (REF T&.) T&)) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!clone.Clone. $ BOOL))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type)) (! (tr_bound%core!clone.Clone. $ (PTR T&. T&)) :pattern ((tr_bound%core!clone.Clone. $ (PTR T&. T&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type)) (! (=> (tr_bound%core!clone.Clone. T&. T&) (tr_bound%core!clone.Clone. $ (TYPE%core!option.Option. T&. T&))) :pattern ((tr_bound%core!clone.Clone. $ (TYPE%core!option.Option. T&. T&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%core!clone.Clone. $ ALLOCATOR_GLOBAL))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type) (A&. Dcr) (A& Type)) (! (=> (and (tr_bound%core!clone.Clone. T&. T&) (tr_bound%core!alloc.Allocator. A&. A&) (tr_bound%core!clone.Clone. A&. A&)) (tr_bound%core!clone.Clone. $ (TYPE%alloc!vec.Vec. T&. T& A&. A&))) :pattern ((tr_bound%core!clone.Clone. $ (TYPE%alloc!vec.Vec. T&. T& A&. A&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((A&. Dcr) (A& Type)) (! (tr_bound%core!clone.Clone. (TRACKED A&.) A&) :pattern ((tr_bound%core!clone.Clone. (TRACKED A&.) A&)) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((A&. Dcr) (A& Type)) (! (tr_bound%core!clone.Clone. (GHOST A&.) A&) :pattern ((tr_bound%core!clone.Clone. (GHOST A&.) A&)) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((T&. Dcr) (T& Type) (A&. Dcr) (A& Type)) (! (=> (and (tr_bound%core!clone.Clone. T&. T&) (tr_bound%core!alloc.Allocator. A&. A&) (tr_bound%core!clone.Clone. A&. A&)) (tr_bound%core!clone.Clone. (BOX A&. A& T&.) T&)) :pattern ((tr_bound%core!clone.Clone. (BOX A&. A& T&.) T&)) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%lib!pmem.traits_t.UnsafeSpecPmSized. $ (UINT 8)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%lib!pmem.pmcopy_t.SpecPmSized. $ (UINT 8)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%lib!pmem.traits_t.UnsafeSpecPmSized. $ (UINT 128)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%lib!pmem.pmcopy_t.SpecPmSized. $ (UINT 128)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%lib!pmem.traits_t.UnsafeSpecPmSized. $ (UINT SZ)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%lib!pmem.pmcopy_t.SpecPmSized. $ (UINT SZ)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%lib!pmem.traits_t.UnsafeSpecPmSized. $ BOOL))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%lib!pmem.pmcopy_t.SpecPmSized. $ BOOL))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((K&. Dcr) (K& Type) (E&. Dcr) (E& Type)) (! (=> (and (tr_bound%core!cmp.PartialEq. K&. K& K&. K&) (tr_bound%core!cmp.PartialEq. E&. E& E&. E&) (tr_bound%core!fmt.Debug. K&. K&) (tr_bound%core!fmt.Debug. E&. E&)) (tr_bound%core!cmp.PartialEq. $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&) $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) :pattern ((tr_bound%core!cmp.PartialEq. $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&) $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (forall ((K&. Dcr) (K& Type) (E&. Dcr) (E& Type)) (! (=> (and (tr_bound%core!clone.Clone. K&. K&) (tr_bound%core!clone.Clone. E&. E&) (tr_bound%core!fmt.Debug. K&. K&) (tr_bound%core!fmt.Debug. E&. E&)) (tr_bound%core!clone.Clone. $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) :pattern ((tr_bound%core!clone.Clone. $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) )))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%lib!pmem.traits_t.PmSafe. $ (UINT 8)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%lib!pmem.traits_t.PmSafe. $ (UINT SZ)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%lib!pmem.traits_t.PmSafe. $ BOOL))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%lib!pmem.traits_t.PmSized. $ (UINT 8)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%lib!pmem.traits_t.PmSized. $ (UINT 128)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%lib!pmem.traits_t.PmSized. $ (UINT SZ)))
(set-info :comment ";; Trait-Impl-Axiom")
(assert (tr_bound%lib!pmem.traits_t.PmSized. $ BOOL))
(set-info :comment ";; Function-Specs lib::kv::inv_v::lemma_empty_map_contains_no_keys")
(declare-fun req%lib!kv.inv_v.lemma_empty_map_contains_no_keys. (Dcr Type Dcr Type Poly) Bool)
(declare-const %%global_location_label%%29 Bool)
(declare-const %%global_location_label%%30 Bool)
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (map! Poly)) (! (= (req%lib!kv.inv_v.lemma_empty_map_contains_no_keys. K&. K& V&. V& map!) (and (=> %%global_location_label%%29 (vstd!set_lib.impl&%0.is_empty.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& map!))) (=> %%global_location_label%%30 (vstd!set.impl&%0.finite.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& map!))))) :pattern ((req%lib!kv.inv_v.lemma_empty_map_contains_no_keys. K&. K& V&. V& map!)) )))
(declare-fun ens%lib!kv.inv_v.lemma_empty_map_contains_no_keys. (Dcr Type Dcr Type Poly) Bool)
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (map! Poly)) (! (= (ens%lib!kv.inv_v.lemma_empty_map_contains_no_keys. K&. K& V&. V& map!) (forall ((k$ Poly)) (! (=> (has_type k$ K&) (not (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& map!) k$))) :pattern ((vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& map!) k$)) ))) :pattern ((ens%lib!kv.inv_v.lemma_empty_map_contains_no_keys. K&. K& V&. V& map!)) )))
(set-info :comment ";; Function-Specs lib::kv::inv_v::lemma_empty_index_matches_empty_store")
(declare-fun req%lib!kv.inv_v.lemma_empty_index_matches_empty_store. (Dcr Type Dcr Type Dcr Type Dcr Type lib!kv.durable.durablespec_t.DurableKvStoreView. lib!kv.volatile.volatilespec_t.VolatileKvIndexView.) Bool)
(declare-const %%global_location_label%%31 Bool)
(declare-const %%global_location_label%%32 Bool)
(declare-const %%global_location_label%%33 Bool)
(declare-const %%global_location_label%%34 Bool)
(assert (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (durable_store! lib!kv.durable.durablespec_t.DurableKvStoreView.) (volatile_index! lib!kv.volatile.volatilespec_t.VolatileKvIndexView.)) (! (= (req%lib!kv.inv_v.lemma_empty_index_matches_empty_store. K&. K& I&. I& L&. L& E&. E& durable_store! volatile_index!) (and (=> %%global_location_label%%31 (lib!kv.durable.durablespec_t.impl&%2.empty.? K&. K& I&. I& L&. L& E&. E& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. durable_store!))) (=> %%global_location_label%%32 (lib!kv.durable.durablespec_t.impl&%2.valid.? K&. K& I&. I& L&. L& E&. E& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. durable_store!))) (=> %%global_location_label%%33 (vstd!set.impl&%0.finite.? $ INT (vstd!map.impl&%0.dom.? $ INT $ (TYPE%lib!kv.durable.durablespec_t.DurableKvStoreViewEntry. K&. K& I&. I& L&. L&) (lib!kv.durable.durablespec_t.DurableKvStoreView./DurableKvStoreView/contents (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. (Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. durable_store!)))))) (=> %%global_location_label%%34 (lib!kv.volatile.volatilespec_t.impl&%1.empty.? K&. K& (Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. volatile_index!))))) :pattern ((req%lib!kv.inv_v.lemma_empty_index_matches_empty_store. K&. K& I&. I& L&. L& E&. E& durable_store! volatile_index!)) )))
(declare-fun ens%lib!kv.inv_v.lemma_empty_index_matches_empty_store. (Dcr Type Dcr Type Dcr Type Dcr Type lib!kv.durable.durablespec_t.DurableKvStoreView. lib!kv.volatile.volatilespec_t.VolatileKvIndexView.) Bool)
(assert (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (durable_store! lib!kv.durable.durablespec_t.DurableKvStoreView.) (volatile_index! lib!kv.volatile.volatilespec_t.VolatileKvIndexView.)) (! (= (ens%lib!kv.inv_v.lemma_empty_index_matches_empty_store. K&. K& I&. I& L&. L& E&. E& durable_store! volatile_index!) (lib!kv.durable.durablespec_t.impl&%2.matches_volatile_index.? K&. K& I&. I& L&. L& E&. E& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. durable_store!) (Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. volatile_index!))) :pattern ((ens%lib!kv.inv_v.lemma_empty_index_matches_empty_store. K&. K& I&. I& L&. L& E&. E& durable_store! volatile_index!)) )))
(set-info :comment ";; Function-Specs lib::kv::inv_v::lemma_volatile_matches_durable_after_create")
(declare-fun req%lib!kv.inv_v.lemma_volatile_matches_durable_after_create. (Dcr Type Dcr Type Dcr Type Dcr Type lib!kv.durable.durablespec_t.DurableKvStoreView. lib!kv.volatile.volatilespec_t.VolatileKvIndexView. Int Poly Poly) Bool)
(declare-const %%global_location_label%%35 Bool)
(declare-const %%global_location_label%%36 Bool)
(declare-const %%global_location_label%%37 Bool)
(declare-const %%global_location_label%%38 Bool)
(assert (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (old_durable_state! lib!kv.durable.durablespec_t.DurableKvStoreView.) (old_volatile_state! lib!kv.volatile.volatilespec_t.VolatileKvIndexView.) (offset! Int) (key! Poly) (item! Poly)) (! (= (req%lib!kv.inv_v.lemma_volatile_matches_durable_after_create. K&. K& I&. I& L&. L& E&. E& old_durable_state! old_volatile_state! offset! key! item!) (and (=> %%global_location_label%%35 (lib!kv.durable.durablespec_t.impl&%2.matches_volatile_index.? K&. K& I&. I& L&. L& E&. E& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. old_durable_state!) (Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. old_volatile_state!))) (=> %%global_location_label%%36 (is-core!option.Option./None_ (lib!kv.durable.durablespec_t.impl&%2.spec_index.? K&. K& I&. I& L&. L& E&. E& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. old_durable_state!) (I offset!)))) (=> %%global_location_label%%37 (is-core!option.Option./None_ (lib!kv.volatile.volatilespec_t.impl&%1.spec_index.? K&. K& (Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. old_volatile_state!) key!))) (=> %%global_location_label%%38 (= (lib!kv.kvimpl_t.Item.spec_key.? I&. I& K&. K& item!) key!)))) :pattern ((req%lib!kv.inv_v.lemma_volatile_matches_durable_after_create. K&. K& I&. I& L&. L& E&. E& old_durable_state! old_volatile_state! offset! key! item!)) )))
(declare-fun ens%lib!kv.inv_v.lemma_volatile_matches_durable_after_create. (Dcr Type Dcr Type Dcr Type Dcr Type lib!kv.durable.durablespec_t.DurableKvStoreView. lib!kv.volatile.volatilespec_t.VolatileKvIndexView. Int Poly Poly) Bool)
(assert (forall ((K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (E&. Dcr) (E& Type) (old_durable_state! lib!kv.durable.durablespec_t.DurableKvStoreView.) (old_volatile_state! lib!kv.volatile.volatilespec_t.VolatileKvIndexView.) (offset! Int) (key! Poly) (item! Poly)) (! (= (ens%lib!kv.inv_v.lemma_volatile_matches_durable_after_create. K&. K& I&. I& L&. L& E&. E& old_durable_state! old_volatile_state! offset! key! item!) (let ((new_durable_state$ (%Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. (core!result.Result./Ok/0 (%Poly%core!result.Result. (Poly%core!result.Result. (lib!kv.durable.durablespec_t.impl&%2.create.? K&. K& I&. I& L&. L& E&. E& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. old_durable_state!) (I offset!) item!))))))) (let ((new_volatile_state$ (lib!kv.volatile.volatilespec_t.impl&%1.insert_item_offset.? K&. K& (Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. old_volatile_state!) key! (I offset!)))) (lib!kv.durable.durablespec_t.impl&%2.matches_volatile_index.? K&. K& I&. I& L&. L& E&. E& (Poly%lib!kv.durable.durablespec_t.DurableKvStoreView. new_durable_state$) (Poly%lib!kv.volatile.volatilespec_t.VolatileKvIndexView. new_volatile_state$))))) :pattern ((ens%lib!kv.inv_v.lemma_volatile_matches_durable_after_create. K&. K& I&. I& L&. L& E&. E& old_durable_state! old_volatile_state! offset! key! item!)) )))
(set-info :comment ";; Function-Specs lib::kv::kvimpl_v::UntrustedKvStoreImpl::lemma_empty_kv")
(declare-fun req%lib!kv.kvimpl_v.impl&%0.lemma_empty_kv. (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type lib!kv.kvimpl_v.UntrustedKvStoreImpl.) Bool)
(declare-const %%global_location_label%%39 Bool)
(declare-const %%global_location_label%%40 Bool)
(assert (forall ((PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (D&. Dcr) (D& Type) (V&. Dcr) (V& Type) (E&. Dcr) (E& Type) (self! lib!kv.kvimpl_v.UntrustedKvStoreImpl.)) (! (= (req%lib!kv.kvimpl_v.impl&%0.lemma_empty_kv. PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& self!) (and (=> %%global_location_label%%39 (lib!kv.durable.durablespec_t.impl&%2.empty.? K&. K& I&. I& L&. L& E&. E& (lib!kv.durable.durableimpl_v.DurableKvStore.view.? D&. D& PM&. PM& K&. K& I&. I& L&. L& E&. E& (lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/durable_store (%Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. (Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. self!)))))) (=> %%global_location_label%%40 (lib!kv.volatile.volatilespec_t.impl&%1.empty.? K&. K& (lib!kv.volatile.volatileimpl_v.VolatileKvIndex.view.? V&. V& K&. K& E&. E& (lib!kv.kvimpl_v.UntrustedKvStoreImpl./UntrustedKvStoreImpl/volatile_index (%Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. (Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. self!)))))))) :pattern ((req%lib!kv.kvimpl_v.impl&%0.lemma_empty_kv. PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& self!)) )))
(declare-fun ens%lib!kv.kvimpl_v.impl&%0.lemma_empty_kv. (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type lib!kv.kvimpl_v.UntrustedKvStoreImpl.) Bool)
(assert (forall ((PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (D&. Dcr) (D& Type) (V&. Dcr) (V& Type) (E&. Dcr) (E& Type) (self! lib!kv.kvimpl_v.UntrustedKvStoreImpl.)) (! (= (ens%lib!kv.kvimpl_v.impl&%0.lemma_empty_kv. PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& self!) (lib!kv.kvspec_t.impl&%2.empty.? K&. K& I&. I& L&. L& E&. E& (Poly%lib!kv.kvspec_t.AbstractKvStoreState. (lib!kv.kvimpl_v.impl&%0.view.? PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& (Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. self!))))) :pattern ((ens%lib!kv.kvimpl_v.impl&%0.lemma_empty_kv. PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& self!)) )))
(set-info :comment ";; Function-Def lib::kv::kvimpl_v::UntrustedKvStoreImpl::lemma_empty_kv")
(set-info :comment ";; src/kv/kvimpl_v.rs:80:11: 80:34 (#0)")
(set-info :comment ";; Function-Specs lib::kv::kvimpl_v::UntrustedKvStoreImpl::untrusted_new")
(declare-fun ens%lib!kv.kvimpl_v.impl&%0.untrusted_new. (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Poly Int Int Int core!result.Result.) Bool)
(assert (forall ((PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (D&. Dcr) (D& Type) (V&. Dcr) (V& Type) (E&. Dcr) (E& Type) (pmem! Poly) (kvstore_id! Int) (max_keys! Int) (list_node_size! Int) (result! core!result.Result.)) (! (= (ens%lib!kv.kvimpl_v.impl&%0.untrusted_new. PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& pmem! kvstore_id! max_keys! list_node_size! result!) (and (has_type (Poly%core!result.Result. result!) (TYPE%core!result.Result. $ (TYPE%lib!kv.kvimpl_v.UntrustedKvStoreImpl. PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E&) $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) (=> (is-core!result.Result./Ok_ result!) (let ((new_kv$ (%Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. (core!result.Result./Ok/0 (%Poly%core!result.Result. (Poly%core!result.Result. result!)))))) (lib!kv.kvimpl_v.impl&%0.valid.? PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& (Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. new_kv$)))))) :pattern ((ens%lib!kv.kvimpl_v.impl&%0.untrusted_new. PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& pmem! kvstore_id! max_keys! list_node_size! result!)) )))
(set-info :comment ";; Function-Def lib::kv::kvimpl_v::UntrustedKvStoreImpl::untrusted_new")
(set-info :comment ";; src/kv/kvimpl_v.rs:98:5: 103:46 (#0)")
(set-info :comment ";; Function-Specs lib::kv::kvimpl_v::UntrustedKvStoreImpl::untrusted_contains_key")
(declare-fun req%lib!kv.kvimpl_v.impl&%0.untrusted_contains_key. (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type lib!kv.kvimpl_v.UntrustedKvStoreImpl. Poly) Bool)
(declare-const %%global_location_label%%41 Bool)
(assert (forall ((PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (D&. Dcr) (D& Type) (V&. Dcr) (V& Type) (E&. Dcr) (E& Type) (self! lib!kv.kvimpl_v.UntrustedKvStoreImpl.) (key! Poly)) (! (= (req%lib!kv.kvimpl_v.impl&%0.untrusted_contains_key. PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& self! key!) (=> %%global_location_label%%41 (lib!kv.kvimpl_v.impl&%0.valid.? PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& (Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. self!)))) :pattern ((req%lib!kv.kvimpl_v.impl&%0.untrusted_contains_key. PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& self! key!)) )))
(declare-fun ens%lib!kv.kvimpl_v.impl&%0.untrusted_contains_key. (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type lib!kv.kvimpl_v.UntrustedKvStoreImpl. Poly Bool) Bool)
(assert (forall ((PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (D&. Dcr) (D& Type) (V&. Dcr) (V& Type) (E&. Dcr) (E& Type) (self! lib!kv.kvimpl_v.UntrustedKvStoreImpl.) (key! Poly) (result! Bool)) (! (= (ens%lib!kv.kvimpl_v.impl&%0.untrusted_contains_key. PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& self! key! result!) (ite (= result! true) (is-core!option.Option./Some_ (lib!kv.kvspec_t.impl&%2.spec_index.? K&. K& I&. I& L&. L& E&. E& (Poly%lib!kv.kvspec_t.AbstractKvStoreState. (lib!kv.kvimpl_v.impl&%0.view.? PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& (Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. self!))) key!)) (is-core!option.Option./None_ (lib!kv.kvspec_t.impl&%2.spec_index.? K&. K& I&. I& L&. L& E&. E& (Poly%lib!kv.kvspec_t.AbstractKvStoreState. (lib!kv.kvimpl_v.impl&%0.view.? PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& (Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. self!))) key!)))) :pattern ((ens%lib!kv.kvimpl_v.impl&%0.untrusted_contains_key. PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& self! key! result!)) )))
(set-info :comment ";; Function-Def lib::kv::kvimpl_v::UntrustedKvStoreImpl::untrusted_contains_key")
(set-info :comment ";; src/kv/kvimpl_v.rs:554:5: 554:67 (#0)")
(set-info :comment ";; Function-Specs lib::kv::kvimpl_v::UntrustedKvStoreImpl::untrusted_create")
(declare-fun req%lib!kv.kvimpl_v.impl&%0.untrusted_create. (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type lib!kv.kvimpl_v.UntrustedKvStoreImpl. Poly Poly Poly) Bool)
(declare-const %%global_location_label%%42 Bool)
(declare-const %%global_location_label%%43 Bool)
(assert (forall ((PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (D&. Dcr) (D& Type) (V&. Dcr) (V& Type) (E&. Dcr) (E& Type) (pre%self! lib!kv.kvimpl_v.UntrustedKvStoreImpl.) (key! Poly) (item! Poly) (perm! Poly)) (! (= (req%lib!kv.kvimpl_v.impl&%0.untrusted_create. PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& pre%self! key! item! perm!) (and (=> %%global_location_label%%42 (lib!kv.kvimpl_v.impl&%0.valid.? PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& (Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. pre%self!))) (=> %%global_location_label%%43 (= key! (lib!kv.kvimpl_t.Item.spec_key.? I&. I& K&. K& item!))))) :pattern ((req%lib!kv.kvimpl_v.impl&%0.untrusted_create. PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& pre%self! key! item! perm!)) )))
(declare-fun ens%lib!kv.kvimpl_v.impl&%0.untrusted_create. (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type lib!kv.kvimpl_v.UntrustedKvStoreImpl. lib!kv.kvimpl_v.UntrustedKvStoreImpl. Poly Poly Poly core!result.Result.) Bool)
(define-fun is-lib!kv.kvimpl_t.KvError./KeyAlreadyExists_ ((c lib!kv.kvimpl_t.KvError.)) Bool ((_ is lib!kv.kvimpl_t.KvError./KeyAlreadyExists) c))
(assert (forall ((PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (D&. Dcr) (D& Type) (V&. Dcr) (V& Type) (E&. Dcr) (E& Type) (pre%self! lib!kv.kvimpl_v.UntrustedKvStoreImpl.) (self! lib!kv.kvimpl_v.UntrustedKvStoreImpl.) (key! Poly) (item! Poly) (perm! Poly) (result! core!result.Result.)) (! (= (ens%lib!kv.kvimpl_v.impl&%0.untrusted_create. PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& pre%self! self! key! item! perm! result!) (and (has_type (Poly%core!result.Result. result!) (TYPE%core!result.Result. $ TYPE%tuple%0. $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) (has_type (Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. self!) (TYPE%lib!kv.kvimpl_v.UntrustedKvStoreImpl. PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E&)) (lib!kv.kvimpl_v.impl&%0.valid.? PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& (Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. self!)) (ite (and (is-core!result.Result./Ok_ result!) (is-tuple%0./tuple%0_ (%Poly%tuple%0. (core!result.Result./Ok/0 (%Poly%core!result.Result. (Poly%core!result.Result. result!)))))) (= (lib!kv.kvimpl_v.impl&%0.view.? PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& (Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. self!)) (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. (core!result.Result./Ok/0 (%Poly%core!result.Result. (Poly%core!result.Result. (lib!kv.kvspec_t.impl&%2.create.? K&. K& I&. I& L&. L& E&. E& (Poly%lib!kv.kvspec_t.AbstractKvStoreState. (lib!kv.kvimpl_v.impl&%0.view.? PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& (Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. pre%self!))) key! item!)))))) (and (and (is-core!result.Result./Err_ result!) (is-lib!kv.kvimpl_t.KvError./KeyAlreadyExists_ (%Poly%lib!kv.kvimpl_t.KvError. (core!result.Result./Err/0 (%Poly%core!result.Result. (Poly%core!result.Result. result!)))))) (and (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& $ (TYPE%tuple%2. I&. I& $ (TYPE%vstd!seq.Seq. L&. L&)) (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/contents (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. (Poly%lib!kv.kvspec_t.AbstractKvStoreState. (lib!kv.kvimpl_v.impl&%0.view.? PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& (Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. pre%self!)))))) key!) (= (lib!kv.kvimpl_v.impl&%0.view.? PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& (Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. pre%self!)) (lib!kv.kvimpl_v.impl&%0.view.? PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& (Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. self!)))))))) :pattern ((ens%lib!kv.kvimpl_v.impl&%0.untrusted_create. PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& pre%self! self! key! item! perm! result!)) )))
(set-info :comment ";; Function-Def lib::kv::kvimpl_v::UntrustedKvStoreImpl::untrusted_create")
(set-info :comment ";; src/kv/kvimpl_v.rs:128:5: 133:44 (#0)")
(set-info :comment ";; Function-Specs lib::kv::kvimpl_v::UntrustedKvStoreImpl::untrusted_read_item")
(declare-fun req%lib!kv.kvimpl_v.impl&%0.untrusted_read_item. (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type lib!kv.kvimpl_v.UntrustedKvStoreImpl. Poly) Bool)
(declare-const %%global_location_label%%44 Bool)
(assert (forall ((PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (D&. Dcr) (D& Type) (V&. Dcr) (V& Type) (E&. Dcr) (E& Type) (self! lib!kv.kvimpl_v.UntrustedKvStoreImpl.) (key! Poly)) (! (= (req%lib!kv.kvimpl_v.impl&%0.untrusted_read_item. PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& self! key!) (=> %%global_location_label%%44 (lib!kv.kvimpl_v.impl&%0.valid.? PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& (Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. self!)))) :pattern ((req%lib!kv.kvimpl_v.impl&%0.untrusted_read_item. PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& self! key!)) )))
(declare-fun ens%lib!kv.kvimpl_v.impl&%0.untrusted_read_item. (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type lib!kv.kvimpl_v.UntrustedKvStoreImpl. Poly core!option.Option.) Bool)
(assert (forall ((PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (D&. Dcr) (D& Type) (V&. Dcr) (V& Type) (E&. Dcr) (E& Type) (self! lib!kv.kvimpl_v.UntrustedKvStoreImpl.) (key! Poly) (result! core!option.Option.)) (! (= (ens%lib!kv.kvimpl_v.impl&%0.untrusted_read_item. PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& self! key! result!) (and (has_type (Poly%core!option.Option. result!) (TYPE%core!option.Option. (REF I&.) I&)) (let ((spec_result$ (lib!kv.kvspec_t.impl&%2.read_item_and_list.? K&. K& I&. I& L&. L& E&. E& (Poly%lib!kv.kvspec_t.AbstractKvStoreState. (lib!kv.kvimpl_v.impl&%0.view.? PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& (Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. self!))) key!))) (let ((tmp%%$ (tuple%2./tuple%2 (Poly%core!option.Option. result!) (Poly%core!option.Option. spec_result$)))) (ite (and (and (is-tuple%2./tuple%2_ tmp%%$) (is-core!option.Option./Some_ (%Poly%core!option.Option. (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$)))))) (and (is-core!option.Option./Some_ (%Poly%core!option.Option. (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))) (is-tuple%2./tuple%2_ (%Poly%tuple%2. (core!option.Option./Some/0 (%Poly%core!option.Option. (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))))))) (let ((output_item$ (core!option.Option./Some/0 (%Poly%core!option.Option. (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))))) (let ((spec_item$ (tuple%2./tuple%2/0 (%Poly%tuple%2. (core!option.Option./Some/0 (%Poly%core!option.Option. (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))))))) (let ((pages$ (tuple%2./tuple%2/1 (%Poly%tuple%2. (core!option.Option./Some/0 (%Poly%core!option.Option. (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))))))) (= spec_item$ output_item$)))) (ite (and (and (is-tuple%2./tuple%2_ tmp%%$) (is-core!option.Option./Some_ (%Poly%core!option.Option. (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$)))))) (is-core!option.Option./None_ (%Poly%core!option.Option. (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$)))))) (let ((output_item$ (core!option.Option./Some/0 (%Poly%core!option.Option. (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))))) false) (=> (and (and (is-tuple%2./tuple%2_ tmp%%$) (is-core!option.Option./None_ (%Poly%core!option.Option. (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$)))))) (and (is-core!option.Option./Some_ (%Poly%core!option.Option. (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))) (is-tuple%2./tuple%2_ (%Poly%tuple%2. (core!option.Option./Some/0 (%Poly%core!option.Option. (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))))))) (let ((spec_item$ (tuple%2./tuple%2/0 (%Poly%tuple%2. (core!option.Option./Some/0 (%Poly%core!option.Option. (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))))))) (let ((pages$ (tuple%2./tuple%2/1 (%Poly%tuple%2. (core!option.Option./Some/0 (%Poly%core!option.Option. (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))))))) false))))))))) :pattern ((ens%lib!kv.kvimpl_v.impl&%0.untrusted_read_item. PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& self! key! result!)) )))
(set-info :comment ";; Function-Def lib::kv::kvimpl_v::UntrustedKvStoreImpl::untrusted_read_item")
(set-info :comment ";; src/kv/kvimpl_v.rs:176:5: 176:70 (#0)")
(set-info :comment ";; Function-Specs lib::kv::kvimpl_v::UntrustedKvStoreImpl::untrusted_read_list_entry_at_index")
(declare-fun req%lib!kv.kvimpl_v.impl&%0.untrusted_read_list_entry_at_index. (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type lib!kv.kvimpl_v.UntrustedKvStoreImpl. Poly Int) Bool)
(declare-const %%global_location_label%%45 Bool)
(assert (forall ((PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (D&. Dcr) (D& Type) (V&. Dcr) (V& Type) (E&. Dcr) (E& Type) (self! lib!kv.kvimpl_v.UntrustedKvStoreImpl.) (key! Poly) (idx! Int)) (! (= (req%lib!kv.kvimpl_v.impl&%0.untrusted_read_list_entry_at_index. PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& self! key! idx!) (=> %%global_location_label%%45 (lib!kv.kvimpl_v.impl&%0.valid.? PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& (Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. self!)))) :pattern ((req%lib!kv.kvimpl_v.impl&%0.untrusted_read_list_entry_at_index. PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& self! key! idx!)) )))
(declare-fun ens%lib!kv.kvimpl_v.impl&%0.untrusted_read_list_entry_at_index. (Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type Dcr Type lib!kv.kvimpl_v.UntrustedKvStoreImpl. Poly Int core!result.Result.) Bool)
(assert (forall ((PM&. Dcr) (PM& Type) (K&. Dcr) (K& Type) (I&. Dcr) (I& Type) (L&. Dcr) (L& Type) (D&. Dcr) (D& Type) (V&. Dcr) (V& Type) (E&. Dcr) (E& Type) (self! lib!kv.kvimpl_v.UntrustedKvStoreImpl.) (key! Poly) (idx! Int) (result! core!result.Result.)) (! (= (ens%lib!kv.kvimpl_v.impl&%0.untrusted_read_list_entry_at_index. PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& self! key! idx! result!) (and (has_type (Poly%core!result.Result. result!) (TYPE%core!result.Result. (REF L&.) L& $ (TYPE%lib!kv.kvimpl_t.KvError. K&. K& E&. E&))) (let ((spec_result$ (lib!kv.kvspec_t.impl&%2.read_list_entry_at_index.? K&. K& I&. I& L&. L& E&. E& (Poly%lib!kv.kvspec_t.AbstractKvStoreState. (lib!kv.kvimpl_v.impl&%0.view.? PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& (Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. self!))) key! (I idx!)))) (let ((tmp%%$ (tuple%2./tuple%2 (Poly%core!result.Result. result!) (Poly%core!result.Result. spec_result$)))) (ite (and (and (is-tuple%2./tuple%2_ tmp%%$) (is-core!result.Result./Ok_ (%Poly%core!result.Result. (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$)))))) (is-core!result.Result./Ok_ (%Poly%core!result.Result. (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$)))))) (let ((output_entry$ (core!result.Result./Ok/0 (%Poly%core!result.Result. (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))))) (let ((spec_entry$ (core!result.Result./Ok/0 (%Poly%core!result.Result. (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))))) (= output_entry$ spec_entry$))) (ite (and (and (is-tuple%2./tuple%2_ tmp%%$) (and (is-core!result.Result./Err_ (%Poly%core!result.Result. (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))) (is-lib!kv.kvimpl_t.KvError./IndexOutOfRange_ (%Poly%lib!kv.kvimpl_t.KvError. (core!result.Result./Err/0 (%Poly%core!result.Result. (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))))))) (and (is-core!result.Result./Err_ (%Poly%core!result.Result. (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))) (is-lib!kv.kvimpl_t.KvError./IndexOutOfRange_ (%Poly%lib!kv.kvimpl_t.KvError. (core!result.Result./Err/0 (%Poly%core!result.Result. (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))))))) (and (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& $ (TYPE%tuple%2. I&. I& $ (TYPE%vstd!seq.Seq. L&. L&)) (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/contents (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. (Poly%lib!kv.kvspec_t.AbstractKvStoreState. (lib!kv.kvimpl_v.impl&%0.view.? PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& (Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. self!)))))) key!) (<= (vstd!seq.Seq.len.? L&. L& (tuple%2./tuple%2/1 (%Poly%tuple%2. (vstd!map.impl&%0.index.? K&. K& $ (TYPE%tuple%2. I&. I& $ (TYPE%vstd!seq.Seq. L&. L&)) (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/contents (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. (Poly%lib!kv.kvspec_t.AbstractKvStoreState. (lib!kv.kvimpl_v.impl&%0.view.? PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& (Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. self!))))) key!)))) idx!)) (and (and (and (is-tuple%2./tuple%2_ tmp%%$) (and (is-core!result.Result./Err_ (%Poly%core!result.Result. (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))) (is-lib!kv.kvimpl_t.KvError./KeyNotFound_ (%Poly%lib!kv.kvimpl_t.KvError. (core!result.Result./Err/0 (%Poly%core!result.Result. (tuple%2./tuple%2/0 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))))))) (and (is-core!result.Result./Err_ (%Poly%core!result.Result. (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))) (is-lib!kv.kvimpl_t.KvError./KeyNotFound_ (%Poly%lib!kv.kvimpl_t.KvError. (core!result.Result./Err/0 (%Poly%core!result.Result. (tuple%2./tuple%2/1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%$))))))))) (not (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& $ (TYPE%tuple%2. I&. I& $ (TYPE%vstd!seq.Seq. L&. L&)) (lib!kv.kvspec_t.AbstractKvStoreState./AbstractKvStoreState/contents (%Poly%lib!kv.kvspec_t.AbstractKvStoreState. (Poly%lib!kv.kvspec_t.AbstractKvStoreState. (lib!kv.kvimpl_v.impl&%0.view.? PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& (Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. self!)))))) key!))))))))) :pattern ((ens%lib!kv.kvimpl_v.impl&%0.untrusted_read_list_entry_at_index. PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& self! key! idx! result!)) )))
(set-info :comment ";; Function-Def lib::kv::kvimpl_v::UntrustedKvStoreImpl::untrusted_read_list_entry_at_index")
(set-info :comment ";; src/kv/kvimpl_v.rs:229:5: 229:110 (#0)")
(declare-const PM&. Dcr)
(declare-const PM& Type)
(declare-const K&. Dcr)
(declare-const K& Type)
(declare-const I&. Dcr)
(declare-const I& Type)
(declare-const L&. Dcr)
(declare-const L& Type)
(declare-const D&. Dcr)
(declare-const D& Type)
(declare-const V&. Dcr)
(declare-const V& Type)
(declare-const E&. Dcr)
(declare-const E& Type)
(declare-const result! core!result.Result.)
(declare-const self! lib!kv.kvimpl_v.UntrustedKvStoreImpl.)
(declare-const key! Poly)
(declare-const idx! Int)
(assert fuel_defaults)
(assert (has_type (Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. self!) (TYPE%lib!kv.kvimpl_v.UntrustedKvStoreImpl. PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E&)))
(assert (has_type key! K&))
(assert (uInv 64 idx!))
(assert (tr_bound%lib!pmem.pmemspec_t.PersistentMemoryRegions. PM&. PM&))
(assert (tr_bound%core!hash.Hash. K&. K&))
(assert (tr_bound%core!cmp.Eq. K&. K&))
(assert (tr_bound%core!clone.Clone. K&. K&))
(assert (tr_bound%lib!pmem.pmcopy_t.PmCopy. K&. K&))
(assert (tr_bound%core!fmt.Debug. K&. K&))
(assert (tr_bound%lib!pmem.pmcopy_t.PmCopy. I&. I&))
(assert (tr_bound%lib!kv.kvimpl_t.Item. I&. I& K&. K&))
(assert (tr_bound%core!fmt.Debug. I&. I&))
(assert (tr_bound%lib!pmem.pmcopy_t.PmCopy. L&. L&))
(assert (tr_bound%core!fmt.Debug. L&. L&))
(assert (tr_bound%lib!kv.durable.durableimpl_v.DurableKvStore. D&. D& PM&. PM& K&. K& I&. I& L&. L& E&. E&))
(assert (tr_bound%lib!kv.volatile.volatileimpl_v.VolatileKvIndex. V&. V& K&. K& E&. E&))
(assert (tr_bound%core!fmt.Debug. E&. E&))
(assert (lib!kv.kvimpl_v.impl&%0.valid.? PM&. PM& K&. K& I&. I& L&. L& D&. D& V&. V& E&. E& (Poly%lib!kv.kvimpl_v.UntrustedKvStoreImpl. self!)))
(assert (not true))
(check-sat)
(exit)
